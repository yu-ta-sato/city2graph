"""
Module for creating morphological graphs from urban data.

This module provides comprehensive functionality for analyzing urban morphology
through graph representations, focusing on the relationships between private
spaces (buildings and their tessellations) and public spaces (street segments).
It creates heterogeneous graphs that capture the complex spatial relationships
inherent in urban environments. Both GeoDataFrame and NetworkX objects can be
converted to PyTorch Geometric Data or HeteroData by functions from graph.py.

The module specializes in three types of spatial relationships:
1. Private-to-private: Adjacency relationships between building tessellations
2. Public-to-public: Topological connectivity between street segments
3. Private-to-public: Interface relationships between private and public spaces
"""

# Standard library imports
import itertools
import logging
import math
import warnings

# Third-party imports
import geopandas as gpd
import networkx as nx
import numpy as np
import pandas as pd
from scipy.spatial import KDTree
from scipy.spatial.distance import pdist
from shapely.creation import linestrings as sh_linestrings
from shapely.geometry import Point

# Local imports
from .base import GeoDataProcessor
from .proximity import contiguity_graph
from .utils import create_tessellation
from .utils import dual_graph
from .utils import filter_graph_by_distance
from .utils import gdf_to_nx
from .utils import nx_to_gdf

# Public API definition
__all__ = [
    "morphological_graph",
    "private_to_private_graph",
    "private_to_public_graph",
    "public_to_public_graph",
    "segments_to_graph",
]

# Module logger configuration
logger = logging.getLogger(__name__)


# ============================================================================
# MAIN MORPHOLOGICAL GRAPH FUNCTION
# ============================================================================


# ============================================================================
# PUBLIC API - MAIN FUNCTIONS
# ============================================================================


def morphological_graph(
    buildings_gdf: gpd.GeoDataFrame,
    segments_gdf: gpd.GeoDataFrame,
    center_point: gpd.GeoSeries | gpd.GeoDataFrame | None = None,
    distance: float | None = None,
    clipping_buffer: float = math.inf,
    primary_barrier_col: str | None = "barrier_geometry",
    contiguity: str = "queen",
    keep_buildings: bool = False,
    keep_segments: bool = True,
    tolerance: float = 1e-6,
    as_nx: bool = False,
) -> tuple[dict[str, gpd.GeoDataFrame], dict[tuple[str, str, str], gpd.GeoDataFrame]] | nx.Graph:
    """
    Create a morphological graph from buildings and street segments.

    This function creates a comprehensive morphological graph that captures relationships
    between private spaces (building tessellations) and public spaces (street segments).
    The graph includes three types of relationships: private-to-private adjacency,
    public-to-public connectivity, and private-to-public interfaces.

    The 'private_id' for tessellation cells is derived from 'tess_id' (generated by
    `create_tessellation`) or assigned sequentially if 'tess_id' doesn't directly map.
    The 'public_id' for street segments is taken directly from the index of `segments_gdf`.

    Parameters
    ----------
    buildings_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing building polygons. Should contain Polygon or MultiPolygon geometries.
    segments_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing street segments. Should contain LineString geometries.
    center_point : geopandas.GeoSeries or geopandas.GeoDataFrame, optional
        Center point(s) for spatial filtering. If provided with distance parameter,
        only segments within the specified distance will be included.
    distance : float, optional
        Maximum distance from ``center_point`` for spatial filtering. When
        specified, street segments beyond this shortest-path distance are
        removed and tessellation cells are kept only if their own distance via
        these segments does not exceed this value.
    clipping_buffer : float, default=math.inf
        Buffer distance to ensure adequate context for generating tessellation.
        Must be non-negative.
    primary_barrier_col : str, optional
        Column name containing alternative geometry for public spaces. If specified and exists,
        this geometry will be used instead of the main geometry column for tessellation barriers.
    contiguity : str, default="queen"
        Type of spatial contiguity for private-to-private connections.
        Must be either "queen" or "rook".
    keep_buildings : bool, default=False
        If True, preserves building information in the tessellation output.
    keep_segments : bool, default=True
        If True, preserves the original segment LineString geometry in a column
        named 'segment_geometry' in the public nodes GeoDataFrame.
    tolerance : float, default=1e-6
        Buffer distance for public geometries when creating private-to-public connections.
        This parameter controls how close private spaces need to be to public spaces
        to establish a connection.
    as_nx : bool, default=False
        If True, convert the output to a NetworkX graph.

    Returns
    -------
    tuple[dict[str, geopandas.GeoDataFrame], dict[tuple[str, str, str], geopandas.GeoDataFrame]] | networkx.Graph
        If as_nx is False (default), returns a tuple (nodes, edges) where:

        - nodes: Dictionary containing node GeoDataFrames with keys:
            - "private": Tessellation cells (private spaces)
            - "public": Street segments (public spaces)

        - edges: Dictionary containing edge GeoDataFrames with keys:
            - ("private", "touched_to", "private"): Adjacency between tessellation cells
            - ("public", "connected_to", "public"): Connectivity between street segments
            - ("private", "faced_to", "public"): Interface between tessellation cells and street segments

        If as_nx is True, returns a NetworkX graph.

    Raises
    ------
    TypeError
        If buildings_gdf or segments_gdf are not GeoDataFrames.
    ValueError
        If contiguity parameter is not "queen" or "rook".
        If clipping_buffer is negative.

    See Also
    --------
    private_to_private_graph : Create adjacency between private spaces.
    private_to_public_graph : Create connections between private and public spaces.
    public_to_public_graph : Create connectivity between public spaces.

    Notes
    -----
    The function first filters the street network by `distance` (resulting in `segs`).
    A `segs_buffer` GeoDataFrame is also created for tessellation context, potentially
    filtered by `distance + clipping_buffer` or `distance` if `center_point` and
    `distance` are provided. This `segs_buffer` is used to create enclosures and
    tessellations.
    It then establishes three types of relationships:
    1. Private-to-private: Adjacency between tessellation cells (handled by private_to_private_graph)
    2. Public-to-public: Topological connectivity between street segments
    3. Private-to-public: Spatial interfaces between tessellations and streets

    The output follows a heterogeneous graph structure suitable for network analysis
    of urban morphology.

    Examples
    --------
    >>> # Create morphological graph from buildings and segments
    >>> nodes, edges = morphological_graph(buildings_gdf, segments_gdf)
    >>> private_nodes = nodes['private']
    >>> public_nodes = nodes['public']
    """
    # Define fixed ID column names
    private_id_col = "private_id"
    public_id_col = "public_id"

    _validate_input_gdfs(buildings_gdf, segments_gdf)

    # Validate contiguity parameter
    if contiguity not in {"queen", "rook"}:
        msg = "contiguity must be 'queen' or 'rook'"
        raise ValueError(msg)

    # Validate clipping_buffer
    if clipping_buffer < 0:
        msg = "clipping_buffer cannot be negative."
        raise ValueError(msg)

    if isinstance(buildings_gdf.index, pd.MultiIndex):
        buildings_gdf = buildings_gdf.copy()
        buildings_gdf.index = buildings_gdf.index.to_flat_index()

    # Ensure CRS consistency between buildings and segments
    segments_gdf = _ensure_crs_consistency(buildings_gdf, segments_gdf)

    segments_gdf = segments_gdf.copy()
    segments_gdf[public_id_col] = segments_gdf.index

    segments_filtered, segments_buffer = _process_segments(
        segments_gdf,
        center_point,
        distance,
        clipping_buffer,
    )

    tessellation = _create_and_filter_tessellation(
        buildings_gdf,
        segments_buffer,
        segments_filtered,
        primary_barrier_col,
        distance,
        clipping_buffer,
        center_point,
        keep_buildings,
        private_id_col,
    )

    nodes, edges = _build_morphological_layers(
        tessellation,
        segments_filtered,
        primary_barrier_col,
        contiguity,
        tolerance,
        private_id_col,
        public_id_col,
        keep_segments,
    )

    return (nodes, edges) if not as_nx else gdf_to_nx(nodes, edges)


# ============================================================================
# PRIVATE TO PRIVATE GRAPH
# ============================================================================


def private_to_private_graph(
    private_gdf: gpd.GeoDataFrame,
    group_col: str | None = None,
    contiguity: str = "queen",
    as_nx: bool = False,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame] | nx.Graph:
    """
    Create edges between contiguous private polygons based on spatial adjacency.

    This function identifies spatial adjacency relationships between private polygons
    (e.g., tessellation cells) using either Queen or Rook contiguity criteria.
    Optionally groups connections within specified groups (e.g., enclosures).
    The input `private_gdf` is expected to have a 'private_id' column.

    Parameters
    ----------
    private_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing private space polygons. Must contain a 'private_id' column.
    group_col : str, optional
        Column name for grouping connections. Only polygons within the same group
        will be connected. If None, all polygons are considered as one group.
    contiguity : str, default="queen"
        Type of spatial contiguity to use. Must be either "queen" or "rook".
        Queen contiguity includes vertex neighbors, Rook includes only edge neighbors.
    as_nx : bool, default=False
        If True, convert the output to a NetworkX graph.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame] or networkx.Graph
        If as_nx is False (default), returns a tuple (nodes, edges) where:

        - nodes is a geopandas.GeoDataFrame containing the private nodes.
        - edges is a geopandas.GeoDataFrame containing the adjacency connections.

        If as_nx is True, returns a networkx.Graph representing the private adjacency.

    Raises
    ------
    TypeError
        If private_gdf is not a GeoDataFrame.
    ValueError
        If contiguity not in {"queen", "rook"}, or if group_col doesn't exist.

    See Also
    --------
    morphological_graph : Main function that creates comprehensive morphological graphs.
    private_to_public_graph : Create connections between private and public spaces.
    public_to_public_graph : Create connectivity between public spaces.

    Notes
    -----
    The function uses libpysal's spatial weights to determine adjacency relationships.
    Edge geometries are created as LineStrings connecting polygon centroids.
    Self-connections and duplicate edges are automatically filtered out.
    The input private_gdf is expected to have a 'private_id' column.

    Examples
    --------
    >>> # Create private-to-private adjacency graph
    >>> nodes, edges = private_to_private_graph(tessellation_gdf)
    >>> # With grouping by enclosures
    >>> nodes, edges = private_to_private_graph(tessellation_gdf, group_col='enclosure_id')
    """
    # Input validation
    _validate_single_gdf_input(private_gdf, "private_gdf")

    private_id_col = "private_id"

    # If not empty, require the ID column
    if not private_gdf.empty and private_id_col not in private_gdf.columns:
        msg = f"Expected ID column '{private_id_col}' not found in private_gdf."
        raise ValueError(msg)

    # Validate that the contiguity type is supported
    if contiguity not in {"queen", "rook"}:
        msg = "contiguity must be either 'queen' or 'rook'"
        raise ValueError(msg)

    # Validate that the group column exists if specified
    if group_col and group_col not in private_gdf.columns:
        msg = f"group_col '{group_col}' not found in private_gdf columns"
        raise ValueError(msg)

    # Handle empty or insufficient data: return empty edges GeoDataFrame
    if private_gdf.empty or len(private_gdf) < 2:
        return _return_empty_private_edges(private_gdf, group_col, as_nx)

    # Deduplicate based on private_id to avoid libpysal errors
    # This handles cases where private_gdf has been joined with other data (e.g. buildings)
    # resulting in multiple rows per private space. We only need unique private spaces for the graph.
    gdf_unique = private_gdf.drop_duplicates(subset=[private_id_col])

    # Set index to private_id so contiguity_graph returns edges with correct IDs
    # We must ensure the index is unique for libpysal
    gdf_indexed = gdf_unique.set_index(private_id_col)

    _, edges_gdf = contiguity_graph(
        gdf_indexed,
        contiguity=contiguity,
        as_nx=False,
    )

    if edges_gdf.empty:
        return _return_empty_private_edges(private_gdf, group_col, as_nx)

    # contiguity_graph returns edges with MultiIndex (source, target) containing the index values
    # (which are now private_ids). We reset index to get them as columns.
    edges_gdf = edges_gdf.reset_index()

    cols = edges_gdf.columns.tolist()
    cols[0] = "from_private_id"
    cols[1] = "to_private_id"
    edges_gdf.columns = cols

    # Add group column if applicable and filter edges
    if group_col:
        # Create a mapping from private_id to group
        # Use gdf_unique to ensure unique index
        id_to_group = gdf_unique.set_index(private_id_col)[group_col]

        # Map group values to edges
        edges_gdf[group_col] = edges_gdf["from_private_id"].map(id_to_group)
        to_group = edges_gdf["to_private_id"].map(id_to_group)

        # Filter edges where source and target are in the same group
        edges_gdf = edges_gdf[edges_gdf[group_col] == to_group].copy()

    else:
        edges_gdf["group"] = 0

    if as_nx:
        return gdf_to_nx(nodes=gdf_unique, edges=edges_gdf)

    return gdf_unique, edges_gdf


# ============================================================================
# PRIVATE TO PUBLIC GRAPH
# ============================================================================


def private_to_public_graph(
    private_gdf: gpd.GeoDataFrame,
    public_gdf: gpd.GeoDataFrame,
    primary_barrier_col: str | None = None,
    tolerance: float = 1e-6,
    as_nx: bool = False,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame] | nx.Graph:
    """
    Create edges between private polygons and nearby public geometries.

    This function identifies spatial relationships between private spaces (tessellations)
    and public spaces (street segments) by finding intersections between buffered public
    geometries and private polygons.
    Input GDFs are expected to have 'private_id' and 'public_id' columns respectively.

    Parameters
    ----------
    private_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing private space polygons. Expected to have a 'private_id' column.
    public_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing public space geometries (typically LineStrings).
        Expected to have a 'public_id' column.
    primary_barrier_col : str, optional
        Column name for alternative public geometry. If specified and exists,
        this geometry will be used instead of the main geometry column.
    tolerance : float, default=1e-6
        Buffer distance for public geometries to detect proximity to private spaces.
    as_nx : bool, default=False
        If True, convert the output to a NetworkX graph.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame] or networkx.Graph
        If as_nx is False (default), returns a tuple (nodes, edges) where:

        - nodes is a geopandas.GeoDataFrame containing the combined private and public nodes.
        - edges is a geopandas.GeoDataFrame containing the edges between private and public geometries.

        If as_nx is True, returns a networkx.Graph representing the private-to-public connections.

    Raises
    ------
    TypeError
        If private_gdf or public_gdf are not GeoDataFrames.
    ValueError
        If 'private_id' or 'public_id' columns are missing from input GDFs.

    See Also
    --------
    morphological_graph : Main function that creates comprehensive morphological graphs.
    private_to_private_graph : Create adjacency between private spaces.
    public_to_public_graph : Create connectivity between public spaces.

    Notes
    -----
    Edge geometries are created as LineStrings connecting the centroids of
    private polygons and public geometries. The function uses spatial joins
    to identify overlapping areas within the specified tolerance.
    Input GDFs are expected to have 'private_id' and 'public_id' columns respectively.

    Examples
    --------
    >>> # Create private-to-public interface graph
    >>> nodes, edges = private_to_public_graph(tessellation_gdf, segments_gdf)
    >>> # With custom tolerance
    >>> nodes, edges = private_to_public_graph(tessellation_gdf, segments_gdf, tolerance=2.0)
    """
    # Input validation
    _validate_single_gdf_input(private_gdf, "private_gdf")
    _validate_single_gdf_input(public_gdf, "public_gdf")

    private_id_col = "private_id"
    public_id_col = "public_id"

    # Handle empty data: return empty edges GeoDataFrame
    if private_gdf.empty or public_gdf.empty:
        empty_edges = _create_empty_edges_gdf(private_gdf.crs, private_id_col, public_id_col)
        all_nodes = pd.concat([private_gdf, public_gdf], ignore_index=True)

        return (
            (all_nodes, empty_edges) if not as_nx else gdf_to_nx(nodes=all_nodes, edges=empty_edges)
        )

    # Ensure required ID columns exist in the input GeoDataFrames
    if private_id_col not in private_gdf.columns:
        msg = f"Expected ID column '{private_id_col}' not found in private_gdf."
        raise ValueError(msg)
    if public_id_col not in public_gdf.columns:
        msg = f"Expected ID column '{public_id_col}' not found in public_gdf."
        raise ValueError(msg)

    # Ensure CRS consistency between private and public GeoDataFrames
    public_gdf = _ensure_crs_consistency(private_gdf, public_gdf)

    # Determine which geometry to use for the query
    query_geometry = (
        public_gdf[primary_barrier_col]
        if primary_barrier_col and primary_barrier_col in public_gdf.columns
        else public_gdf.geometry
    )

    # Use spatial index query with 'dwithin' predicate for efficient proximity search
    # This avoids creating expensive buffer geometries
    # indices[0] -> index of the geometry passed to query (public_gdf)
    # indices[1] -> index of the geometry in the sindex (private_gdf)
    public_indices, private_indices = private_gdf.sindex.query(
        query_geometry,
        predicate="dwithin",
        distance=tolerance,
    )

    # Create a DataFrame from the indices
    joined = pd.DataFrame(
        {
            private_id_col: private_gdf.iloc[private_indices][private_id_col].to_numpy(),
            public_id_col: public_gdf.iloc[public_indices][public_id_col].to_numpy(),
        }
    )

    # Drop duplicate pairs of (private_id, public_id)
    joined = joined.drop_duplicates()

    edges_gdf = _create_private_public_edges(
        joined,
        private_gdf,
        public_gdf,
        private_id_col,
        public_id_col,
    )

    nodes_gdf = pd.concat([private_gdf, public_gdf], ignore_index=True)

    return (nodes_gdf, edges_gdf) if not as_nx else gdf_to_nx(nodes=nodes_gdf, edges=edges_gdf)


# ============================================================================
# PUBLIC TO PUBLIC GRAPH
# ============================================================================


def public_to_public_graph(
    public_gdf: gpd.GeoDataFrame,
    as_nx: bool = False,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame] | nx.Graph:
    """
    Create edges between connected public segments based on topological connectivity.

    This function identifies topological connections between public space geometries
    (typically street segments) using the dual graph approach to find segments
    that share endpoints or connection points.
    The function automatically creates a unique identifier for each row if needed.

    Parameters
    ----------
    public_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing public space geometries (typically LineString).
    as_nx : bool, default=False
        If True, convert the output to a NetworkX graph.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame] or networkx.Graph
        If as_nx is False (default), returns a tuple (nodes, edges) where:

        - nodes is a geopandas.GeoDataFrame containing the public nodes.
        - edges is a geopandas.GeoDataFrame containing the topological connections.

        If as_nx is True, returns a networkx.Graph representing the public connectivity.

    Raises
    ------
    TypeError
        If public_gdf is not a GeoDataFrame.

    See Also
    --------
    morphological_graph : Main function that creates comprehensive morphological graphs.
    private_to_private_graph : Create adjacency between private spaces.
    private_to_public_graph : Create connections between private and public spaces.

    Notes
    -----
    The function uses the dual graph approach where each LineString becomes a node,
    and edges represent topological connections between segments. Edge geometries
    are created as LineStrings connecting the centroids of connected segments.

    Examples
    --------
    >>> # Create public-to-public connectivity graph
    >>> nodes, edges = public_to_public_graph(segments_gdf)
    >>> # Convert to NetworkX format
    >>> graph = public_to_public_graph(segments_gdf, as_nx=True)
    """
    # Input validation
    _validate_single_gdf_input(public_gdf, "public_gdf")

    # Handle empty or insufficient data: return empty edges GeoDataFrame
    if public_gdf.empty or len(public_gdf) < 2:
        empty_edges = _create_empty_edges_gdf(public_gdf.crs, "from_public_id", "to_public_id")

        return (
            (public_gdf, empty_edges)
            if not as_nx
            else gdf_to_nx(nodes=public_gdf, edges=empty_edges)
        )

    # Create a copy to avoid modifying the original
    public_gdf_copy = public_gdf.copy()

    if "public_id" in public_gdf_copy.columns:
        edge_id_col = "public_id"

    else:
        edge_id_col = "_edge_id"
        public_gdf_copy[edge_id_col] = [str(idx) for idx in public_gdf_copy.index]

    # Convert public_gdf to a graph
    segment_nodes, segment_edges = segments_to_graph(public_gdf_copy)

    _, dual_edges = dual_graph(
        (segment_nodes, segment_edges),
        edge_id_col=edge_id_col,
        keep_original_geom=True,
    )

    # Preserve the original MultiIndex structure and data types
    if isinstance(dual_edges.index, pd.MultiIndex):
        # Rename the MultiIndex levels for clarity and consistency
        dual_edges.index.names = ["from_public_id", "to_public_id"]

    # Reset index to ensure it is a regular DataFrame
    dual_edges = dual_edges.reset_index()

    return (public_gdf, dual_edges) if not as_nx else gdf_to_nx(nodes=public_gdf, edges=dual_edges)


# ============================================================================
# SEGMENTS TO GRAPH
# ============================================================================


def segments_to_graph(
    segments_gdf: gpd.GeoDataFrame,
    multigraph: bool = False,
    as_nx: bool = False,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame] | nx.Graph | nx.MultiGraph:
    r"""
    Convert a GeoDataFrame of LineString segments into a graph structure.

    This function takes a GeoDataFrame of LineStrings and processes it into a
    topologically explicit graph representation, consisting of a GeoDataFrame of
    unique nodes (the endpoints of the lines) and a GeoDataFrame of edges.

    The resulting nodes GeoDataFrame contains unique points representing the start
    and end points of the input line segments. The edges GeoDataFrame is a copy
    of the input, but with a new MultiIndex (`from_node_id`, `to_node_id`) that
    references the IDs in the new nodes GeoDataFrame. If `multigraph` is True
    and there are multiple edges between the same pair of nodes, an additional
    index level (`edge_key`) is added to distinguish them.

    Parameters
    ----------
    segments_gdf : geopandas.GeoDataFrame
        A GeoDataFrame where each row represents a line segment, and the
        'geometry' column contains LineString objects.
    multigraph : bool, default False
        If True, supports multiple edges between the same pair of nodes by
        adding an `edge_key` level to the MultiIndex. This is useful when
        the input contains duplicate node-to-node connections that should
        be preserved as separate edges.
    as_nx : bool, default False
        If True, returns a NetworkX graph instead of a tuple of GeoDataFrames.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame]
        A tuple containing two GeoDataFrames:

        - nodes_gdf: A GeoDataFrame of unique nodes (Points), indexed by `node_id`.
        - edges_gdf: A GeoDataFrame of edges (LineStrings), with a MultiIndex
          mapping to the `node_id` in `nodes_gdf`. If `multigraph` is True,
          the index includes a third level (`edge_key`) for duplicate connections.

    Examples
    --------
    >>> import geopandas as gpd
    >>> from shapely.geometry import LineString
    >>> # Create a GeoDataFrame of line segments
    >>> segments = gpd.GeoDataFrame(
    ...     {"road_name": ["A", "B"]},
    ...     geometry=[LineString([(0, 0), (1, 1)]), LineString([(1, 1), (1, 0)])],
    ...     crs="EPSG:32633"
    ... )
    >>> # Convert to graph representation
    >>> nodes_gdf, edges_gdf = segments_to_graph(segments)
    >>> print(nodes_gdf)
    >>> print(edges_gdf)
    node_id  geometry
    0        POINT (0 0)
    1        POINT (1 1)
    2        POINT (1 0)
                                    road_name   geometry
    from_node_id to_node_id
    0            1                  A           LINESTRING (0 0, 1 1)
    1            2                  B           LINESTRING (1 1, 1 0)

    >>> # Example with duplicate connections (multigraph)
    >>> segments_with_duplicates = gpd.GeoDataFrame(
    ...     {"road_name": ["A", "B", "C"]},
    ...     geometry=[LineString([(0, 0), (1, 1)]),
    ...               LineString([(0, 0), (1, 1)]),
    ...               LineString([(1, 1), (1, 0)])],
    ...     crs="EPSG:32633"
    ... )
    >>> nodes_gdf, edges_gdf = segments_to_graph(segments_with_duplicates, multigraph=True)
    >>> print(edges_gdf.index.names)
    ['from_node_id', 'to_node_id', 'edge_key']
    """
    processor = GeoDataProcessor()

    # Validate input
    segments_clean = processor.validate_gdf(segments_gdf, ["LineString"])

    if segments_clean is None or segments_clean.empty:
        empty_nodes = gpd.GeoDataFrame(columns=["geometry"], crs=segments_gdf.crs)
        empty_edges = gpd.GeoDataFrame(columns=["geometry"], crs=segments_gdf.crs)
        return empty_nodes, empty_edges

    # Extract coordinates
    start_coords = processor.extract_coordinates(segments_clean, start=True)
    end_coords = processor.extract_coordinates(segments_clean, start=False)

    # Create unique nodes
    all_coords = pd.concat([start_coords, end_coords]).drop_duplicates()
    coord_to_id = {coord: i for i, coord in enumerate(all_coords)}

    # Create nodes GeoDataFrame efficiently using gpd.points_from_xy
    coords_array = all_coords.to_numpy()
    x_coords = [coord[0] for coord in coords_array]
    y_coords = [coord[1] for coord in coords_array]

    # Create nodes GeoDataFrame with unique node IDs
    nodes_gdf = gpd.GeoDataFrame(
        {
            "node_id": range(len(all_coords)),
            "geometry": gpd.points_from_xy(x_coords, y_coords),
        },
        crs=segments_clean.crs,
    ).set_index("node_id", drop=True)

    # Create edges with MultiIndex
    from_ids = start_coords.map(coord_to_id)
    to_ids = end_coords.map(coord_to_id)

    edges_gdf = segments_clean.copy()

    if multigraph:
        # For multigraph, handle potential duplicate node pairs by adding edge keys
        edge_pairs_df = pd.DataFrame({"from_id": from_ids, "to_id": to_ids})
        edge_keys = edge_pairs_df.groupby(["from_id", "to_id"]).cumcount()

        edges_gdf.index = pd.MultiIndex.from_arrays(
            [from_ids, to_ids, edge_keys],
            names=["from_node_id", "to_node_id", "edge_key"],
        )
    else:
        edges_gdf.index = pd.MultiIndex.from_arrays(
            [from_ids, to_ids],
            names=["from_node_id", "to_node_id"],
        )

    return gdf_to_nx(nodes=nodes_gdf, edges=edges_gdf) if as_nx else (nodes_gdf, edges_gdf)


# ============================================================================
# VALIDATION AND CRS HELPERS
# ============================================================================


def _validate_input_gdfs(buildings_gdf: gpd.GeoDataFrame, segments_gdf: gpd.GeoDataFrame) -> None:
    """
    Validate the primary input GeoDataFrames for the morphological graph function.

    This function ensures that the provided buildings and segments inputs are both
    GeoDataFrames and that their geometries are of the expected types (Polygons for
    buildings, LineStrings for segments). It serves as a critical initial check
    to prevent errors in downstream processing.

    Parameters
    ----------
    buildings_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing building polygons.
    segments_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing street segments.

    Raises
    ------
    TypeError
        If either input is not a GeoDataFrame.
    ValueError
        If the geometries are not of the expected types.

    See Also
    --------
    _validate_single_gdf_input : Validate a single GeoDataFrame.
    """
    if not isinstance(buildings_gdf, gpd.GeoDataFrame):
        msg = "buildings_gdf must be a GeoDataFrame"
        raise TypeError(msg)
    if not isinstance(segments_gdf, gpd.GeoDataFrame):
        msg = "segments_gdf must be a GeoDataFrame"
        raise TypeError(msg)

    if not buildings_gdf.empty:
        building_geom_types = buildings_gdf.geometry.geom_type.unique()
        if not all(geom_type in {"Polygon", "MultiPolygon"} for geom_type in building_geom_types):
            msg = (
                f"buildings_gdf must contain only Polygon or MultiPolygon geometries. "
                f"Found: {', '.join(building_geom_types)}"
            )
            raise ValueError(msg)

    if not segments_gdf.empty:
        # Assuming LineString is required for operations like dual_graph
        segment_geom_types = segments_gdf.geometry.geom_type.unique()
        if not all(geom_type in {"LineString"} for geom_type in segment_geom_types):
            msg = (
                f"segments_gdf must contain only LineString geometries. "
                f"Found: {', '.join(segment_geom_types)}"
            )
            raise ValueError(msg)


def _validate_single_gdf_input(
    gdf: gpd.GeoDataFrame,
    gdf_name: str,
) -> None:
    """
    Validate that a single input is a GeoDataFrame.

    This is a simple utility function to ensure that an input object is of type
    geopandas.GeoDataFrame, raising a TypeError with a descriptive message if it
    is not. It is used for validating individual geospatial inputs in various
    functions.

    Parameters
    ----------
    gdf : geopandas.GeoDataFrame
        The GeoDataFrame to validate.
    gdf_name : str
        The name of the GeoDataFrame, used in the error message.

    Raises
    ------
    TypeError
        If the input is not a GeoDataFrame.

    See Also
    --------
    _validate_input_gdfs : Validate both buildings and segments GeoDataFrames.
    """
    if not isinstance(gdf, gpd.GeoDataFrame):
        msg = f"{gdf_name} must be a GeoDataFrame"
        raise TypeError(msg)


def _ensure_crs_consistency(
    target_gdf: gpd.GeoDataFrame,
    source_gdf: gpd.GeoDataFrame,
) -> gpd.GeoDataFrame:
    """
    Ensure that the source GeoDataFrame has the same CRS as the target.

    This function checks if the Coordinate Reference System (CRS) of the source
    GeoDataFrame matches that of the target. If they do not match, it reprojects
    the source to the target's CRS and issues a warning. This is essential for
    ensuring that spatial operations between the two GeoDataFrames are valid.

    Parameters
    ----------
    target_gdf : geopandas.GeoDataFrame
        The GeoDataFrame with the target CRS.
    source_gdf : geopandas.GeoDataFrame
        The GeoDataFrame to check and potentially reproject.

    Returns
    -------
    geopandas.GeoDataFrame
        The source GeoDataFrame, reprojected to the target CRS if necessary.

    Warns
    -----
    RuntimeWarning
        If a CRS mismatch is detected and reprojection is performed.
    """
    if source_gdf.crs != target_gdf.crs:
        warnings.warn(
            "CRS mismatch detected, reprojecting",
            RuntimeWarning,
            stacklevel=3,
        )  # Warn user
        return source_gdf.to_crs(target_gdf.crs)
    return source_gdf


# ============================================================================
# ORCHESTRATION HELPERS (for morphological_graph)
# ============================================================================


def _process_segments(
    segments_gdf: gpd.GeoDataFrame,
    center_point: gpd.GeoSeries | gpd.GeoDataFrame | None,
    distance: float | None,
    clipping_buffer: float,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame]:
    """
    Process segments: create graph, filter by distance, and create buffer context.

    This function converts the input segments GeoDataFrame to a graph representation,
    filters it by network distance if a center point and distance are provided,
    and creates a buffered version of the segments for tessellation context.

    Parameters
    ----------
    segments_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing street segments.
    center_point : geopandas.GeoSeries or geopandas.GeoDataFrame or None
        Center point(s) for spatial filtering.
    distance : float or None
        Maximum distance from ``center_point`` for spatial filtering.
    clipping_buffer : float
        Buffer distance to ensure adequate context for generating tessellation.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame]
        A tuple containing:
        - segments_filtered: Segments filtered by distance (or all segments if no filter).
        - segments_buffer: Segments used for tessellation context (buffered filter).
    """
    # Convert segments to a graph representation for efficient filtering.
    if not segments_gdf.empty:
        segment_nodes, segment_edges = segments_to_graph(segments_gdf)
        segments_graph = gdf_to_nx(nodes=segment_nodes, edges=segment_edges)
    else:
        segment_nodes, segment_edges = segments_to_graph(segments_gdf)
        segments_graph = nx.Graph()

    # Filter segments by network distance for the final graph if center_point and distance are provided
    if center_point is not None and distance is not None and not segments_gdf.empty:
        filtered_segments_graph = filter_graph_by_distance(segments_graph, center_point, distance)
        segments_filtered = nx_to_gdf(filtered_segments_graph, nodes=False, edges=True)
    else:
        segments_filtered = segment_edges

    if center_point is not None and distance is not None and not segments_gdf.empty:
        if not math.isinf(clipping_buffer):
            # Finite clipping_buffer: use distance + clipping_buffer for segments_buffer radius
            buffer_radius = distance + clipping_buffer
            segments_buffer_graph = filter_graph_by_distance(
                segments_graph,
                center_point,
                buffer_radius,
            )
            segments_buffer = nx_to_gdf(segments_buffer_graph, nodes=False, edges=True)
        else:  # clipping_buffer is math.inf
            # Fallback to 'distance' as radius for segments_buffer
            segments_buffer_graph = filter_graph_by_distance(
                segments_graph,
                center_point,
                distance,
            )
            segments_buffer = nx_to_gdf(segments_buffer_graph, nodes=False, edges=True)
    else:
        # No center_point or no distance, so segments_buffer is not filtered by distance
        segments_buffer = segment_edges

    return segments_filtered, segments_buffer


def _create_and_filter_tessellation(
    buildings_gdf: gpd.GeoDataFrame,
    segments_buffer: gpd.GeoDataFrame,
    segments_filtered: gpd.GeoDataFrame,
    primary_barrier_col: str | None,
    distance: float | None,
    clipping_buffer: float,
    center_point: gpd.GeoSeries | gpd.GeoDataFrame | None,
    keep_buildings: bool,
    private_id_col: str,
) -> gpd.GeoDataFrame:
    """
    Create tessellation and apply spatial filters.

    This function creates a tessellation from buildings and barriers, renames the ID column,
    and filters the tessellation based on adjacency to segments and network distance.

    Parameters
    ----------
    buildings_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing building polygons.
    segments_buffer : geopandas.GeoDataFrame
        Buffered segments used for tessellation context.
    segments_filtered : geopandas.GeoDataFrame
        Filtered segments used for adjacency checks.
    primary_barrier_col : str or None
        Column name containing alternative geometry for public spaces.
    distance : float or None
        Maximum distance from ``center_point`` for spatial filtering.
    clipping_buffer : float
        Buffer distance to ensure adequate context for generating tessellation.
    center_point : geopandas.GeoSeries or geopandas.GeoDataFrame or None
        Center point(s) for spatial filtering.
    keep_buildings : bool
        If True, preserves building information in the tessellation output.
    private_id_col : str
        Name of the private ID column.

    Returns
    -------
    geopandas.GeoDataFrame
        The created and filtered tessellation GeoDataFrame.
    """
    barriers = _prepare_barriers(segments_buffer, primary_barrier_col)
    # Create tessellation based on buildings and prepared barriers
    tessellation = create_tessellation(
        buildings_gdf,
        primary_barriers=None if barriers.empty else barriers,  # Use barriers if available
    )

    tessellation = tessellation.rename(columns={"tess_id": private_id_col})

    # Ensure the fixed private ID column exists, creating a sequential ID if necessary
    if private_id_col not in tessellation.columns:
        tessellation[private_id_col] = range(len(tessellation))  # Assign sequential private IDs

    # Determine max_distance for filtering tessellation adjacent to segments
    max_distance_for_adj_filter = distance + clipping_buffer if distance is not None else math.inf

    tessellation = _filter_adjacent_tessellation(
        tessellation,
        segments_filtered,  # Use 'segments_filtered' (final graph segments) for adjacency check
        max_distance=max_distance_for_adj_filter,  # Max distance for adjacency
    )

    # Further filter tessellation by network distance if center_point and distance are specified
    if center_point is not None and distance is not None:
        tessellation = _filter_tessellation_by_network_distance(
            tessellation,
            segments_filtered,  # Use 'segments_filtered' for network distance calculation
            center_point,
            distance,  # Max network distance
        )

    # Optionally preserve building information by joining tessellation with buildings
    if keep_buildings:
        tessellation = _add_building_info(tessellation, buildings_gdf)

    return tessellation


def _build_morphological_layers(
    tessellation: gpd.GeoDataFrame,
    segments_filtered: gpd.GeoDataFrame,
    primary_barrier_col: str | None,
    contiguity: str,
    tolerance: float,
    private_id_col: str,
    public_id_col: str,
    keep_segments: bool = True,
) -> tuple[dict[str, gpd.GeoDataFrame], dict[tuple[str, str, str], gpd.GeoDataFrame]]:
    """
    Build the node and edge layers for the morphological graph.

    This function orchestrates the creation of private-to-private, public-to-public,
    and private-to-public graphs and organizes them into a heterogeneous graph structure.

    Parameters
    ----------
    tessellation : geopandas.GeoDataFrame
        GeoDataFrame containing tessellation cells (private nodes).
    segments_filtered : geopandas.GeoDataFrame
        GeoDataFrame containing filtered segments (public nodes).
    primary_barrier_col : str or None
        Column name containing alternative geometry for public spaces.
    contiguity : str
        Type of spatial contiguity for private-to-private connections.
    tolerance : float
        Buffer distance for public geometries when creating private-to-public connections.
    private_id_col : str
        Name of the private ID column.
    public_id_col : str
        Name of the public ID column.
    keep_segments : bool, default True
        If True, preserves the original segment LineString geometry in a column
        named 'segment_geometry' in the public nodes GeoDataFrame.

    Returns
    -------
    tuple[dict[str, geopandas.GeoDataFrame], dict[tuple[str, str, str], geopandas.GeoDataFrame]]
        A tuple containing:
        - nodes: Dictionary with keys "private" and "public" containing node GeoDataFrames
        - edges: Dictionary with relationship type keys containing edge GeoDataFrames
    """
    # Determine group_col for private_to_private_graph
    group_col_for_priv_priv: str | None = "enclosure_index"
    if group_col_for_priv_priv not in tessellation.columns:
        if not tessellation.empty:
            logger.warning(
                "Column '%s' not found in tessellation. "
                "Private-to-private graph will not use grouping.",
                group_col_for_priv_priv,
            )
        group_col_for_priv_priv = None

    _, private_to_private_edges = private_to_private_graph(
        tessellation,
        group_col=group_col_for_priv_priv,
        contiguity=contiguity,
    )

    _, public_to_public_edges = public_to_public_graph(
        segments_filtered,
    )

    _, private_to_public_edges = private_to_public_graph(
        tessellation,
        segments_filtered,
        primary_barrier_col=primary_barrier_col,
        tolerance=tolerance,
    )

    # Log warning if no private-public connections found
    if private_to_public_edges.empty:
        logger.warning("No private to public connections found")

    # Prepare private nodes with Point geometry (centroids)
    # Preserve original tessellation geometry in tessellation_geometry column
    private_nodes = tessellation.copy()
    private_nodes["tessellation_geometry"] = private_nodes.geometry
    # Convert geometry to centroid for private nodes
    private_nodes["geometry"] = private_nodes.geometry.centroid

    # Prepare public nodes with Point geometry (centroids)
    # Optionally preserve original segment geometry in segment_geometry column
    public_nodes = segments_filtered.copy()
    if keep_segments:
        public_nodes["segment_geometry"] = public_nodes.geometry
    # Convert geometry to centroid for public nodes
    public_nodes["geometry"] = public_nodes.geometry.centroid

    nodes = {
        "private": _set_node_index(private_nodes, private_id_col),
        "public": _set_node_index(public_nodes, public_id_col),
    }

    # Organize edges into a dictionary with relationship types as keys
    edges = {
        ("private", "touched_to", "private"): _set_edge_index(
            private_to_private_edges,
            "from_private_id",
            "to_private_id",
        ),
        ("public", "connected_to", "public"): _set_edge_index(
            public_to_public_edges,
            "from_public_id",
            "to_public_id",
        ),
        ("private", "faced_to", "public"): _set_edge_index(
            private_to_public_edges,
            "private_id",
            "public_id",
        ),
    }

    return nodes, edges


# ============================================================================
# DATA PREPARATION HELPERS
# ============================================================================


def _prepare_barriers(
    segments: gpd.GeoDataFrame,
    geom_col: str | None,
) -> gpd.GeoDataFrame:
    """
    Prepare the barrier geometries for tessellation.

    This function selects the appropriate geometry column from the segments
    GeoDataFrame to be used as barriers in the tessellation process. If an
    alternative geometry column is specified and exists, it is used; otherwise,
    the default geometry column is used.

    Parameters
    ----------
    segments : geopandas.GeoDataFrame
        The street segments GeoDataFrame.
    geom_col : str, optional
        The name of an alternative geometry column to use for the barriers.

    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame containing the prepared barrier geometries.
    """
    if geom_col and geom_col in segments.columns and geom_col != "geometry":
        return gpd.GeoDataFrame(
            segments.drop(columns=["geometry"]),
            geometry=segments[geom_col],
            crs=segments.crs,
        )
    return segments.copy()


def _add_building_info(
    tessellation: gpd.GeoDataFrame,
    buildings: gpd.GeoDataFrame,
) -> gpd.GeoDataFrame:
    """
    Add building information to tessellation.

    This function performs a spatial join between the tessellation GeoDataFrame
    and the buildings GeoDataFrame to associate each tessellation cell with
    the building(s) it contains or intersects. It adds a new column
    `building_geometry` to the tessellation, containing the geometry of the
    intersecting building.

    Parameters
    ----------
    tessellation : geopandas.GeoDataFrame
        The tessellation GeoDataFrame to which building information will be added.
    buildings : geopandas.GeoDataFrame
        The GeoDataFrame containing building geometries.

    Returns
    -------
    geopandas.GeoDataFrame
        The tessellation GeoDataFrame with an added `building_geometry` column.
    """
    joined = gpd.sjoin(tessellation, buildings, how="left", predicate="intersects")

    # If 'index_right' exists (meaning some joins occurred), map building geometries
    if "index_right" in joined.columns:
        # Create a mapping from building index to building geometry
        building_geom_map = buildings.geometry.to_dict()

        # Use the 'index_right' (building indices) to look up geometries from the map
        # This creates a pandas Series of Shapely geometries.
        building_geometries_series = joined["index_right"].map(building_geom_map)

        # Convert this pandas Series to a GeoSeries, assigning the CRS from the source 'buildings' GDF
        joined["building_geometry"] = gpd.GeoSeries(building_geometries_series, crs=buildings.crs)

        # Remove the temporary 'index_right' column
        joined = joined.drop(columns=["index_right"])

    return joined  # Return tessellation with added building geometry (if any)


# ============================================================================
# SPATIAL FILTERING HELPERS
# ============================================================================


def _filter_adjacent_tessellation(
    tessellation: gpd.GeoDataFrame,
    segments: gpd.GeoDataFrame,
    max_distance: float = math.inf,
) -> gpd.GeoDataFrame:
    """
    Filter tessellation cells to include only those adjacent to segments.

    This function filters a tessellation GeoDataFrame to retain only the cells
    that are within a specified maximum Euclidean distance of the provided street
    segments. If the tessellation is grouped by enclosures, the filtering is
    performed independently for each enclosure, considering only the segments
    that intersect that enclosure.

    Parameters
    ----------
    tessellation : geopandas.GeoDataFrame
        The tessellation GeoDataFrame to filter.
    segments : geopandas.GeoDataFrame
        The street segments to measure distance against.
    max_distance : float, default math.inf
        The maximum distance for a tessellation cell to be considered adjacent.

    Returns
    -------
    geopandas.GeoDataFrame
        The filtered tessellation GeoDataFrame.
    """
    # If tessellation is empty, return an empty GeoDataFrame with the same structure
    if tessellation.empty:
        return tessellation.copy()

    # If max_distance is infinite, no filtering is needed based on distance
    if math.isinf(max_distance):
        return tessellation.copy()

    # Check if 'enclosure_index' column exists for grouped processing
    enclosure_col = "enclosure_index" if "enclosure_index" in tessellation.columns else None

    # List to store filtered parts of tessellation
    filtered_parts: list[gpd.GeoDataFrame] = []

    # Iterate over each enclosure group
    for _, group in tessellation.groupby(enclosure_col):
        # Geometry of the current enclosure
        enclosure_geom = group.union_all()

        # Segments intersecting this enclosure
        segments_in_enclosure = segments[segments.intersects(enclosure_geom)]

        # Union of segments within this enclosure
        segment_union_in_enclosure = segments_in_enclosure.union_all()

        # Centroids of cells in this group
        centroids_in_group = group.geometry.centroid

        # Distances to segments in this enclosure
        distances_in_group = centroids_in_group.distance(segment_union_in_enclosure)

        # Filter cells in group by distance
        filtered_group = group.loc[distances_in_group <= max_distance]

        # Add filtered group to list
        if not filtered_group.empty:
            filtered_parts.append(filtered_group)

    # Concatenate all filtered parts into a single GeoDataFrame
    return gpd.GeoDataFrame(pd.concat(filtered_parts), crs=tessellation.crs)


def _filter_tessellation_by_network_distance(
    tessellation: gpd.GeoDataFrame,
    segments: gpd.GeoDataFrame,
    center_point: gpd.GeoSeries | gpd.GeoDataFrame | Point,
    max_distance: float,
) -> gpd.GeoDataFrame:
    """
    Filter tessellation by network distance from a center point.

    This function filters a tessellation GeoDataFrame to include only those cells
    that are within a specified network distance from a given `center_point`.
    It constructs a spatial graph combining street segments and tessellation
    centroids, then uses shortest-path calculations to determine reachability.

    Parameters
    ----------
    tessellation : geopandas.GeoDataFrame
        The tessellation GeoDataFrame to filter.
    segments : geopandas.GeoDataFrame
        The street segments GeoDataFrame used to build the network for distance calculations.
    center_point : shapely.geometry.Point or geopandas.GeoSeries or geopandas.GeoDataFrame
        The geographic center point(s) from which to calculate network distances.
    max_distance : float
        The maximum network distance (e.g., in meters) for a tessellation cell to be included.

    Returns
    -------
    geopandas.GeoDataFrame
        The filtered tessellation GeoDataFrame, containing only cells within the specified
        network distance from the center point.
    """
    # Return a copy of tessellation if it or segments are empty
    if tessellation.empty or segments.empty:
        return tessellation.copy()

    # Get centroids of tessellation cells
    tessellation_centroids = tessellation.geometry.centroid

    # Build a spatial graph including segment endpoints and tessellation centroids as nodes
    graph, centroid_iloc_to_node_id, segment_node_positions = _build_spatial_graph(
        segments,
        tessellation_centroids,
    )

    # Connect tessellation centroid nodes to the nearest segment graph nodes
    _connect_centroids_to_segment_graph(
        graph,
        tessellation_centroids,
        centroid_iloc_to_node_id,
        segment_node_positions,
    )

    _connect_centroids_to_centroids(graph, tessellation_centroids, centroid_iloc_to_node_id)

    # Normalize center_point input to a single Shapely Point geometry
    center_geom = center_point.iloc[0] if isinstance(center_point, gpd.GeoSeries) else center_point

    # Find the graph node closest to the geographic center_geom
    center_node_id_in_graph = _find_closest_node_to_center(graph, center_geom)

    # Filter centroid ilocs based on network path length from the center_node_id_in_graph
    keep_ilocs = _filter_nodes_by_path_length(
        graph,
        center_node_id_in_graph,
        max_distance,
        centroid_iloc_to_node_id,
    )

    # Return the subset of the original tessellation corresponding to the kept ilocs
    return tessellation.iloc[sorted(keep_ilocs)].copy()


def _filter_nodes_by_path_length(
    graph: nx.Graph,
    source_node_id: str,
    max_distance: float,
    centroid_iloc_to_node_id: dict[int, str],
) -> list[int]:
    """
    Filter nodes by their shortest path length from a source node.

    This function calculates the shortest path distance from a given source node to
    all other nodes in the graph using Dijkstra's algorithm. It then returns a list
    of the integer locations (ilocs) of the tessellation centroids whose corresponding
    nodes are within the specified maximum distance.

    Parameters
    ----------
    graph : networkx.Graph
        The graph to perform the search on.
    source_node_id : str
        The ID of the source node for the path length calculation.
    max_distance : float
        The maximum path length for a node to be included.
    centroid_iloc_to_node_id : dict[int, str]
        A mapping from centroid integer location to its graph node ID.

    Returns
    -------
    list[int]
        A list of integer locations of the centroids that are within the distance.
    """
    if source_node_id not in graph:
        # This can happen if the center point is very far from any graph node
        logger.warning("Source node for distance filtering not found in graph.")
        return []

    lengths = nx.single_source_dijkstra_path_length(
        graph,
        source_node_id,
        weight="length",
    )

    # Get the ilocs of tessellation centroids that are within the max_distance
    keep_ilocs = []
    for iloc, node_id in centroid_iloc_to_node_id.items():
        if node_id in lengths and lengths[node_id] <= max_distance:
            keep_ilocs.append(iloc)
    return keep_ilocs


# ============================================================================
# SPATIAL GRAPH CONSTRUCTION HELPERS
# ============================================================================


def _build_spatial_graph(
    segments: gpd.GeoDataFrame,
    tessellation_centroids: gpd.GeoSeries,
) -> tuple[nx.Graph, dict[int, str], dict[str, tuple[float, float]]]:
    """
    Build a spatial graph from segments and tessellation centroids.

    This function creates a unified NetworkX graph that combines the street segment
    network with the tessellation centroids. The segment endpoints and the centroids
    are all treated as nodes in this temporary graph, which is used for calculating
    network distances.

    Parameters
    ----------
    segments : geopandas.GeoDataFrame
        The street segments GeoDataFrame.
    tessellation_centroids : geopandas.GeoSeries
        A GeoSeries of tessellation centroid points.

    Returns
    -------
    tuple[networkx.Graph, dict[int, str], dict[str, tuple[float, float]]]
        A tuple containing the combined graph, a mapping from centroid integer
        location to node ID, and a dictionary of segment node positions.
    """
    graph = gdf_to_nx(edges=segments)

    # Get positions (coordinates) of segment graph nodes
    segment_node_positions = nx.get_node_attributes(graph, "pos")

    centroid_iloc_to_node_id = {
        i: f"tess_centroid_{i}" for i, _ in enumerate(tessellation_centroids)
    }

    centroid_nodes = [
        (f"tess_centroid_{i}", {"pos": (point.x, point.y), "type": "centroid_node"})
        for i, point in enumerate(tessellation_centroids)
    ]

    # Add tessellation centroid nodes to the graph
    graph.add_nodes_from(centroid_nodes)
    return graph, centroid_iloc_to_node_id, segment_node_positions


def _connect_centroids_to_segment_graph(
    graph: nx.Graph,
    tessellation_centroids: gpd.GeoSeries,
    centroid_iloc_to_node_id: dict[int, str],
    segment_node_positions: dict[str, tuple[float, float]],
) -> None:
    """
    Connect centroid nodes to their nearest segment graph nodes.

    This function uses a KDTree for efficient nearest neighbor search to find the
    closest segment node for each tessellation centroid. It then adds edges to the
    graph connecting each centroid to its nearest segment node, with the edge
    length representing the Euclidean distance.

    Parameters
    ----------
    graph : networkx.Graph
        The graph to which the new edges will be added.
    tessellation_centroids : geopandas.GeoSeries
        The GeoSeries of tessellation centroid points.
    centroid_iloc_to_node_id : dict[int, str]
        A mapping from centroid integer location to its graph node ID.
    segment_node_positions : dict[str, tuple[float, float]]
        A dictionary of segment node positions.
    """
    # Prepare segment node IDs and their coordinates for KDTree
    segment_node_ids = list(segment_node_positions.keys())
    segment_node_coords = [list(coord) for coord in segment_node_positions.values()]
    segment_coords_array = np.array(segment_node_coords)

    # Build KDTree from segment graph node coordinates for efficient nearest neighbor search
    kdtree = KDTree(segment_coords_array)

    # Prepare centroid coordinates for querying the KDTree
    centroid_coords = [(point.x, point.y) for point in tessellation_centroids.tolist()]
    centroid_coords_array = np.array(centroid_coords)

    # Query KDTree: for each centroid, find the nearest segment graph node and distance to it
    distances_to_segments, segment_indices = kdtree.query(centroid_coords_array)

    # Prepare edges to connect centroids to their nearest segment graph nodes
    edges_to_add = [
        (
            centroid_iloc_to_node_id[i],
            segment_node_ids[segment_indices[i]],
            {"length": distances_to_segments[i]},
        )
        for i in range(len(tessellation_centroids))
        if 0 <= segment_indices[i] < len(segment_node_ids)
    ]
    # Add the new edges to the graph
    if edges_to_add:
        graph.add_edges_from(edges_to_add)


def _connect_centroids_to_centroids(
    graph: nx.Graph,
    tessellation_centroids: gpd.GeoSeries,
    centroid_iloc_to_node_id: dict[int, str],
) -> None:
    """
    Connect centroid nodes to each other based on Euclidean distance.

    This function creates a complete graph between all the tessellation centroid
    nodes, where the weight of each edge is the Euclidean distance between the
    centroids. This allows for pathfinding between centroids that may not be
    directly connected to the street network.

    Parameters
    ----------
    graph : networkx.Graph
        The graph to which the new edges will be added.
    tessellation_centroids : geopandas.GeoSeries
        The GeoSeries of tessellation centroid points.
    centroid_iloc_to_node_id : dict[int, str]
        A mapping from centroid integer location to its graph node ID.
    """
    relevant_ilocs = sorted(centroid_iloc_to_node_id.keys())

    # Extract centroid Point geometries and their graph node IDs in a consistent, sorted order
    points_to_connect = tessellation_centroids.iloc[relevant_ilocs]
    node_ids_ordered = [centroid_iloc_to_node_id[iloc] for iloc in relevant_ilocs]

    coords_array = np.array([(point.x, point.y) for point in points_to_connect])

    pairwise_distances = pdist(coords_array, metric="euclidean")

    # List to store edges to be added to the graph
    edges_to_add = []

    # Generate all unique pairs of ordered node IDs using itertools.combinations
    # The order of pairs matches the order of distances in pairwise_distances
    for idx, (node_id1, node_id2) in enumerate(itertools.combinations(node_ids_ordered, 2)):
        distance = pairwise_distances[idx]
        edges_to_add.append((node_id1, node_id2, {"length": distance}))

    # Add all new centroid-to-centroid edges to the graph
    if edges_to_add:
        graph.add_edges_from(edges_to_add)


def _find_closest_node_to_center(
    graph: nx.Graph,
    center_point_geom: Point,
) -> str:
    """
    Find the graph node ID closest to a geometric center point.

    This function uses a KDTree to efficiently find the nearest node in the graph
    to a given geometric point. This is used to identify the starting node for
    network distance calculations when filtering by distance from a center point.

    Parameters
    ----------
    graph : networkx.Graph
        The graph to search within.
    center_point_geom : shapely.geometry.Point
        The geometric point to find the closest node to.

    Returns
    -------
    str
        The ID of the closest node in the graph.
    """
    pos = nx.get_node_attributes(graph, "pos")

    node_ids = list(pos.keys())
    node_coords = np.array(list(pos.values()))

    # Create a KDTree for efficient nearest neighbor search
    kdtree = KDTree(node_coords)

    # Query for the closest node to the center point
    _, idx = kdtree.query([center_point_geom.x, center_point_geom.y])

    # Return the ID of the closest node
    return str(node_ids[idx])


# ============================================================================
# EDGE CREATION HELPERS
# ============================================================================


def _create_private_public_edges(
    joined: gpd.GeoDataFrame,
    private_gdf: gpd.GeoDataFrame,
    public_gdf: gpd.GeoDataFrame,
    private_id_col: str,
    public_id_col: str,
) -> gpd.GeoDataFrame:
    """
    Create edge geometries between private and public spaces.

    This function creates LineString geometries connecting the centroids of
    intersecting private and public spaces.

    Parameters
    ----------
    joined : geopandas.GeoDataFrame
        DataFrame containing intersecting private and public IDs.
    private_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing private space polygons.
    public_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing public space geometries.
    private_id_col : str
        Name of the private ID column.
    public_id_col : str
        Name of the public ID column.

    Returns
    -------
    geopandas.GeoDataFrame
        GeoDataFrame containing the created edges with LineString geometries.
    """
    joined_with_geom = joined.copy()

    if joined_with_geom.empty:
        # Create empty GeoDataFrame with required columns and geometry
        return gpd.GeoDataFrame(
            joined_with_geom,
            geometry=gpd.GeoSeries([], crs=private_gdf.crs),
            crs=private_gdf.crs,
        )

    # Filter to only relevant IDs to avoid computing centroids for the entire dataset
    relevant_private_ids = joined_with_geom[private_id_col].unique()
    relevant_public_ids = joined_with_geom[public_id_col].unique()

    private_subset = private_gdf[private_gdf[private_id_col].isin(relevant_private_ids)]
    public_subset = public_gdf[public_gdf[public_id_col].isin(relevant_public_ids)]

    # Compute centroids only for the subset
    private_centroids_map = (
        private_subset.drop_duplicates(subset=[private_id_col])
        .set_index(private_id_col)
        .geometry.centroid
    )
    public_centroids_map = (
        public_subset.drop_duplicates(subset=[public_id_col])
        .set_index(public_id_col)
        .geometry.centroid
    )

    private_centroids = private_centroids_map.loc[joined_with_geom[private_id_col]].reset_index(
        drop=True,
    )
    public_centroids = public_centroids_map.loc[joined_with_geom[public_id_col]].reset_index(
        drop=True,
    )

    # Extract coordinates and ensure 2D array shape
    private_coords = np.array(list(zip(private_centroids.x, private_centroids.y, strict=True)))
    public_coords = np.array(list(zip(public_centroids.x, public_centroids.y, strict=True)))

    # Ensure coords are 2D by reshaping if needed
    private_coords = private_coords.reshape(-1, 2)
    public_coords = public_coords.reshape(-1, 2)

    # Stack coordinates for LineString creation
    line_coords = np.stack((private_coords, public_coords), axis=1)
    joined_with_geom["geometry"] = list(sh_linestrings(line_coords))

    # Convert the DataFrame with edge geometries to a GeoDataFrame
    return gpd.GeoDataFrame(joined_with_geom, geometry="geometry", crs=private_gdf.crs)


# ============================================================================
# UTILITY HELPERS
# ============================================================================


def _return_empty_private_edges(
    private_gdf: gpd.GeoDataFrame,
    group_col: str | None,
    as_nx: bool,
) -> tuple[gpd.GeoDataFrame, gpd.GeoDataFrame] | nx.Graph:
    """
    Return an empty private-to-private graph with the correct structure.

    This helper function creates an empty edge GeoDataFrame with the appropriate
    columns and returns it along with the input nodes, either as a tuple or
    as a NetworkX graph depending on the `as_nx` parameter.

    Parameters
    ----------
    private_gdf : geopandas.GeoDataFrame
        GeoDataFrame containing private space polygons.
    group_col : str, optional
        Column name for grouping connections.
    as_nx : bool
        If True, convert the output to a NetworkX graph.

    Returns
    -------
    tuple[geopandas.GeoDataFrame, geopandas.GeoDataFrame] | networkx.Graph
        Empty graph structure.
    """
    group_cols = [group_col] if group_col else ["group"]
    empty_edges = _create_empty_edges_gdf(
        private_gdf.crs,
        "from_private_id",
        "to_private_id",
        group_cols,
    )
    return (
        (private_gdf, empty_edges) if not as_nx else gdf_to_nx(nodes=private_gdf, edges=empty_edges)
    )


def _create_empty_edges_gdf(
    crs: str | int | None,
    from_col: str,  # Name for the 'from' node ID column
    to_col: str,  # Name for the 'to' node ID column
    extra_cols: list[str] | None = None,  # Optional list of additional column names
) -> gpd.GeoDataFrame:
    """
    Create an empty edges GeoDataFrame with specified column structure.

    This helper function generates an empty GeoDataFrame suitable for representing
    graph edges, ensuring it has the correct column names for 'from' and 'to'
    node IDs, and optionally additional columns, along with a geometry column
    and a specified Coordinate Reference System (CRS). This is useful for
    initializing empty edge GeoDataFrames when no connections are found or
    when setting up a new graph structure.

    Parameters
    ----------
    crs : str, int, or None
        Coordinate reference system.
    from_col : str
        Name for the 'from' node ID column.
    to_col : str
        Name for the 'to' node ID column.
    extra_cols : list[str], optional
        Optional list of additional column names.

    Returns
    -------
    geopandas.GeoDataFrame
        Empty GeoDataFrame with specified columns.
    """
    # Initialize list of column names with 'from' and 'to' ID columns
    columns = [from_col, to_col]
    # Add any extra columns if provided
    if extra_cols:
        columns.extend(extra_cols)
    # Add the 'geometry' column name (standard for GeoDataFrames)
    columns.append("geometry")

    # Create an empty GeoDataFrame with the defined columns, geometry column, and CRS
    return gpd.GeoDataFrame(columns=columns, geometry="geometry", crs=crs)


def _set_node_index(gdf: gpd.GeoDataFrame, col: str) -> gpd.GeoDataFrame:
    """
    Set GeoDataFrame index using a specified column, if it exists.

    This function attempts to set the index of a GeoDataFrame to a specified column.
    If the GeoDataFrame is empty, it safely returns an empty GeoDataFrame with an
    empty index. Otherwise, it sets the specified column as the new index, dropping
    the column from the DataFrame's columns.

    Parameters
    ----------
    gdf : geopandas.GeoDataFrame
        Input GeoDataFrame.
    col : str
        Column name to use as index.

    Returns
    -------
    geopandas.GeoDataFrame
        GeoDataFrame with index set if column exists.

    See Also
    --------
    _set_edge_index : Set multi-index for edge GeoDataFrames.

    Examples
    --------
    >>> indexed_gdf = _set_node_index(gdf, 'node_id')
    """
    if gdf.empty:
        # For an empty GDF, set an empty index.
        # Attempting to set_index with a non-existent column `col` would error.
        # If `col` is the intended index name, it can be assigned after.
        return gdf.set_index(pd.Index([]))  # Safest for empty

    return gdf.set_index(col, drop=True)


def _set_edge_index(
    gdf: gpd.GeoDataFrame,
    from_col: str,
    to_col: str,
) -> gpd.GeoDataFrame:
    """
    Set multi-index for edge GeoDataFrame.

    This function sets a MultiIndex on an edge GeoDataFrame using specified
    'from' and 'to' column names. This is crucial for representing graph edges
    where each edge is uniquely identified by its source and target nodes.

    Parameters
    ----------
    gdf : geopandas.GeoDataFrame
        The edge GeoDataFrame to modify.
    from_col : str
        The name of the column to be used as the first level of the MultiIndex
        (representing the source node ID).
    to_col : str
        The name of the column to be used as the second level of the MultiIndex
        (representing the target node ID).

    Returns
    -------
    geopandas.GeoDataFrame
        The GeoDataFrame with the new MultiIndex applied.
    """
    return gdf.set_index([from_col, to_col])
