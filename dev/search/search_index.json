{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"City2Graph","text":"<p>City2Graph is a Python library for converting geospatial datasets into graphs for GNN with integrated interface of GeoPandas, NetworkX, and Pytorch Geometric across multiple domains (e.g. streets, transportations, OD matrices, POI proximities, etc.). It enables researchers and practitioners to seamlessly develop advanced GeoAI and geographic data science applications.</p> <p> </p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Construct graphs from morphological datasets (e.g. buildings, streets, and land use from OpenStreetMap (OSM), Overture Maps, and others)</li> <li>Construct graphs from transportation datasets (e.g. public transport of buses, trams, and trains from GTFS)</li> <li>Construct graphs from contiguity datasets (e.g. land use, land cover, and administrative boundaries)</li> <li>Construct graphs from mobility datasets (e.g. bike-sharing, migration, and pedestrian flows)</li> <li>Convert geospatial data (GeoPandas / NetworkX) into tensors (PyTorch Geometric's Data and HeteroData) for graph representation learning, such as Graph Neural Networks (GNNs)</li> </ul> <p>City2Graph empowers researchers and practitioners in GeoAI, Urban Analytics, and Spatial Data Science to build advanced applications. A key distinction of this library is its ability to model complex urban systems by handling multiple geospatial relations as heterogeneous graphs. It bridges the gap between traditional GIS and modern Graph Neural Networks (GNNs) for a variety of applications. By supporting standard libraries like PyTorch Geometric, it enables seamless integration into deep learning workflows for Graph Representation Learning. With its versatile graph construction interface, this library can also be used for network analysis of urban systems from multiple geospatial relations, such as multi-modal accessibility (e.g. isochrone with street networks + public transport networks).</p> <p> </p>"},{"location":"index.html#quickstart","title":"Quickstart","text":"<p>Install City2Graph using pip (recommended):</p> <pre><code>pip install city2graph\n</code></pre> <p>For graph neural network functionality (PyTorch, PyTorch Geometric):</p> <pre><code>pip install \"city2graph[cpu]\"  # CPU only\npip install \"city2graph[cu130]\"  # For CUDA 13.0 (GPU)\n</code></pre> <p>Supported CUDA options: cu118, cu124, cu126, cu128, cu130</p> <p>Or install with conda (core functionality only):</p> <pre><code>conda install -c conda-forge city2graph\n</code></pre> <p>To add PyTorch and PyTorch Geometric (conda):</p> <pre><code>conda install -c conda-forge pytorch pytorch_geometric\n</code></pre> <p>For CUDA-enabled PyTorch (conda):</p> <pre><code>conda install -c conda-forge pytorch=2.7.1=*cuda128*\nconda install -c conda-forge pytorch_geometric\n</code></pre> <p>Warning</p> <p>As conda is not officially supported by PyTorch and PyTorch Geometric anymore, pip is recommended for full PyTorch support. See Installation for details.</p>"},{"location":"index.html#examples","title":"Examples","text":"<pre><code>import city2graph as c2g\nimport geopandas as gpd\nimport pandas as pd\nfrom pathlib import Path\n</code></pre> <p>Graph</p> <pre><code># Define metapath: amenity -&gt; segment -&gt; segment -&gt; amenity (3-hop in this case)\nmetapaths = [[(\"amenity\", \"is_nearby\", \"segment\"),\n              (\"segment\", \"connects\", \"segment\"),\n              (\"segment\", \"connects\", \"segment\"),\n              (\"segment\", \"is_nearby\", \"amenity\")]]\n\n# Add metapath-derived edges to connect amenities through street networks\nnodes_with_metapaths, edges_with_metapaths = c2g.add_metapaths(\n    (combined_nodes, combined_edges),\n    metapaths,\n    edge_attr=\"distance_m\",\n    edge_attr_agg=\"sum\"\n)\n</code></pre> <p> </p> <p>For details, see Examples</p> <p>Morphology</p> <pre><code>morphological_nodes, morphological_edges = c2g.morphological_graph(\n   buildings_gdf,\n   segments_gdf,\n   center_point,\n   distance=500\n )\n</code></pre> <p> </p> <p>For details, see Examples</p> <p>Transportation</p> <pre><code>sample_gtfs_path = Path(\"./itm_london_gtfs.zip\")\ngtfs_data = c2g.load_gtfs(sample_gtfs_path)\n\ntravel_summary_nodes, travel_summary_edges = c2g.travel_summary_graph(\n   gtfs_data, calendar_start=\"20250601\", calendar_end=\"20250601\")\n</code></pre> <p> </p> <p>For details, see Examples</p> <p>Mobility</p> <pre><code># Load zones (e.g., MSOA boundaries) and OD matrix data\nod_data = pd.read_csv(\"od_matrix.csv\")\nzones_gdf = gpd.read_file(\"zones.gpkg\")\n\n# Convert OD matrix to graph\nod_nodes, od_edges = c2g.od_matrix_to_graph(\n    od_data,\n    zones_gdf,\n    source_col=\"origin\",\n    target_col=\"destination\",\n    weight_cols=[\"flow\"],\n    zone_id_col=\"zone_id\",\n    directed=False\n)\n</code></pre> <p> </p> <p>For details, see Examples</p> <p>Proximity</p> <pre><code>fixed_radius_graph = c2g.fixed_radius_graph(poi_gdf, radius=100)\n</code></pre> <p>      Your browser does not support the video tag.    </p> <pre><code>wax_l1_nodes, wax_l1_edges = c2g.waxman_graph(poi_gdf,\n                                 distance_metric=\"manhattan\",\n                                 r0=100,\n                                 beta=0.5)\n\nwax_l2_nodes, wax_l2_edges = c2g.waxman_graph(poi_gdf,\n                                 distance_metric=\"euclidean\",\n                                 r0=100,\n                                 beta=0.5)\n\nwax_net_nodes, wax_net_edges = c2g.waxman_graph(poi_gdf,\n                                 distance_metric=\"network\",\n                                 r0=100,\n                                 beta=0.5,\n                                 network_gdf=segments_gdf.to_crs(epsg=6677))\n</code></pre> <p> </p> <pre><code>nodes_dict = {\n   \"restaurants\": poi_gdf,\n   \"hospitals\": hospital_gdf,\n   \"commercial\": commercial_gdf\n}\n\n# Generate proximity edges between layers using KNN method\nproximity_nodes, proximity_edges = c2g.bridge_nodes(\n   nodes_dict,\n   proximity_method=\"knn\",\n   k=5,\n   distance_metric=\"euclidean\"\n)\n</code></pre> <p> </p> <pre><code># Build a contiguity graph (Queen or Rook) from polygonal zones\nwn_q_nodes, wn_q_edges = c2g.contiguity_graph(\n    wards_gdf,\n    contiguity=\"queen\",        # or \"rook\"\n    distance_metric=\"euclidean\" # or \"manhattan\", \"network\"\n)\n</code></pre> <pre><code># Link point features (e.g., POIs, stops) to containing polygons (e.g., wards)\nnodes_dict, edges_dict = c2g.group_nodes(\n    polygons_gdf=wards_gdf,\n    points_gdf=poi_gdf,\n    predicate=\"covered_by\"      # include boundary points; alternatives: \"within\", \"contains\"\n)\n</code></pre> <pre><code># Combine contiguity edges and grouped edges into a single heterogeneous graph\ncombined_nodes = {\n    \"wards\": wn_q_nodes,\n    \"poi\": nodes_dict[\"poi\"]\n}\n\ncombined_edges = {\n    (\"wards\", \"is_contiguous_with\", \"wards\"): wn_q_edges[(\"wards\", \"is_contiguous_with\", \"wards\")],\n    (\"wards\", \"covers\", \"poi\"): edges_dict[(\"wards\", \"covers\", \"poi\")]\n}\n\n# Convert to PyG HeteroData\nhetero_graph = c2g.gdf_to_pyg(combined_nodes, combined_edges)\n</code></pre> <p> </p> <p>For details, see Examples</p>"},{"location":"index.html#citation","title":"Citation","text":"<p>If you use City2Graph in your research, please cite it as follows:</p> <pre><code>@software{sato2025city2graph,\n  title = {City2Graph: Transform geospatial relations into graphs for spatial network analysis and Graph Neural Networks},\n  author = {Sato, Yuta},\n  year = {2025},\n  url = {https://github.com/c2g-dev/city2graph},\n  doi = {10.5281/zenodo.15858845},\n}\n</code></pre> <p>You can also find the citation information in the CITATION.cff file in the repository, which follows the Citation File Format standard.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<ul> <li>Installation</li> <li>Examples</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"contributing.html","title":"Contributing","text":"<p>We welcome contributions to the City2Graph project! This document provides guidelines for contributing to the project.</p>"},{"location":"contributing.html#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone https://github.com/&lt;your-name&gt;/city2graph.git\ncd city2graph\ngit remote add upstream https://github.com/c2g-dev/city2graph.git\n</code></pre> <ol> <li>Set up the development environment:</li> </ol> <pre><code>uv sync --group dev --extra cpu\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"contributing.html#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li> <p>Make your changes to the codebase.</p> </li> <li> <p>Run pre-commit checks before committing:</p> </li> </ol> <pre><code>uv run pre-commit run --all-files\n</code></pre> <ol> <li>Run the tests to ensure your changes don't break existing functionality:</li> </ol> <pre><code>uv run pytest --cov=city2graph --cov-report=html --cov-report=term\n</code></pre> <ol> <li>Update or add documentation as needed.</li> <li>Commit your changes with a descriptive commit message.</li> </ol>"},{"location":"contributing.html#code-style","title":"Code Style","text":"<p>We follow strict code quality standards using the following tools:</p> <ul> <li>Ruff: For linting and formatting Python code</li> <li>mypy: For static type checking</li> <li>numpydoc: For docstring style validation</li> </ul> <p>Key style guidelines:</p> <ul> <li>Use 4 spaces for indentation.</li> <li>Maximum line length of 88 characters.</li> <li>Use docstrings following numpydoc conventions for all public modules, functions, classes, and methods.</li> <li>Use type hints where appropriate.</li> </ul> <p>Pre-commit hooks will automatically run these checks when you commit changes.</p>"},{"location":"contributing.html#documentation","title":"Documentation","text":"<p>When contributing new features or making significant changes, please update the documentation:</p> <ol> <li>Add docstrings to all public functions, classes, and methods.</li> <li>Update the relevant documentation files in the <code>docs</code> directory.</li> <li>If adding a new feature, consider adding an example to <code>docs/examples/index.md</code>.</li> </ol>"},{"location":"contributing.html#pull-requests","title":"Pull Requests","text":"<ol> <li>Push your changes to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Open a pull request on GitHub.</li> <li>Describe your changes in the pull request description.</li> <li>Reference any related issues that your pull request addresses.</li> </ol> <p>Your pull request will be reviewed, and you may be asked to make changes before it's merged.</p>"},{"location":"contributing.html#building-documentation","title":"Building Documentation","text":"<p>To build and preview the documentation locally:</p> <ol> <li>Create and activate a virtual environment with uv:</li> </ol> <pre><code>uv venv docs-env\nsource docs-env/bin/activate  # On Windows: docs-env\\Scripts\\activate\n</code></pre> <ol> <li>Install documentation dependencies:</li> </ol> <pre><code>uv pip install -e \".[docs]\"\n</code></pre> <ol> <li>Build the documentation:</li> </ol> <pre><code>uv run mkdocs serve\n</code></pre> <ol> <li>Open <code>http://127.0.0.1:8000/</code> in your browser to view the documentation.</li> </ol>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#using-pip","title":"Using pip","text":""},{"location":"installation.html#standard-installation","title":"Standard Installation","text":"<p>The simplest way to install City2Graph is via pip:</p> <pre><code>pip install city2graph\n</code></pre> <p>This installs the core functionality without PyTorch and PyTorch Geometric.</p>"},{"location":"installation.html#with-pytorch-cpu","title":"With PyTorch (CPU)","text":"<p>If you need the graph neural network functionality, install with the <code>cpu</code> option:</p> <pre><code>pip install \"city2graph[cpu]\"\n</code></pre> <p>This will install PyTorch and PyTorch Geometric with CPU support.</p>"},{"location":"installation.html#with-pytorch-cuda-gpu","title":"With PyTorch + CUDA (GPU)","text":"<p>For GPU acceleration, you can install City2Graph with a specific CUDA version extra. For example, to install for CUDA 13.0:</p> <pre><code>pip install \"city2graph[cu130]\"\n</code></pre> <p>Supported CUDA versions are <code>cu118</code>, <code>cu124</code>, <code>cu126</code>, <code>cu128</code>, and <code>cu130</code>.</p>"},{"location":"installation.html#using-conda-forge","title":"Using conda-forge","text":""},{"location":"installation.html#basic-installation","title":"Basic Installation","text":"<p>You can also install City2Graph using conda from conda-forge:</p> <pre><code>conda install -c conda-forge city2graph\n</code></pre> <p>This installs the core functionality without PyTorch and PyTorch Geometric.</p>"},{"location":"installation.html#with-pytorch-cpu_1","title":"With PyTorch (CPU)","text":"<p>To use PyTorch and PyTorch Geometric with City2Graph installed from conda-forge, you need to manually add these libraries to your environment:</p> <pre><code># Install city2graph\nconda install -c conda-forge city2graph\n\n# Then install PyTorch and PyTorch Geometric\nconda install -c conda-forge pytorch pytorch_geometric\n</code></pre>"},{"location":"installation.html#with-pytorch-cuda-gpu_1","title":"With PyTorch + CUDA (GPU)","text":"<p>For GPU support, you should select the appropriate PyTorch variant by specifying the version and CUDA build string. For example, to install PyTorch 2.7.1 with CUDA 12.8 support:</p> <pre><code># Install city2graph\nconda install -c conda-forge city2graph\n\n# Then install PyTorch with CUDA support\nconda install -c conda-forge pytorch=2.7.1=*cuda128*\nconda install -c conda-forge pytorch_geometric\n</code></pre> <p>You can browse available CUDA-enabled builds on the conda-forge PyTorch files page and substitute the desired version and CUDA variant in your install command. Make sure that the versions of PyTorch and PyTorch Geometric you install are compatible with each other and with your system.</p> <p>Warning</p> <p>conda is not officially supported by PyTorch and PyTorch Geometric anymore, and only conda-forge distributions are available for them. We recommend using pip or uv for the most streamlined installation experience if you need PyTorch functionality.</p>"},{"location":"installation.html#requirements","title":"Requirements","text":"<p>City2Graph requires the following packages:</p> <ul> <li>networkx</li> <li>shapely</li> <li>geopandas</li> <li>libpysal</li> <li>momepy</li> <li>overturemaps</li> <li>rustworkx</li> </ul> <p>For graph neural network functionality, you'll also need:</p> <ul> <li>torch</li> <li>torch_geometric</li> </ul>"},{"location":"api/index.html","title":"API Reference","text":"<p>This section contains the complete API reference for the <code>city2graph</code> package.</p> <p>City2Graph provides a comprehensive toolkit for constructing graphs from geospatial datasets, enabling network analysis and graph neural network applications on urban data.</p>"},{"location":"api/index.html#modules","title":"Modules","text":"Module Description Data Loading and processing geospatial data from sources like Overture Maps Graph Converting between GeoDataFrames, NetworkX, and PyTorch Geometric Mobility Processing OD matrices and mobility networks Morphology Creating morphological graphs from urban fabric data Proximity Generating proximity-based graph networks Transportation Processing GTFS data and transportation networks Utils Core utilities for graph conversion and validation"},{"location":"api/data.html","title":"Data Module","text":"<p>The data module provides functions for loading and processing geospatial data from various sources, with a focus on Overture Maps data.</p>"},{"location":"api/data.html#functions","title":"Functions","text":"<p>Data Loading and Processing Module.</p> <p>This module provides comprehensive functionality for loading and processing geospatial data from various sources, with specialized support for Overture Maps data. It handles data validation, coordinate reference system management, and geometric processing operations commonly needed for urban network analysis.</p> <p>Functions:</p> Name Description <code>load_overture_data</code> <p>Load data from Overture Maps using the CLI tool and optionally save to GeoJSON files.</p> <code>process_overture_segments</code> <p>Process segments from Overture Maps to be split by connectors and extract barriers.</p>"},{"location":"api/data.html#city2graph.data.load_overture_data","title":"load_overture_data","text":"<pre><code>load_overture_data(\n    area,\n    types=None,\n    output_dir=\".\",\n    prefix=\"\",\n    save_to_file=True,\n    return_data=True,\n    release=None,\n    connect_timeout=None,\n    request_timeout=None,\n    use_stac=True,\n)\n</code></pre> <p>Load data from Overture Maps using the CLI tool and optionally save to GeoJSON files.</p> <p>This function downloads geospatial data from Overture Maps for a specified area and data types. It can save the data to GeoJSON files and/or return it as GeoDataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>list[float] or Polygon</code> <p>The area of interest. Can be either a bounding box as [min_lon, min_lat, max_lon, max_lat] or a Polygon geometry.</p> required <code>types</code> <code>list[str]</code> <p>List of Overture data types to download. If None, downloads all available types.</p> <p>Available types:</p> Type Description <code>address</code> Represents a physical place through a series of attributes (street number, etc). <code>bathymetry</code> Derived vectorized bathymetric data products from ETOPO1 and GLOBathy. <code>building</code> The most basic form of a building feature; geometry is the outer footprint. <code>building_part</code> A single part of a building (e.g. 3D part); associated with a parent building. <code>connector</code> Point feature connecting segments in the transportation network. <code>division</code> Represents an official/non-official organization of people (country, city, etc). <code>division_area</code> Captures the shape of the land/maritime area belonging to a division. <code>division_boundary</code> Represents a shared border between two division features. <code>infrastructure</code> Features such as communication towers, lines, piers, and bridges. <code>land</code> Physical representations of land surfaces derived from OSM Coastlines. <code>land_cover</code> Derived from ESA WorldCover high-resolution optical Earth observation data. <code>land_use</code> Classifications of the human use of a section of land (from OSM landuse). <code>place</code> Points of interest: schools, businesses, hospitals, landmarks, etc. <code>segment</code> LineString feature representing paths for travel (road, rail, water). <code>water</code> Physical representations of inland and ocean marine surfaces. <p>For more information, see the Overture Maps documentation.</p> <code>None</code> <code>output_dir</code> <code>str</code> <p>Directory where GeoJSON files will be saved.</p> <code>\".\"</code> <code>prefix</code> <code>str</code> <p>Prefix to add to output filenames.</p> <code>\"\"</code> <code>save_to_file</code> <code>bool</code> <p>Whether to save downloaded data to GeoJSON files.</p> <code>True</code> <code>return_data</code> <code>bool</code> <p>Whether to return the data as GeoDataFrames.</p> <code>True</code> <code>release</code> <code>str</code> <p>Overture Maps release version to use (e.g., '2024-11-13.0'). If None, uses the default release from the CLI tool. Must be a valid release from the overturemaps library's ALL_RELEASES list.</p> <code>None</code> <code>connect_timeout</code> <code>float</code> <p>Socket connection timeout in seconds. If None, uses the AWS SDK default value (typically 1 second).</p> <code>None</code> <code>request_timeout</code> <code>float</code> <p>Socket read timeout in seconds (Windows and macOS only). If None, uses the AWS SDK default value (typically 3 seconds). This option is ignored on non-Windows, non-macOS systems.</p> <code>None</code> <code>use_stac</code> <code>bool</code> <p>Whether to use Overture's STAC-geoparquet catalog to speed up queries. If False, data will be read normally without the STAC optimization.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, GeoDataFrame]</code> <p>Dictionary mapping data type names to their corresponding GeoDataFrames.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid data types are specified or if an invalid release version is provided.</p> <code>CalledProcessError</code> <p>If the Overture Maps CLI command fails.</p> See Also <p>process_overture_segments : Process segments from Overture Maps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Download building and segment data for a bounding box\n&gt;&gt;&gt; bbox = [-74.01, 40.70, -73.99, 40.72]  # Manhattan area\n&gt;&gt;&gt; data = load_overture_data(bbox, types=['building', 'segment'])\n&gt;&gt;&gt; buildings = data['building']\n&gt;&gt;&gt; segments = data['segment']\n</code></pre> <pre><code>&gt;&gt;&gt; # Download with a specific release version\n&gt;&gt;&gt; data = load_overture_data(bbox, types=['building'], release='2024-11-13.0')\n</code></pre> <pre><code>&gt;&gt;&gt; # Download with custom timeout settings\n&gt;&gt;&gt; data = load_overture_data(\n...     bbox,\n...     types=['building'],\n...     connect_timeout=5.0,\n...     request_timeout=10.0\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Download without STAC optimization\n&gt;&gt;&gt; data = load_overture_data(bbox, types=['building'], use_stac=False)\n</code></pre>"},{"location":"api/data.html#city2graph.data.process_overture_segments","title":"process_overture_segments","text":"<pre><code>process_overture_segments(\n    segments_gdf, get_barriers=True, connectors_gdf=None, threshold=1.0\n)\n</code></pre> <p>Process segments from Overture Maps to be split by connectors and extract barriers.</p> <p>This function processes road segments by splitting them at connector points and optionally generates barrier geometries based on level rules. It also performs endpoint clustering to snap nearby endpoints together.</p> <p>Parameters:</p> Name Type Description Default <code>segments_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing road segments with LineString geometries. Expected to have 'connectors' and 'level_rules' columns.</p> required <code>get_barriers</code> <code>bool</code> <p>Whether to generate barrier geometries from level rules.</p> <code>True</code> <code>connectors_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing connector information. If provided, segments will be split at connector positions.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Distance threshold for endpoint clustering in the same units as the CRS.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>Processed segments with additional columns: - 'split_from', 'split_to': Split positions if segments were split - 'length': Length of each segment - 'barrier_geometry': Passable geometry if get_barriers=True</p> See Also <p>load_overture_data : Load data from Overture Maps.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Process segments with connector splitting\n&gt;&gt;&gt; processed = process_overture_segments(\n...     segments_gdf,\n...     connectors_gdf=connectors_gdf,\n...     threshold=1.0\n... )\n&gt;&gt;&gt; # Access barrier geometries for routing\n&gt;&gt;&gt; barriers = processed['barrier_geometry']\n</code></pre>"},{"location":"api/graph.html","title":"Graph Module","text":"<p>The graph module provides functions for converting between different graph representations, including GeoDataFrames, NetworkX graphs, and PyTorch Geometric data objects.</p>"},{"location":"api/graph.html#conversion-functions","title":"Conversion Functions","text":"<p>Module for creating heterogeneous graph representations of urban environments.</p> <p>This module provides comprehensive functionality for converting spatial data (GeoDataFrames and NetworkX objects) into PyTorch Geometric Data and HeteroData objects, supporting both homogeneous and heterogeneous graphs. It handles the complex mapping between geographical coordinates, node/edge features, and the tensor representations required by graph neural networks.</p> <p>The module serves as a bridge between geospatial data analysis tools and deep learning frameworks, enabling seamless integration of spatial urban data with Graph Neural Networks (GNNs) for tasks of GeoAI such as urban modeling, traffic prediction, and spatial analysis.</p> <p>Functions:</p> Name Description <code>gdf_to_pyg</code> <p>Convert GeoDataFrames (nodes/edges) to a PyTorch Geometric object.</p> <code>nx_to_pyg</code> <p>Convert NetworkX graph to PyTorch Geometric Data object.</p> <code>pyg_to_gdf</code> <p>Convert PyTorch Geometric data to GeoDataFrames.</p> <code>pyg_to_nx</code> <p>Convert a PyTorch Geometric object to a NetworkX graph.</p>"},{"location":"api/graph.html#city2graph.graph.gdf_to_pyg","title":"gdf_to_pyg","text":"<pre><code>gdf_to_pyg(\n    nodes,\n    edges=None,\n    node_feature_cols=None,\n    node_label_cols=None,\n    edge_feature_cols=None,\n    device=None,\n    dtype=None,\n    keep_geom=True,\n)\n</code></pre> <p>Convert GeoDataFrames (nodes/edges) to a PyTorch Geometric object.</p> <p>This function serves as the main entry point for converting spatial data into PyTorch Geometric graph objects. It automatically detects whether to create homogeneous or heterogeneous graphs based on input structure. Node identifiers are taken from the GeoDataFrame index. Edge relationships are defined by a MultiIndex on the edge GeoDataFrame (source ID, target ID).</p> <p>The operation multiplies typed adjacency tables to connect terminal node pairs and can aggregate additional numeric edge attributes along the way.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>dict[str, GeoDataFrame] or GeoDataFrame</code> <p>Node data. For homogeneous graphs, provide a single GeoDataFrame. For heterogeneous graphs, provide a dictionary mapping node type names to their respective GeoDataFrames. The index of these GeoDataFrames will be used as node identifiers.</p> required <code>edges</code> <code>dict[tuple[str, str, str], GeoDataFrame] or GeoDataFrame</code> <p>Edge data. For homogeneous graphs, provide a single GeoDataFrame. For heterogeneous graphs, provide a dictionary mapping edge type tuples (source_type, relation_type, target_type) to their GeoDataFrames. The GeoDataFrame must have a MultiIndex where the first level represents source node IDs and the second level represents target node IDs.</p> <code>None</code> <code>node_feature_cols</code> <code>dict[str, list[str]] or list[str]</code> <p>Column names to use as node features. For heterogeneous graphs, provide a dictionary mapping node types to their feature columns.</p> <code>None</code> <code>node_label_cols</code> <code>dict[str, list[str]] or list[str]</code> <p>Column names to use as node labels for supervised learning tasks. For heterogeneous graphs, provide a dictionary mapping node types to their label columns.</p> <code>None</code> <code>edge_feature_cols</code> <code>dict[str, list[str]] or list[str]</code> <p>Column names to use as edge features. For heterogeneous graphs, provide a dictionary mapping relation types to their feature columns.</p> <code>None</code> <code>device</code> <code>str or device</code> <p>Target device for tensor placement ('cpu', 'cuda', or torch.device). If None, automatically selects CUDA if available, otherwise CPU.</p> <code>None</code> <code>dtype</code> <code>dtype</code> <p>Data type for float tensors (e.g., torch.float32, torch.float16). If None, uses torch.float32 (default PyTorch float type).</p> <code>None</code> <code>keep_geom</code> <code>bool</code> <p>Whether to preserve geometry information during conversion. If True, original geometries are serialized and stored in metadata for exact reconstruction. If False, geometries are reconstructed from node positions during conversion back to GeoDataFrames (creating straight-line edges between nodes).</p> <code>True</code> <p>Returns:</p> Type Description <code>Data or HeteroData</code> <p>PyTorch Geometric Data object for homogeneous graphs or HeteroData object for heterogeneous graphs. The returned object contains:</p> <ul> <li>Node features (x), positions (pos), and labels (y) if available</li> <li>Edge connectivity (edge_index) and features (edge_attr) if available</li> <li>Metadata for reconstruction including ID mappings and column names</li> </ul> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyTorch Geometric is not installed.</p> <code>ValueError</code> <p>If input GeoDataFrames are invalid or incompatible.</p> See Also <p>pyg_to_gdf : Convert PyTorch Geometric data back to GeoDataFrames. nx_to_pyg : Convert NetworkX graph to PyTorch Geometric object. city2graph.utils.validate_gdf : Validate GeoDataFrame structure.</p> Notes <p>This function automatically detects the graph type based on input structure. For heterogeneous graphs, provide dictionaries mapping types to GeoDataFrames. Node positions are automatically extracted from geometry centroids when available. - Preserves original coordinate reference systems (CRS) - Maintains index structure for bidirectional conversion - Handles both Point and non-Point geometries (using centroids) - Creates empty tensors for missing features/edges - For heterogeneous graphs, ensures consistent node/edge type mapping</p> <p>Examples:</p> <p>Create a homogeneous graph from single GeoDataFrames:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from city2graph.graph import gdf_to_pyg\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load and prepare node data\n&gt;&gt;&gt; nodes_gdf = gpd.read_file(\"nodes.geojson\").set_index(\"node_id\")\n&gt;&gt;&gt; edges_gdf = gpd.read_file(\"edges.geojson\").set_index([\"source_id\", \"target_id\"])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to PyTorch Geometric\n&gt;&gt;&gt; data = gdf_to_pyg(nodes_gdf, edges_gdf,\n...                   node_feature_cols=['population', 'area'])\n</code></pre> <p>Create a heterogeneous graph from dictionaries:</p> <pre><code>&gt;&gt;&gt; # Prepare heterogeneous data\n&gt;&gt;&gt; buildings_gdf = buildings_gdf.set_index(\"building_id\")\n&gt;&gt;&gt; roads_gdf = roads_gdf.set_index(\"road_id\")\n&gt;&gt;&gt; connections_gdf = connections_gdf.set_index([\"building_id\", \"road_id\"])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Define node and edge types\n&gt;&gt;&gt; nodes_dict = {'building': buildings_gdf, 'road': roads_gdf}\n&gt;&gt;&gt; edges_dict = {('building', 'connects', 'road'): connections_gdf}\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to heterogeneous graph with labels\n&gt;&gt;&gt; data = gdf_to_pyg(nodes_dict, edges_dict,\n...                   node_label_cols={'building': ['type'], 'road': ['category']})\n</code></pre>"},{"location":"api/graph.html#city2graph.graph.nx_to_pyg","title":"nx_to_pyg","text":"<pre><code>nx_to_pyg(\n    graph,\n    node_feature_cols=None,\n    node_label_cols=None,\n    edge_feature_cols=None,\n    device=None,\n    dtype=None,\n    keep_geom=True,\n)\n</code></pre> <p>Convert NetworkX graph to PyTorch Geometric Data object.</p> <p>Converts a NetworkX Graph to a PyTorch Geometric Data object by first converting to GeoDataFrames then using the main conversion pipeline. This provides a bridge between NetworkX's rich graph analysis tools and PyTorch Geometric's deep learning capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph</code> <p>NetworkX graph to convert.</p> required <code>node_feature_cols</code> <code>list[str]</code> <p>List of node attribute names to use as features.</p> <code>None</code> <code>node_label_cols</code> <code>list[str]</code> <p>List of node attribute names to use as labels.</p> <code>None</code> <code>edge_feature_cols</code> <code>list[str]</code> <p>List of edge attribute names to use as features.</p> <code>None</code> <code>device</code> <code>device or str</code> <p>Target device for tensor placement ('cpu', 'cuda', or torch.device). If None, automatically selects CUDA if available, otherwise CPU.</p> <code>None</code> <code>dtype</code> <code>dtype</code> <p>Data type for float tensors (e.g., torch.float32, torch.float16). If None, uses torch.float32 (default PyTorch float type).</p> <code>None</code> <code>keep_geom</code> <code>bool</code> <p>Whether to preserve geometry information during conversion. If True, original geometries are serialized and stored in metadata for exact reconstruction. If False, geometries are reconstructed from node positions during conversion back to GeoDataFrames.</p> <code>True</code> <p>Returns:</p> Type Description <code>Data or HeteroData</code> <p>PyTorch Geometric Data object for homogeneous graphs or HeteroData object for heterogeneous graphs. The returned object contains:</p> <ul> <li>Node features (x), positions (pos), and labels (y) if available</li> <li>Edge connectivity (edge_index) and features (edge_attr) if available</li> <li>Metadata for reconstruction including ID mappings and column names</li> </ul> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyTorch Geometric is not installed.</p> <code>ValueError</code> <p>If the NetworkX graph is invalid or empty.</p> See Also <p>pyg_to_nx : Convert PyTorch Geometric data to NetworkX graph. gdf_to_pyg : Convert GeoDataFrames to PyTorch Geometric object. city2graph.utils.nx_to_gdf : Convert NetworkX graph to GeoDataFrames.</p> Notes <ul> <li>Uses intermediate GeoDataFrame conversion for consistency</li> <li>Preserves all graph attributes and metadata</li> <li>Handles spatial coordinates if present in node attributes</li> <li>Maintains compatibility with existing city2graph workflows</li> <li>Automatically creates geometry from 'x', 'y' coordinates if available</li> </ul> <p>Examples:</p> <p>Convert a NetworkX graph with spatial data:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; from city2graph.graph import nx_to_pyg\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create NetworkX graph with spatial attributes\n&gt;&gt;&gt; G = nx.Graph()\n&gt;&gt;&gt; G.add_node(0, x=0.0, y=0.0, population=1000)\n&gt;&gt;&gt; G.add_node(1, x=1.0, y=1.0, population=1500)\n&gt;&gt;&gt; G.add_edge(0, 1, weight=0.5, road_type='primary')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to PyTorch Geometric\n&gt;&gt;&gt; data = nx_to_pyg(G,\n...                  node_feature_cols=['population'],\n...                  edge_feature_cols=['weight'])\n</code></pre> <p>Convert from graph analysis results:</p> <pre><code>&gt;&gt;&gt; # Use NetworkX for analysis, then convert for ML\n&gt;&gt;&gt; communities = nx.community.greedy_modularity_communities(G)\n&gt;&gt;&gt; # Add community labels to nodes\n&gt;&gt;&gt; for i, community in enumerate(communities):\n...     for node in community:\n...         G.nodes[node]['community'] = i\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert with community labels\n&gt;&gt;&gt; data = nx_to_pyg(G, node_label_cols=['community'])\n</code></pre>"},{"location":"api/graph.html#city2graph.graph.pyg_to_gdf","title":"pyg_to_gdf","text":"<pre><code>pyg_to_gdf(data, node_types=None, edge_types=None, keep_geom=True)\n</code></pre> <p>Convert PyTorch Geometric data to GeoDataFrames.</p> <p>Reconstructs the original GeoDataFrame structure from PyTorch Geometric Data or HeteroData objects. This function provides bidirectional conversion capability, preserving spatial information, feature data, and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Data or HeteroData</code> <p>PyTorch Geometric data object to convert back to GeoDataFrames.</p> required <code>node_types</code> <code>str or list[str]</code> <p>For heterogeneous graphs, specify which node types to reconstruct. If None, reconstructs all available node types.</p> <code>None</code> <code>edge_types</code> <code>str or list[tuple[str, str, str]]</code> <p>For heterogeneous graphs, specify which edge types to reconstruct. Edge types are specified as (source_type, relation_type, target_type) tuples. If None, reconstructs all available edge types.</p> <code>None</code> <code>keep_geom</code> <code>bool</code> <p>Whether to use stored geometries for reconstruction. If True and geometries are stored in metadata, uses the original geometries. If False or no stored geometries exist, reconstructs geometries from node positions (creating straight-line edges between nodes).</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] | tuple[dict[str, GeoDataFrame], dict[tuple[str, str, str], GeoDataFrame]]</code> <p>For Data input: Returns a tuple containing:     - First element: GeoDataFrame containing nodes     - Second element: GeoDataFrame containing edges (or None if no edges) For HeteroData input: Returns a tuple containing:     - First element: dict mapping node type names to GeoDataFrames     - Second element: dict mapping edge types to GeoDataFrames</p> See Also <p>gdf_to_pyg : Convert GeoDataFrames to PyTorch Geometric object. pyg_to_nx : Convert PyTorch Geometric data to NetworkX graph.</p> Notes <ul> <li>Preserves original index structure and names when available</li> <li>Reconstructs geometry from stored position tensors</li> <li>Maintains coordinate reference system (CRS) information</li> <li>Converts feature tensors back to named DataFrame columns</li> <li>Handles both homogeneous and heterogeneous graph structures</li> </ul> <p>Examples:</p> <p>Convert homogeneous PyTorch Geometric data back to GeoDataFrames:</p> <pre><code>&gt;&gt;&gt; from city2graph.graph import pyg_to_gdf\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert back to GeoDataFrames\n&gt;&gt;&gt; nodes_gdf, edges_gdf = pyg_to_gdf(data)\n</code></pre> <p>Convert heterogeneous data with specific node types:</p> <pre><code>&gt;&gt;&gt; # Convert only specific node types\n&gt;&gt;&gt; node_gdfs, edge_gdfs = pyg_to_gdf(hetero_data,\n...                                   node_types=['building', 'road'])\n</code></pre>"},{"location":"api/graph.html#city2graph.graph.pyg_to_nx","title":"pyg_to_nx","text":"<pre><code>pyg_to_nx(data, keep_geom=True)\n</code></pre> <p>Convert a PyTorch Geometric object to a NetworkX graph.</p> <p>Converts PyTorch Geometric Data or HeteroData objects to NetworkX graphs, preserving node and edge features as graph attributes. This enables compatibility with the extensive NetworkX ecosystem for graph analysis.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Data or HeteroData</code> <p>PyTorch Geometric data object to convert.</p> required <code>keep_geom</code> <code>bool</code> <p>Whether to use stored geometries for reconstruction. If True and geometries are stored in metadata, uses the original geometries. If False or no stored geometries exist, reconstructs geometries from node positions.</p> <code>True</code> <p>Returns:</p> Type Description <code>Graph</code> <p>The converted NetworkX graph with node and edge attributes. For heterogeneous graphs, node and edge types are stored as attributes.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyTorch Geometric is not installed.</p> See Also <p>nx_to_pyg : Convert NetworkX graph to PyTorch Geometric object. pyg_to_gdf : Convert PyTorch Geometric data to GeoDataFrames.</p> Notes <ul> <li>Node features, positions, and labels are stored as node attributes</li> <li>Edge features are stored as edge attributes</li> <li>For heterogeneous graphs, type information is preserved</li> <li>Geometry information is converted from tensor positions</li> <li>Maintains compatibility with NetworkX analysis algorithms</li> </ul> <p>Examples:</p> <p>Convert PyTorch Geometric data to NetworkX:</p> <pre><code>&gt;&gt;&gt; from city2graph.graph import pyg_to_nx\n&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Convert to NetworkX graph\n&gt;&gt;&gt; nx_graph = pyg_to_nx(data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use NetworkX algorithms\n&gt;&gt;&gt; centrality = nx.betweenness_centrality(nx_graph)\n&gt;&gt;&gt; communities = nx.community.greedy_modularity_communities(nx_graph)\n</code></pre>"},{"location":"api/graph.html#validation-functions","title":"Validation Functions","text":"<p>Module for creating heterogeneous graph representations of urban environments.</p> <p>This module provides comprehensive functionality for converting spatial data (GeoDataFrames and NetworkX objects) into PyTorch Geometric Data and HeteroData objects, supporting both homogeneous and heterogeneous graphs. It handles the complex mapping between geographical coordinates, node/edge features, and the tensor representations required by graph neural networks.</p> <p>The module serves as a bridge between geospatial data analysis tools and deep learning frameworks, enabling seamless integration of spatial urban data with Graph Neural Networks (GNNs) for tasks of GeoAI such as urban modeling, traffic prediction, and spatial analysis.</p> <p>Functions:</p> Name Description <code>is_torch_available</code> <p>Check if PyTorch Geometric is available.</p> <code>validate_pyg</code> <p>Validate PyTorch Geometric Data or HeteroData objects and return metadata.</p>"},{"location":"api/graph.html#city2graph.graph.is_torch_available","title":"is_torch_available","text":"<pre><code>is_torch_available()\n</code></pre> <p>Check if PyTorch Geometric is available.</p> <p>This utility function checks whether the required PyTorch and PyTorch Geometric packages are installed and can be imported. It's useful for conditional functionality and providing helpful error messages.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if PyTorch Geometric can be imported, False otherwise.</p> See Also <p>gdf_to_pyg : Convert GeoDataFrames to PyTorch Geometric (requires torch). pyg_to_gdf : Convert PyTorch Geometric to GeoDataFrames (requires torch).</p> Notes <ul> <li>Returns False if either PyTorch or PyTorch Geometric is missing</li> <li>Used internally by torch-dependent functions to provide helpful error messages</li> </ul> <p>Examples:</p> <p>Check availability before using torch-dependent functions:</p> <pre><code>&gt;&gt;&gt; from city2graph.graph import is_torch_available\n&gt;&gt;&gt;\n&gt;&gt;&gt; if is_torch_available():\n...     from city2graph.graph import gdf_to_pyg\n...     data = gdf_to_pyg(nodes_gdf, edges_gdf)\n... else:\n...     print(\"PyTorch Geometric not available.\")\n</code></pre>"},{"location":"api/graph.html#city2graph.graph.validate_pyg","title":"validate_pyg","text":"<pre><code>validate_pyg(data)\n</code></pre> <p>Validate PyTorch Geometric Data or HeteroData objects and return metadata.</p> <p>This centralized validation function performs comprehensive validation of PyG objects, including type checking, metadata validation, and structural consistency checks. It serves as the single point of validation for all PyG objects in city2graph.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Data or HeteroData</code> <p>PyTorch Geometric data object to validate.</p> required <p>Returns:</p> Type Description <code>GraphMetadata</code> <p>Metadata object containing graph information for reconstruction.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyTorch Geometric is not installed.</p> <code>TypeError</code> <p>If data is not a valid PyTorch Geometric object.</p> <code>ValueError</code> <p>If the data object is missing required metadata or is inconsistent.</p> See Also <p>pyg_to_gdf : Convert PyG objects to GeoDataFrames. pyg_to_nx : Convert PyG objects to NetworkX graphs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = gdf_to_pyg(nodes_gdf, edges_gdf)\n&gt;&gt;&gt; metadata = validate_pyg(data)\n</code></pre>"},{"location":"api/graph.html#metapath-functions","title":"Metapath Functions","text":"<p>Module for creating heterogeneous graph representations of urban environments.</p> <p>This module provides comprehensive functionality for converting spatial data (GeoDataFrames and NetworkX objects) into PyTorch Geometric Data and HeteroData objects, supporting both homogeneous and heterogeneous graphs. It handles the complex mapping between geographical coordinates, node/edge features, and the tensor representations required by graph neural networks.</p> <p>The module serves as a bridge between geospatial data analysis tools and deep learning frameworks, enabling seamless integration of spatial urban data with Graph Neural Networks (GNNs) for tasks of GeoAI such as urban modeling, traffic prediction, and spatial analysis.</p> <p>Functions:</p> Name Description <code>add_metapaths</code> <p>Add metapath-derived edges to a heterogeneous graph.</p> <code>add_metapaths_by_weight</code> <p>Connect nodes of a specific type if they are reachable within a cost threshold band.</p>"},{"location":"api/graph.html#city2graph.graph.add_metapaths","title":"add_metapaths","text":"<pre><code>add_metapaths(\n    graph=None,\n    nodes=None,\n    edges=None,\n    sequence=None,\n    new_relation_name=None,\n    edge_attr=None,\n    edge_attr_agg=\"sum\",\n    directed=False,\n    trace_path=False,\n    multigraph=False,\n    as_nx=False,\n    **_\n)\n</code></pre> <p>Add metapath-derived edges to a heterogeneous graph.</p> <p>The operation multiplies typed adjacency tables to connect terminal node pairs and can aggregate additional numeric edge attributes along the way.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>tuple or Graph or MultiGraph</code> <p>Heterogeneous graph input expressed as typed GeoDataFrame dictionaries or a city2graph-compatible NetworkX graph.</p> <code>None</code> <code>nodes</code> <code>dict[str, GeoDataFrame]</code> <p>Dictionary of node GeoDataFrames.</p> <code>None</code> <code>edges</code> <code>dict[tuple[str, str, str], GeoDataFrame]</code> <p>Dictionary of edge GeoDataFrames.</p> <code>None</code> <code>sequence</code> <code>list[tuple[str, str, str]]</code> <p>Sequence of metapath specifications; every edge type is a <code>(src_type, relation, dst_type)</code> tuple and the path must contain at least two steps.</p> <code>None</code> <code>new_relation_name</code> <code>str</code> <p>Target edge relation name for the new metapath edges. If None (default), edges are named <code>metapath_0</code>.</p> <code>None</code> <code>edge_attr</code> <code>str | list[str] | None</code> <p>Numeric edge attributes to aggregate along metapaths. When <code>None</code>, only path weights are produced.</p> <code>None</code> <code>edge_attr_agg</code> <code>str | object | None</code> <p>Aggregation strategy for <code>edge_attr</code> columns. Supported values are <code>\"sum\"</code> and <code>\"mean\"</code> (default <code>\"sum\"</code>).</p> <code>'sum'</code> <code>directed</code> <code>bool</code> <p>Treat metapaths as directed when <code>True</code>; otherwise both edge directions are accepted when available in the input graph.</p> <code>False</code> <code>trace_path</code> <code>bool</code> <p>When <code>True</code>, attempt to create traced geometries. Currently ignored but retained for API compatibility.</p> <code>False</code> <code>multigraph</code> <code>bool</code> <p>When returning NetworkX data, build a <code>networkx.MultiGraph</code> if <code>True</code>.</p> <code>False</code> <code>as_nx</code> <code>bool</code> <p>Return the result as a NetworkX graph when <code>True</code>.</p> <code>False</code> <code>**_</code> <code>object</code> <p>Ignored placeholder for future keyword extensions.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[dict[str, GeoDataFrame], dict[tuple[str, str, str], GeoDataFrame]] | Graph | MultiGraph</code> <p>The graph with metapath-derived edges. If as_nx is False (default), returns a tuple of node and edge GeoDataFrames. If as_nx is True, returns a NetworkX graph (Graph or MultiGraph).</p> Notes <p>Legacy scaffolding for path-tracing geometries has been removed because it was never executed. The trace_path argument is preserved for API compatibility but remains a no-op while straight-line geometries are generated for all metapath edges.</p>"},{"location":"api/graph.html#city2graph.graph.add_metapaths_by_weight","title":"add_metapaths_by_weight","text":"<pre><code>add_metapaths_by_weight(\n    graph=None,\n    nodes=None,\n    edges=None,\n    weight=None,\n    threshold=None,\n    new_relation_name=None,\n    min_threshold=0.0,\n    edge_types=None,\n    endpoint_type=None,\n    directed=False,\n    multigraph=False,\n    as_nx=False,\n)\n</code></pre> <p>Connect nodes of a specific type if they are reachable within a cost threshold band.</p> <p>This function dynamically adds metapaths (edges) between nodes of a specified <code>endpoint_type</code> if they are reachable within a given cost band [<code>min_threshold</code>, <code>threshold</code>] based on edge weights (e.g., travel time). It uses Dijkstra's algorithm for path finding via <code>scipy.sparse.csgraph</code> for efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>tuple or Graph or MultiGraph</code> <p>Input graph. Can be a tuple of (nodes_dict, edges_dict) or a NetworkX graph.</p> <code>None</code> <code>nodes</code> <code>dict[str, GeoDataFrame]</code> <p>Dictionary of node GeoDataFrames.</p> <code>None</code> <code>edges</code> <code>dict[tuple[str, str, str], GeoDataFrame]</code> <p>Dictionary of edge GeoDataFrames.</p> <code>None</code> <code>weight</code> <code>str</code> <p>The edge attribute to use as weight (e.g., 'travel_time').</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum cost threshold for connection.</p> <code>None</code> <code>new_relation_name</code> <code>str</code> <p>Name of the new edge relation.</p> <code>None</code> <code>min_threshold</code> <code>float</code> <p>The minimum cost threshold for connection.</p> <code>0.0</code> <code>edge_types</code> <code>list[tuple[str, str, str]]</code> <p>List of edge types to consider for traversal. If None, all edges are used.</p> <code>None</code> <code>endpoint_type</code> <code>str</code> <p>The node type to connect (e.g., 'building').</p> <code>None</code> <code>directed</code> <code>bool</code> <p>If True, creates a directed graph for traversal.</p> <code>False</code> <code>multigraph</code> <code>bool</code> <p>If True, returns a MultiGraph (only relevant if as_nx=True).</p> <code>False</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph or MultiGraph or tuple</code> <p>The graph with added metapaths. Format depends on <code>as_nx</code> parameter.</p>"},{"location":"api/mobility.html","title":"Mobility Module","text":"<p>The mobility module provides functions for processing Origin-Destination (OD) matrices and creating mobility networks for urban flow analysis.</p>"},{"location":"api/mobility.html#functions","title":"Functions","text":"<p>Mobility / OD matrix utilities.</p> <p>This module introduces the public function <code>od_matrix_to_graph</code> which converts Origin-Destination (OD) data (adjacency matrices or edge lists) into spatial graph representations used throughout the city2graph ecosystem.</p> Notes <p>This module includes a complete implementation of <code>od_matrix_to_graph</code>: input validation, zone alignment, conversion to a canonical edgelist, thresholding and self-loop handling, optional geometry creation, and an optional NetworkX export path.</p> <p>Examples:</p> <p>See the function docstring for usage examples with adjacency matrices, NumPy arrays and edge lists (single/multi weight columns).</p> <p>Functions:</p> Name Description <code>od_matrix_to_graph</code> <p>Convert OD data (edge list or adjacency matrix) into graph structures.</p>"},{"location":"api/mobility.html#city2graph.mobility.od_matrix_to_graph","title":"od_matrix_to_graph","text":"<pre><code>od_matrix_to_graph(\n    od_data,\n    zones_gdf,\n    zone_id_col=None,\n    *,\n    matrix_type=\"edgelist\",\n    source_col=\"source\",\n    target_col=\"target\",\n    weight_cols=None,\n    threshold=None,\n    threshold_col=None,\n    include_self_loops=False,\n    compute_edge_geometry=True,\n    directed=True,\n    as_nx=False\n)\n</code></pre> <p>Convert OD data (edge list or adjacency matrix) into graph structures.</p> <p>Creates spatially-aware graphs from OD data following city2graph's GeoDataFrame-first design. Supports adjacency matrices (DataFrame or ndarray) and edgelists with one or multiple numeric weight columns. By default, this function returns a pair of GeoDataFrames representing nodes and edges. When <code>directed=False</code>, the output is undirected: for each unordered pair {u, v}, the edge weight equals the sum of directed weights in both directions (u-&gt;v plus v-&gt;u). When a threshold is provided in undirected mode, it is applied after this summation. By default edges are directed and thresholded with the rule weight &gt;= threshold (or, when no threshold provided, strictly &gt; 0). Optionally, it can return a NetworkX graph when <code>as_nx=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>od_data</code> <code>DataFrame | ndarray</code> <ul> <li>When <code>matrix_type='adjacency'</code>: a square DataFrame whose   index &amp; columns are zone IDs, or a square ndarray whose ordering   matches <code>zones_gdf</code>.</li> <li>When <code>matrix_type='edgelist'</code>: a DataFrame containing origin,   destination and one or more numeric flow columns.</li> </ul> required <code>zones_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame of zones. Must contain unique identifiers in <code>zone_id_col</code>.</p> required <code>zone_id_col</code> <code>str</code> <p>Name of the zone ID column in <code>zones_gdf</code> (required in this initial skeleton; automatic inference may be added later).</p> <code>None</code> <code>matrix_type</code> <code>('edgelist', 'adjacency')</code> <p>Declares how to interpret <code>od_data</code>.</p> <code>'edgelist','adjacency'</code> <code>source_col</code> <code>str</code> <p>Column names for origins / destinations when using an edge list.</p> <code>'source','target'</code> <code>target_col</code> <code>str</code> <p>Column names for origins / destinations when using an edge list.</p> <code>'source','target'</code> <code>weight_cols</code> <code>Sequence[str] | None</code> <p>Edge list weight (flow) columns to preserve. A single column acts as the canonical weight. If multiple columns are provided a <code>threshold_col</code> must be designated in the full implementation.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>Minimum flow retained (&gt;=) applied to <code>threshold_col</code> (future logic).</p> <code>None</code> <code>threshold_col</code> <code>str</code> <p>Column among <code>weight_cols</code> used for thresholding &amp; canonical weight (required when <code>len(weight_cols) &gt; 1</code> in full implementation).</p> <code>None</code> <code>include_self_loops</code> <code>bool</code> <p>Keep flows where origin == destination (defaults drop when False).</p> <code>False</code> <code>compute_edge_geometry</code> <code>bool</code> <p>Whether to build LineString geometries from zone centroids.</p> <code>True</code> <code>directed</code> <code>bool</code> <p>Whether to build a directed graph. If False, reciprocal edges are merged by summing their weights (and all provided weight columns).</p> <code>True</code> <code>as_nx</code> <code>bool</code> <p>If True, final output will be an NetworkX graph (<code>nx.DiGraph</code> when <code>directed=True</code>; otherwise <code>nx.Graph</code>).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph or DiGraph</code> <p>The graph representation in the requested format:</p> <ul> <li>When <code>as_nx=False</code> (default): Returns a tuple <code>(nodes, edges)</code> of     GeoDataFrames. The nodes GeoDataFrame index is aligned with the zone     identifier. The edges GeoDataFrame uses a pandas MultiIndex on     (source_id, target_id).</li> <li>When <code>as_nx=True</code>: Returns a NetworkX graph. A <code>networkx.DiGraph</code>     is returned if <code>directed=True</code>, otherwise a <code>networkx.Graph</code>.</li> </ul>"},{"location":"api/morphology.html","title":"Morphology Module","text":"<p>The morphology module provides functions for creating morphological graphs from urban fabric data, capturing spatial relationships between buildings, streets, and public spaces.</p>"},{"location":"api/morphology.html#composite-graphs","title":"Composite Graphs","text":"<p>Module for creating morphological graphs from urban data.</p> <p>This module provides comprehensive functionality for analyzing urban morphology through graph representations, focusing on the relationships between private spaces (buildings and their tessellations) and public spaces (street segments). It creates heterogeneous graphs that capture the complex spatial relationships inherent in urban environments. Both GeoDataFrame and NetworkX objects can be converted to PyTorch Geometric Data or HeteroData by functions from graph.py.</p> <p>The module specializes in three types of spatial relationships: 1. Private-to-private: Adjacency relationships between building tessellations 2. Public-to-public: Topological connectivity between street segments 3. Private-to-public: Interface relationships between private and public spaces</p> <p>Functions:</p> Name Description <code>morphological_graph</code> <p>Create a morphological graph from buildings and street segments.</p>"},{"location":"api/morphology.html#city2graph.morphology.morphological_graph","title":"morphological_graph","text":"<pre><code>morphological_graph(\n    buildings_gdf,\n    segments_gdf,\n    center_point=None,\n    distance=None,\n    clipping_buffer=inf,\n    primary_barrier_col=\"barrier_geometry\",\n    contiguity=\"queen\",\n    keep_buildings=False,\n    keep_segments=True,\n    tolerance=1e-06,\n    as_nx=False,\n)\n</code></pre> <p>Create a morphological graph from buildings and street segments.</p> <p>This function creates a comprehensive morphological graph that captures relationships between private spaces (building tessellations) and public spaces (street segments). The graph includes three types of relationships: private-to-private adjacency, public-to-public connectivity, and private-to-public interfaces.</p> <p>The 'private_id' for tessellation cells is derived from 'tess_id' (generated by <code>create_tessellation</code>) or assigned sequentially if 'tess_id' doesn't directly map. The 'public_id' for street segments is taken directly from the index of <code>segments_gdf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>buildings_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing building polygons. Should contain Polygon or MultiPolygon geometries.</p> required <code>segments_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing street segments. Should contain LineString geometries.</p> required <code>center_point</code> <code>GeoSeries or GeoDataFrame</code> <p>Center point(s) for spatial filtering. If provided with distance parameter, only segments within the specified distance will be included.</p> <code>None</code> <code>distance</code> <code>float</code> <p>Maximum distance from <code>center_point</code> for spatial filtering. When specified, street segments beyond this shortest-path distance are removed and tessellation cells are kept only if their own distance via these segments does not exceed this value.</p> <code>None</code> <code>clipping_buffer</code> <code>float</code> <p>Buffer distance to ensure adequate context for generating tessellation. Must be non-negative.</p> <code>math.inf</code> <code>primary_barrier_col</code> <code>str</code> <p>Column name containing alternative geometry for public spaces. If specified and exists, this geometry will be used instead of the main geometry column for tessellation barriers.</p> <code>'barrier_geometry'</code> <code>contiguity</code> <code>str</code> <p>Type of spatial contiguity for private-to-private connections. Must be either \"queen\" or \"rook\".</p> <code>\"queen\"</code> <code>keep_buildings</code> <code>bool</code> <p>If True, preserves building information in the tessellation output.</p> <code>False</code> <code>keep_segments</code> <code>bool</code> <p>If True, preserves the original segment LineString geometry in a column named 'segment_geometry' in the public nodes GeoDataFrame.</p> <code>True</code> <code>tolerance</code> <code>float</code> <p>Buffer distance for public geometries when creating private-to-public connections. This parameter controls how close private spaces need to be to public spaces to establish a connection.</p> <code>1e-6</code> <code>as_nx</code> <code>bool</code> <p>If True, convert the output to a NetworkX graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[dict[str, GeoDataFrame], dict[tuple[str, str, str], GeoDataFrame]] | Graph</code> <p>If as_nx is False (default), returns a tuple (nodes, edges) where:</p> <ul> <li> <p>nodes: Dictionary containing node GeoDataFrames with keys:</p> <ul> <li>\"private\": Tessellation cells (private spaces)</li> <li>\"public\": Street segments (public spaces)</li> </ul> </li> <li> <p>edges: Dictionary containing edge GeoDataFrames with keys:</p> <ul> <li>(\"private\", \"touched_to\", \"private\"): Adjacency between tessellation cells</li> <li>(\"public\", \"connected_to\", \"public\"): Connectivity between street segments</li> <li>(\"private\", \"faced_to\", \"public\"): Interface between tessellation cells and street segments</li> </ul> </li> </ul> <p>If as_nx is True, returns a NetworkX graph.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If buildings_gdf or segments_gdf are not GeoDataFrames.</p> <code>ValueError</code> <p>If contiguity parameter is not \"queen\" or \"rook\". If clipping_buffer is negative.</p> See Also <p>private_to_private_graph : Create adjacency between private spaces. private_to_public_graph : Create connections between private and public spaces. public_to_public_graph : Create connectivity between public spaces.</p> Notes <p>The function first filters the street network by <code>distance</code> (resulting in <code>segs</code>). A <code>segs_buffer</code> GeoDataFrame is also created for tessellation context, potentially filtered by <code>distance + clipping_buffer</code> or <code>distance</code> if <code>center_point</code> and <code>distance</code> are provided. This <code>segs_buffer</code> is used to create enclosures and tessellations. It then establishes three types of relationships: 1. Private-to-private: Adjacency between tessellation cells (handled by private_to_private_graph) 2. Public-to-public: Topological connectivity between street segments 3. Private-to-public: Spatial interfaces between tessellations and streets</p> <p>The output follows a heterogeneous graph structure suitable for network analysis of urban morphology.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create morphological graph from buildings and segments\n&gt;&gt;&gt; nodes, edges = morphological_graph(buildings_gdf, segments_gdf)\n&gt;&gt;&gt; private_nodes = nodes['private']\n&gt;&gt;&gt; public_nodes = nodes['public']\n</code></pre>"},{"location":"api/morphology.html#component-graphs","title":"Component Graphs","text":"<p>Module for creating morphological graphs from urban data.</p> <p>This module provides comprehensive functionality for analyzing urban morphology through graph representations, focusing on the relationships between private spaces (buildings and their tessellations) and public spaces (street segments). It creates heterogeneous graphs that capture the complex spatial relationships inherent in urban environments. Both GeoDataFrame and NetworkX objects can be converted to PyTorch Geometric Data or HeteroData by functions from graph.py.</p> <p>The module specializes in three types of spatial relationships: 1. Private-to-private: Adjacency relationships between building tessellations 2. Public-to-public: Topological connectivity between street segments 3. Private-to-public: Interface relationships between private and public spaces</p> <p>Functions:</p> Name Description <code>private_to_private_graph</code> <p>Create edges between contiguous private polygons based on spatial adjacency.</p> <code>private_to_public_graph</code> <p>Create edges between private polygons and nearby public geometries.</p> <code>public_to_public_graph</code> <p>Create edges between connected public segments based on topological connectivity.</p> <code>segments_to_graph</code> <p>Convert a GeoDataFrame of LineString segments into a graph structure.</p>"},{"location":"api/morphology.html#city2graph.morphology.private_to_private_graph","title":"private_to_private_graph","text":"<pre><code>private_to_private_graph(\n    private_gdf, group_col=None, contiguity=\"queen\", as_nx=False\n)\n</code></pre> <p>Create edges between contiguous private polygons based on spatial adjacency.</p> <p>This function identifies spatial adjacency relationships between private polygons (e.g., tessellation cells) using either Queen or Rook contiguity criteria. Optionally groups connections within specified groups (e.g., enclosures). The input <code>private_gdf</code> is expected to have a 'private_id' column.</p> <p>Parameters:</p> Name Type Description Default <code>private_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing private space polygons. Must contain a 'private_id' column.</p> required <code>group_col</code> <code>str</code> <p>Column name for grouping connections. Only polygons within the same group will be connected. If None, all polygons are considered as one group.</p> <code>None</code> <code>contiguity</code> <code>str</code> <p>Type of spatial contiguity to use. Must be either \"queen\" or \"rook\". Queen contiguity includes vertex neighbors, Rook includes only edge neighbors.</p> <code>\"queen\"</code> <code>as_nx</code> <code>bool</code> <p>If True, convert the output to a NetworkX graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If as_nx is False (default), returns a tuple (nodes, edges) where:</p> <ul> <li>nodes is a geopandas.GeoDataFrame containing the private nodes.</li> <li>edges is a geopandas.GeoDataFrame containing the adjacency connections.</li> </ul> <p>If as_nx is True, returns a networkx.Graph representing the private adjacency.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If private_gdf is not a GeoDataFrame.</p> <code>ValueError</code> <p>If contiguity not in {\"queen\", \"rook\"}, or if group_col doesn't exist.</p> See Also <p>morphological_graph : Main function that creates comprehensive morphological graphs. private_to_public_graph : Create connections between private and public spaces. public_to_public_graph : Create connectivity between public spaces.</p> Notes <p>The function uses libpysal's spatial weights to determine adjacency relationships. Edge geometries are created as LineStrings connecting polygon centroids. Self-connections and duplicate edges are automatically filtered out. The input private_gdf is expected to have a 'private_id' column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create private-to-private adjacency graph\n&gt;&gt;&gt; nodes, edges = private_to_private_graph(tessellation_gdf)\n&gt;&gt;&gt; # With grouping by enclosures\n&gt;&gt;&gt; nodes, edges = private_to_private_graph(tessellation_gdf, group_col='enclosure_id')\n</code></pre>"},{"location":"api/morphology.html#city2graph.morphology.private_to_public_graph","title":"private_to_public_graph","text":"<pre><code>private_to_public_graph(\n    private_gdf,\n    public_gdf,\n    primary_barrier_col=None,\n    tolerance=1e-06,\n    as_nx=False,\n)\n</code></pre> <p>Create edges between private polygons and nearby public geometries.</p> <p>This function identifies spatial relationships between private spaces (tessellations) and public spaces (street segments) by finding intersections between buffered public geometries and private polygons. Input GDFs are expected to have 'private_id' and 'public_id' columns respectively.</p> <p>Parameters:</p> Name Type Description Default <code>private_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing private space polygons. Expected to have a 'private_id' column.</p> required <code>public_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing public space geometries (typically LineStrings). Expected to have a 'public_id' column.</p> required <code>primary_barrier_col</code> <code>str</code> <p>Column name for alternative public geometry. If specified and exists, this geometry will be used instead of the main geometry column.</p> <code>None</code> <code>tolerance</code> <code>float</code> <p>Buffer distance for public geometries to detect proximity to private spaces.</p> <code>1e-6</code> <code>as_nx</code> <code>bool</code> <p>If True, convert the output to a NetworkX graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If as_nx is False (default), returns a tuple (nodes, edges) where:</p> <ul> <li>nodes is a geopandas.GeoDataFrame containing the combined private and public nodes.</li> <li>edges is a geopandas.GeoDataFrame containing the edges between private and public geometries.</li> </ul> <p>If as_nx is True, returns a networkx.Graph representing the private-to-public connections.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If private_gdf or public_gdf are not GeoDataFrames.</p> <code>ValueError</code> <p>If 'private_id' or 'public_id' columns are missing from input GDFs.</p> See Also <p>morphological_graph : Main function that creates comprehensive morphological graphs. private_to_private_graph : Create adjacency between private spaces. public_to_public_graph : Create connectivity between public spaces.</p> Notes <p>Edge geometries are created as LineStrings connecting the centroids of private polygons and public geometries. The function uses spatial joins to identify overlapping areas within the specified tolerance. Input GDFs are expected to have 'private_id' and 'public_id' columns respectively.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create private-to-public interface graph\n&gt;&gt;&gt; nodes, edges = private_to_public_graph(tessellation_gdf, segments_gdf)\n&gt;&gt;&gt; # With custom tolerance\n&gt;&gt;&gt; nodes, edges = private_to_public_graph(tessellation_gdf, segments_gdf, tolerance=2.0)\n</code></pre>"},{"location":"api/morphology.html#city2graph.morphology.public_to_public_graph","title":"public_to_public_graph","text":"<pre><code>public_to_public_graph(public_gdf, as_nx=False)\n</code></pre> <p>Create edges between connected public segments based on topological connectivity.</p> <p>This function identifies topological connections between public space geometries (typically street segments) using the dual graph approach to find segments that share endpoints or connection points. The function automatically creates a unique identifier for each row if needed.</p> <p>Parameters:</p> Name Type Description Default <code>public_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing public space geometries (typically LineString).</p> required <code>as_nx</code> <code>bool</code> <p>If True, convert the output to a NetworkX graph.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If as_nx is False (default), returns a tuple (nodes, edges) where:</p> <ul> <li>nodes is a geopandas.GeoDataFrame containing the public nodes.</li> <li>edges is a geopandas.GeoDataFrame containing the topological connections.</li> </ul> <p>If as_nx is True, returns a networkx.Graph representing the public connectivity.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If public_gdf is not a GeoDataFrame.</p> See Also <p>morphological_graph : Main function that creates comprehensive morphological graphs. private_to_private_graph : Create adjacency between private spaces. private_to_public_graph : Create connections between private and public spaces.</p> Notes <p>The function uses the dual graph approach where each LineString becomes a node, and edges represent topological connections between segments. Edge geometries are created as LineStrings connecting the centroids of connected segments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create public-to-public connectivity graph\n&gt;&gt;&gt; nodes, edges = public_to_public_graph(segments_gdf)\n&gt;&gt;&gt; # Convert to NetworkX format\n&gt;&gt;&gt; graph = public_to_public_graph(segments_gdf, as_nx=True)\n</code></pre>"},{"location":"api/morphology.html#city2graph.morphology.segments_to_graph","title":"segments_to_graph","text":"<pre><code>segments_to_graph(segments_gdf, multigraph=False, as_nx=False)\n</code></pre> <p>Convert a GeoDataFrame of LineString segments into a graph structure.</p> <p>This function takes a GeoDataFrame of LineStrings and processes it into a topologically explicit graph representation, consisting of a GeoDataFrame of unique nodes (the endpoints of the lines) and a GeoDataFrame of edges.</p> <p>The resulting nodes GeoDataFrame contains unique points representing the start and end points of the input line segments. The edges GeoDataFrame is a copy of the input, but with a new MultiIndex (<code>from_node_id</code>, <code>to_node_id</code>) that references the IDs in the new nodes GeoDataFrame. If <code>multigraph</code> is True and there are multiple edges between the same pair of nodes, an additional index level (<code>edge_key</code>) is added to distinguish them.</p> <p>Parameters:</p> Name Type Description Default <code>segments_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame where each row represents a line segment, and the 'geometry' column contains LineString objects.</p> required <code>multigraph</code> <code>bool</code> <p>If True, supports multiple edges between the same pair of nodes by adding an <code>edge_key</code> level to the MultiIndex. This is useful when the input contains duplicate node-to-node connections that should be preserved as separate edges.</p> <code>False</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph instead of a tuple of GeoDataFrames.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame]</code> <p>A tuple containing two GeoDataFrames:</p> <ul> <li>nodes_gdf: A GeoDataFrame of unique nodes (Points), indexed by <code>node_id</code>.</li> <li>edges_gdf: A GeoDataFrame of edges (LineStrings), with a MultiIndex   mapping to the <code>node_id</code> in <code>nodes_gdf</code>. If <code>multigraph</code> is True,   the index includes a third level (<code>edge_key</code>) for duplicate connections.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from shapely.geometry import LineString\n&gt;&gt;&gt; # Create a GeoDataFrame of line segments\n&gt;&gt;&gt; segments = gpd.GeoDataFrame(\n...     {\"road_name\": [\"A\", \"B\"]},\n...     geometry=[LineString([(0, 0), (1, 1)]), LineString([(1, 1), (1, 0)])],\n...     crs=\"EPSG:32633\"\n... )\n&gt;&gt;&gt; # Convert to graph representation\n&gt;&gt;&gt; nodes_gdf, edges_gdf = segments_to_graph(segments)\n&gt;&gt;&gt; print(nodes_gdf)\n&gt;&gt;&gt; print(edges_gdf)\nnode_id  geometry\n0        POINT (0 0)\n1        POINT (1 1)\n2        POINT (1 0)\n                                road_name   geometry\nfrom_node_id to_node_id\n0            1                  A           LINESTRING (0 0, 1 1)\n1            2                  B           LINESTRING (1 1, 1 0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Example with duplicate connections (multigraph)\n&gt;&gt;&gt; segments_with_duplicates = gpd.GeoDataFrame(\n...     {\"road_name\": [\"A\", \"B\", \"C\"]},\n...     geometry=[LineString([(0, 0), (1, 1)]),\n...               LineString([(0, 0), (1, 1)]),\n...               LineString([(1, 1), (1, 0)])],\n...     crs=\"EPSG:32633\"\n... )\n&gt;&gt;&gt; nodes_gdf, edges_gdf = segments_to_graph(segments_with_duplicates, multigraph=True)\n&gt;&gt;&gt; print(edges_gdf.index.names)\n['from_node_id', 'to_node_id', 'edge_key']\n</code></pre>"},{"location":"api/proximity.html","title":"Proximity Module","text":"<p>The proximity module provides functions for generating proximity-based graph networks from spatial data. These algorithms create edges between geometries based on various spatial relationships.</p>"},{"location":"api/proximity.html#geometric-graph-algorithms","title":"Geometric Graph Algorithms","text":"<p>Proximity-Based Graph Generation Module.</p> <p>This module provides comprehensive functionality for generating graph networks based on spatial proximity relationships between geographic features. It implements several classical proximity models commonly used in spatial network analysis and geographic information systems. The module is particularly useful for constructing heterogeneous graphs from multiple domains of geospatial relations, enabling complex spatial analysis across different feature types and scales.</p> <p>Functions:</p> Name Description <code>knn_graph</code> <p>Generate a k-nearest neighbour graph from a GeoDataFrame of points.</p> <code>delaunay_graph</code> <p>Generate a Delaunay triangulation graph from a GeoDataFrame of points.</p> <code>gabriel_graph</code> <p>Generate a Gabriel graph from a GeoDataFrame of points.</p> <code>relative_neighborhood_graph</code> <p>Generate a Relative-Neighbourhood Graph (RNG) from a GeoDataFrame.</p> <code>euclidean_minimum_spanning_tree</code> <p>Generate a (generalised) Euclidean Minimum Spanning Tree from a GeoDataFrame of points.</p>"},{"location":"api/proximity.html#city2graph.proximity.knn_graph","title":"knn_graph","text":"<pre><code>knn_graph(\n    gdf,\n    k=5,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    target_gdf=None,\n    as_nx=False\n)\n</code></pre> <p>Generate a k-nearest neighbour graph from a GeoDataFrame of points.</p> <p>This function constructs a graph where each node is connected to its k nearest neighbors based on the specified distance metric. The resulting graph captures local spatial relationships and is commonly used in spatial analysis, clustering, and network topology studies.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the points (nodes) for the graph. The index of this GeoDataFrame will be used as node IDs.</p> required <code>k</code> <code>int</code> <p>The number of nearest neighbors to connect to each node. Must be positive and less than the total number of nodes.</p> <code>5</code> <code>distance_metric</code> <code>str</code> <p>The distance metric to use for calculating nearest neighbors. Options are: - \"euclidean\": Straight-line distance - \"manhattan\": City-block distance (L1 norm) - \"network\": Shortest path distance along a network</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame representing a network (e.g., roads, paths) to use for \"network\" distance calculations. Required if <code>distance_metric</code> is \"network\".</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute name in <code>network_gdf</code> to use as the network distance weight. When omitted, weights default to the geometry length of each network edge.</p> <code>None</code> <code>target_gdf</code> <code>GeoDataFrame</code> <p>If provided, creates a directed graph where edges connect nodes from <code>gdf</code> to their k nearest neighbors in <code>target_gdf</code>. If None, creates an undirected graph within <code>gdf</code> itself.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph object. Otherwise, returns a tuple of GeoDataFrames (nodes, edges).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>distance_metric</code> is \"network\" but <code>network_gdf</code> is not provided. If <code>k</code> is greater than or equal to the number of available nodes.</p>"},{"location":"api/proximity.html#city2graph.proximity.delaunay_graph","title":"delaunay_graph","text":"<pre><code>delaunay_graph(\n    gdf,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    as_nx=False\n)\n</code></pre> <p>Generate a Delaunay triangulation graph from a GeoDataFrame of points.</p> <p>This function constructs a graph based on the Delaunay triangulation of the input points. Each edge in the graph corresponds to an edge in the Delaunay triangulation.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the points (nodes) for the graph. The index of this GeoDataFrame will be used as node IDs.</p> required <code>distance_metric</code> <code>str</code> <p>The distance metric to use for calculating edge weights. Options are \"euclidean\", \"manhattan\", or \"network\".</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame representing a network (e.g., roads) to use for \"network\" distance calculations. Required if <code>distance_metric</code> is \"network\".</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute name in <code>network_gdf</code> used as the path weight when <code>distance_metric</code> is <code>\"network\"</code>. Defaults to geometry length.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph object. Otherwise, returns a tuple of GeoDataFrames (nodes, edges).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>distance_metric</code> is \"network\" but <code>network_gdf</code> is not provided.</p> See Also <p>knn_graph : Generate a k-nearest neighbour graph. fixed_radius_graph : Generate a fixed-radius graph. waxman_graph : Generate a probabilistic Waxman graph.</p> Notes <ul> <li>Node IDs are preserved from the input GeoDataFrame's index.</li> <li>Edge weights represent the distance between connected nodes.</li> <li>Edge geometries are LineStrings connecting the centroids of the nodes.</li> <li>If the input gdf has fewer than 3 points, an empty graph will be returned as Delaunay   triangulation requires at least 3 non-collinear points.</li> </ul> References <p>.. [1] Lee, D. T., &amp; Schachter, B. J. (1980). Two algorithms for constructing a    Delaunay triangulation. International Journal of Computer &amp; Information Sciences, 9(3),    219-242. https://doi.org/10.1007/BF00977785</p>"},{"location":"api/proximity.html#city2graph.proximity.gabriel_graph","title":"gabriel_graph","text":"<pre><code>gabriel_graph(\n    gdf,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    as_nx=False\n)\n</code></pre> <p>Generate a Gabriel graph from a GeoDataFrame of points.</p> <p>In a Gabriel graph two nodes u and v are connected iff the closed disc that has \\(uv\\) as its diameter contains no other node of the set.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Input point layer. The GeoDataFrame index is preserved as the node id.</p> required <code>distance_metric</code> <code>('euclidean', 'manhattan', 'network')</code> <p>Metric used for edge weights / geometries (see the other generators).</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>Required when <code>distance_metric='network'</code>.</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute in <code>network_gdf</code> that supplies weights for network distances. Defaults to geometry length when not provided.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True return a NetworkX graph, otherwise return two GeoDataFrames (nodes, edges) via <code>nx_to_gdf</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> Notes <ul> <li>The Gabriel graph is a sub-graph of the Delaunay triangulation; therefore the   implementation first builds the Delaunay edges then filters them according to the   disc-emptiness predicate, achieving an overall \\(O(n \\\\log n + mk)\\)   complexity (m = Delaunay edges, k = average neighbours tested per edge).</li> <li>When the input layer has exactly two points, the unique edge is returned.</li> <li>If the layer has fewer than two points, an empty graph is produced.</li> </ul> References <p>.. [1] Gabriel, K. R., &amp; Sokal, R. R. (1969). A new statistical approach to geographic    variation analysis. Systematic zoology, 18(3), 259-278.    https://doi.org/10.2307/2412323</p>"},{"location":"api/proximity.html#city2graph.proximity.relative_neighborhood_graph","title":"relative_neighborhood_graph","text":"<pre><code>relative_neighborhood_graph(\n    gdf,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    as_nx=False\n)\n</code></pre> <p>Generate a Relative-Neighbourhood Graph (RNG) from a GeoDataFrame.</p> <p>In an RNG two nodes u and v are connected iff there is no third node w such that both \\(d(u,w) &lt; d(u,v)\\) and \\(d(v,w) &lt; d(u,v)\\). Equivalently, the intersection of the two open discs having radius \\(d(u,v)\\) and centres u and v (the lune) is empty.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Input point layer whose index provides the node ids.</p> required <code>distance_metric</code> <code>('euclidean', 'manhattan', 'network')</code> <p>Metric used to attach edge weights / geometries (see the other generators).</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>Required when <code>distance_metric='network'</code>.</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute in <code>network_gdf</code> used for network distances. Defaults to geometry length when omitted.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True return a NetworkX graph, otherwise return two GeoDataFrames (nodes, edges) via <code>nx_to_gdf</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> Notes <ul> <li>The RNG is a sub-graph of the Delaunay triangulation; therefore the   implementation first collects Delaunay edges (\\(O(n \\\\log n)\\)) and then filters   them according to the lune-emptiness predicate.</li> <li>When the input layer has exactly two points the unique edge is returned.</li> <li>If the layer has fewer than two points, an empty graph is produced.</li> </ul> References <p>.. [1] Toussaint, G. T. (1980). The relative neighbourhood graph of a finite planar    set. Pattern recognition, 12(4), 261-268.    https://doi.org/10.1016/0031-3203(80)90066-7</p>"},{"location":"api/proximity.html#city2graph.proximity.euclidean_minimum_spanning_tree","title":"euclidean_minimum_spanning_tree","text":"<pre><code>euclidean_minimum_spanning_tree(\n    gdf,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    as_nx=False\n)\n</code></pre> <p>Generate a (generalised) Euclidean Minimum Spanning Tree from a GeoDataFrame of points.</p> <p>The classical Euclidean Minimum Spanning Tree (EMST) is the minimum-total-length tree that connects a set of points when edge weights are the straight-line (\\(L_2\\)) distances. For consistency with the other generators this implementation also supports manhattan and network metrics - it simply computes the minimum-weight spanning tree under the chosen metric. When the metric is euclidean the edge search is restricted to the Delaunay triangulation (EMST \u2286 Delaunay), guaranteeing an \\(O(n \\log n)\\) overall complexity. With other metrics, or degenerate cases where the triangulation cannot be built, the algorithm gracefully falls back to the complete graph.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Input point layer. The index is preserved as the node identifier.</p> required <code>distance_metric</code> <code>('euclidean', 'manhattan', 'network')</code> <p>Metric used for the edge weights / geometries.</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>Required when <code>distance_metric='network'</code>. Must contain the network arcs with valid pos attributes on its nodes.</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute name in <code>network_gdf</code> used for weighting shortest paths when <code>distance_metric='network'</code>. Defaults to geometry length.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True return a NetworkX graph, otherwise return two GeoDataFrames (nodes, edges) via <code>nx_to_gdf</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> See Also <p>delaunay_graph : Generate a Delaunay triangulation graph. gabriel_graph : Generate a Gabriel graph. relative_neighborhood_graph : Generate a Relative Neighborhood Graph.</p> Notes <ul> <li>The resulting graph always contains n - 1 edges (or 0 / 1 when the input has &lt; 2 points).</li> <li>For planar Euclidean inputs the computation is \\(O(n \\\\log n)\\) thanks to the   Delaunay pruning.</li> <li>All the usual spatial attributes (weight, geometry, CRS checks, etc.) are attached   through the shared private helpers.</li> </ul> References <p>.. [1] March, W. B., Ram, P., &amp; Gray, A. G. (2010, July). Fast euclidean minimum    spanning tree: algorithm, analysis, and applications. In Proceedings of the 16th ACM    SIGKDD international conference on Knowledge discovery and data mining (pp.    603-612). https://doi.org/10.1145/1835804.1835882</p>"},{"location":"api/proximity.html#distance-based-graphs","title":"Distance-Based Graphs","text":"<p>Proximity-Based Graph Generation Module.</p> <p>This module provides comprehensive functionality for generating graph networks based on spatial proximity relationships between geographic features. It implements several classical proximity models commonly used in spatial network analysis and geographic information systems. The module is particularly useful for constructing heterogeneous graphs from multiple domains of geospatial relations, enabling complex spatial analysis across different feature types and scales.</p> <p>Functions:</p> Name Description <code>fixed_radius_graph</code> <p>Generate a fixed-radius graph from a GeoDataFrame of points.</p> <code>waxman_graph</code> <p>Generate a probabilistic Waxman graph from a GeoDataFrame of points.</p>"},{"location":"api/proximity.html#city2graph.proximity.fixed_radius_graph","title":"fixed_radius_graph","text":"<pre><code>fixed_radius_graph(\n    gdf,\n    radius,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    target_gdf=None,\n    as_nx=False\n)\n</code></pre> <p>Generate a fixed-radius graph from a GeoDataFrame of points.</p> <p>This function constructs a graph where nodes are connected if the distance between them is within a specified radius. This model is particularly useful for modeling communication networks, ecological connectivity, and spatial influence zones where interaction strength has a clear distance threshold.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the source points (nodes) for the graph. The index of this GeoDataFrame will be used as node IDs.</p> required <code>radius</code> <code>float</code> <p>The maximum distance for connecting nodes. Nodes within this radius will have an edge between them. Must be positive.</p> required <code>distance_metric</code> <code>str</code> <p>The distance metric to use for determining connections. Options are: - \"euclidean\": Straight-line distance - \"manhattan\": City-block distance (L1 norm) - \"network\": Shortest path distance along a network</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame representing a network (e.g., roads) to use for \"network\" distance calculations. Required if <code>distance_metric</code> is \"network\".</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute in <code>network_gdf</code> used as path weights when <code>distance_metric=\"network\"</code>. Defaults to geometry length when not provided.</p> <code>None</code> <code>target_gdf</code> <code>GeoDataFrame</code> <p>If provided, creates a directed graph where edges connect nodes from <code>gdf</code> to nodes in <code>target_gdf</code> within the specified radius. If None, creates an undirected graph from <code>gdf</code> itself.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph object. Otherwise, returns a tuple of GeoDataFrames (nodes, edges).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>distance_metric</code> is \"network\" but <code>network_gdf</code> is not provided. If <code>radius</code> is not positive.</p> See Also <p>knn_graph : Generate a k-nearest neighbour graph. delaunay_graph : Generate a Delaunay triangulation graph. waxman_graph : Generate a probabilistic Waxman graph.</p> Notes <ul> <li>Node IDs are preserved from the input GeoDataFrame's index</li> <li>Edge weights represent the actual distance between connected nodes</li> <li>Edge geometries are LineStrings connecting node centroids</li> <li>The graph stores the radius parameter in G.graph[\"radius\"]</li> <li>For Manhattan distance, edges follow L-shaped geometric paths</li> </ul> References <p>.. [1] Bentley, J. L., Stanat, D. F., &amp; Williams Jr, E. H. (1977). The complexity of    finding fixed-radius near neighbors. Information processing letters, 6(6),    209-212. https://doi.org/10.1016/0020-0190(77)90070-9</p>"},{"location":"api/proximity.html#city2graph.proximity.waxman_graph","title":"waxman_graph","text":"<pre><code>waxman_graph(\n    gdf,\n    beta,\n    r0,\n    seed=None,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    *,\n    as_nx=False\n)\n</code></pre> <p>Generate a probabilistic Waxman graph from a GeoDataFrame of points.</p> <p>This function constructs a random graph where the probability of an edge existing between two nodes decreases exponentially with their distance. The model is based on the Waxman random graph model, commonly used to simulate realistic network topologies in telecommunications, transportation, and social networks where connection probability diminishes with distance.</p> <p>The connection probability follows the formula:</p> \\[ P(u,v) = \\beta \\times \\exp \\left(-\\frac{\\text{dist}(u,v)}{r_0}\\right) \\] <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing the points (nodes) for the graph. The index of this GeoDataFrame will be used as node IDs.</p> required <code>beta</code> <code>float</code> <p>Parameter controlling the overall probability of edge creation. Higher values (closer to 1.0) increase the likelihood of connections. Must be between 0 and 1.</p> required <code>r0</code> <code>float</code> <p>Parameter controlling the decay rate of probability with distance. Higher values result in longer-range connections being more likely. Must be positive.</p> required <code>seed</code> <code>int</code> <p>Seed for the random number generator to ensure reproducibility of results. If None, results will vary between runs.</p> <code>None</code> <code>distance_metric</code> <code>str</code> <p>The distance metric to use for calculating distances between nodes. Options are: - \"euclidean\": Straight-line distance - \"manhattan\": City-block distance (L1 norm) - \"network\": Shortest path distance along a network</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>A GeoDataFrame representing a network (e.g., roads) to use for \"network\" distance calculations. Required if <code>distance_metric</code> is \"network\".</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute name in <code>network_gdf</code> used for network distances. Defaults to geometry length when omitted.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph object. Otherwise, returns a tuple of GeoDataFrames (nodes, edges).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple of GeoDataFrames: - nodes_gdf: GeoDataFrame of nodes with spatial and attribute information - edges_gdf: GeoDataFrame of edges with 'weight' and 'geometry' attributes If <code>as_nx</code> is True, returns a NetworkX graph object with spatial attributes.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>distance_metric</code> is \"network\" but <code>network_gdf</code> is not provided. If <code>beta</code> is not between 0 and 1, or if <code>r0</code> is not positive.</p> See Also <p>knn_graph : Generate a k-nearest neighbour graph. delaunay_graph : Generate a Delaunay triangulation graph. fixed_radius_graph : Generate a fixed-radius graph.</p> Notes <ul> <li>Node IDs are preserved from the input GeoDataFrame's index</li> <li>Edge weights represent the actual distance between connected nodes</li> <li>Edge geometries are LineStrings connecting node centroids</li> <li>The graph stores parameters in G.graph[\"beta\"] and G.graph[\"r0\"]</li> <li>Results are stochastic; use seed parameter for reproducible outputs</li> <li>The graph is undirected with symmetric edge probabilities</li> </ul> References <p>.. [1] Waxman, B. M. (2002). Routing of multipoint connections. IEEE journal on    selected areas in communications, 6(9), 1617-1622.    https://doi.org/10.1109/49.12889</p>"},{"location":"api/proximity.html#node-manipulation","title":"Node Manipulation","text":"<p>Proximity-Based Graph Generation Module.</p> <p>This module provides comprehensive functionality for generating graph networks based on spatial proximity relationships between geographic features. It implements several classical proximity models commonly used in spatial network analysis and geographic information systems. The module is particularly useful for constructing heterogeneous graphs from multiple domains of geospatial relations, enabling complex spatial analysis across different feature types and scales.</p> <p>Functions:</p> Name Description <code>bridge_nodes</code> <p>Build directed proximity edges between every ordered pair of node layers.</p> <code>group_nodes</code> <p>Create a heterogeneous graph linking polygon zones to contained points.</p>"},{"location":"api/proximity.html#city2graph.proximity.bridge_nodes","title":"bridge_nodes","text":"<pre><code>bridge_nodes(\n    nodes_dict,\n    proximity_method=\"knn\",\n    *,\n    source_node_types=None,\n    target_node_types=None,\n    multigraph=False,\n    as_nx=False,\n    **kwargs\n)\n</code></pre> <p>Build directed proximity edges between every ordered pair of node layers.</p> <p>This function creates a multi-layer spatial network by generating directed proximity edges from nodes in one GeoDataFrame layer to nodes in another. It systematically processes all ordered pairs of layers and applies either k-nearest neighbors (KNN) or fixed-radius method to establish inter-layer connections. This function is specifically designed for constructing heterogeneous graphs by generating new edge types (\"is_nearby\") between different types of nodes, enabling the modeling of complex relationships across multiple domains. It is useful for modeling complex urban systems, ecological networks, or multi-modal transportation systems where different types of entities interact through spatial proximity.</p> <p>Parameters:</p> Name Type Description Default <code>nodes_dict</code> <code>dict[str, GeoDataFrame]</code> <p>A dictionary where keys are layer names (strings) and values are GeoDataFrames representing the nodes of each layer. Each GeoDataFrame should contain point geometries with consistent CRS across all layers.</p> required <code>proximity_method</code> <code>str</code> <p>The method to use for generating proximity edges between layers. Options are: - \"knn\": k-nearest neighbors method - \"fixed_radius\": fixed-radius method</p> <code>\"knn\"</code> <code>source_node_types</code> <code>Iterable[str]</code> <p>Node types from <code>nodes_dict</code> that should act as sources. When None, all node types are considered sources.</p> <code>None</code> <code>target_node_types</code> <code>Iterable[str]</code> <p>Node types from <code>nodes_dict</code> that should act as targets. When None, all node types are considered targets.</p> <code>None</code> <code>multigraph</code> <code>bool</code> <p>If True, the resulting NetworkX graph will be a MultiGraph, allowing multiple edges between the same pair of nodes from different proximity relationships.</p> <code>False</code> <code>as_nx</code> <code>bool</code> <p>If True, returns a NetworkX graph object containing all nodes and inter-layer edges. Otherwise, returns dictionaries of GeoDataFrames.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the underlying proximity method:</p> <p>For <code>proximity_method=\"knn\"</code>:     - k : int, default 1       Number of nearest neighbors to connect to in target layer     - distance_metric : str, default \"euclidean\"       Distance metric (\"euclidean\", \"manhattan\", \"network\")     - network_gdf : geopandas.GeoDataFrame, optional       Network for \"network\" distance calculations     - network_weight : str, optional         Edge attribute used as shortest-path weight when <code>distance_metric='network'</code></p> <p>For <code>proximity_method=\"fixed_radius\"</code>:     - radius : float, required       Maximum connection distance between layers     - distance_metric : str, default \"euclidean\"       Distance metric (\"euclidean\", \"manhattan\", \"network\")     - network_gdf : geopandas.GeoDataFrame, optional       Network for \"network\" distance calculations     - network_weight : str, optional         Edge attribute used as shortest-path weight when <code>distance_metric='network'</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[dict[str, GeoDataFrame], dict[tuple[str, str, str], GeoDataFrame]] or Graph</code> <p>If <code>as_nx</code> is False, returns a tuple containing:</p> <ul> <li>nodes_dict: The original input nodes_dict (unchanged)</li> <li>edges_dict: Dictionary where keys are edge type tuples of the form   (source_layer_name, \"is_nearby\", target_layer_name) and values are GeoDataFrames   of the generated directed edges. Each unique tuple represents a distinct edge type   in the heterogeneous graph, enabling differentiation between relationships across   different node type combinations.</li> </ul> <p>If <code>as_nx</code> is True, returns a NetworkX graph object containing all nodes from all layers and the generated directed inter-layer edges, forming a heterogeneous graph structure where different node types are connected through proximity-based relationships.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>nodes_dict</code> contains fewer than two layers. If <code>proximity_method</code> is not \"knn\" or \"fixed_radius\". If <code>proximity_method</code> is \"fixed_radius\" but <code>radius</code> is not provided in kwargs. If unknown node types are provided via <code>source_node_types</code> or <code>target_node_types</code>.</p> See Also <p>knn_graph : Generate a k-nearest neighbour graph. fixed_radius_graph : Generate a fixed-radius graph.</p> Notes <ul> <li>All generated edges are directed from source layer to target layer</li> <li>The relation type for all generated edges is fixed as \"is_nearby\", creating a   new edge type that bridges different node types in heterogeneous graphs</li> <li>Each ordered pair of node layers generates a distinct edge type, enabling the   construction of rich heterogeneous graph structures with multiple relationship   types between different domain entities</li> <li>Edge weights and geometries are calculated based on the chosen <code>distance_metric</code></li> <li>Each ordered pair of layers generates a separate edge GeoDataFrame</li> <li>Self-connections (layer to itself) are not created</li> <li>The resulting structure is ideal for heterogeneous graph neural networks,   multi-layer network analysis, and cross-domain spatial relationship modeling</li> </ul>"},{"location":"api/proximity.html#city2graph.proximity.group_nodes","title":"group_nodes","text":"<pre><code>group_nodes(\n    polygons_gdf,\n    points_gdf,\n    *,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    predicate=\"covered_by\",\n    as_nx=False\n)\n</code></pre> <p>Create a heterogeneous graph linking polygon zones to contained points.</p> <p>This function builds a bipartite relation between polygon and point features by connecting each polygon to the points that satisfy a spatial containment predicate (default: \"covered_by\" so boundary points are included). It follows city2graph heterogeneous graph conventions and reuses the proximity helpers for computing edge weights and geometries according to the chosen distance metric.</p> <p>Parameters:</p> Name Type Description Default <code>polygons_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame of polygonal features representing zones. CRS must match <code>points_gdf</code>. Original attributes and geometries are preserved in the resulting polygon nodes.</p> required <code>points_gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame of point features to be associated with the polygons. CRS must match <code>polygons_gdf</code>. Original attributes and geometries are preserved in the resulting point nodes.</p> required <code>distance_metric</code> <code>('euclidean', 'manhattan', 'network')</code> <p>Metric used for edge weights and geometries. Euclidean produces straight line segments, Manhattan produces L-shaped polylines, and Network traces polylines along the provided <code>network_gdf</code> and uses shortest-path distances.</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>Required when <code>distance_metric=\"network\"</code>. Must share the same CRS as the inputs.</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute in <code>network_gdf</code> supplying network path weights. Defaults to geometry length when omitted.</p> <code>None</code> <code>predicate</code> <code>str</code> <p>Spatial predicate used to determine containment in a vectorized spatial join (e.g., \"covered_by\", \"within\", \"contains\", \"intersects\"). The default includes points on polygon boundaries.</p> <code>\"covered_by\"</code> <code>as_nx</code> <code>bool</code> <p>If False, return heterogeneous GeoDataFrame dictionaries. If True, return a typed heterogeneous NetworkX graph built with <code>gdf_to_nx</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[dict[str, GeoDataFrame], dict[tuple[str, str, str], GeoDataFrame]] or Graph</code> <p>(nodes_dict, edges_dict) (tuple of dicts)     Returned when <code>as_nx=False</code>. <code>nodes_dict</code> is {\"polygon\": polygons_gdf, \"point\":     points_gdf} with original indices, attributes, and geometries. <code>edges_dict</code> maps a     typed edge key to an edges GeoDataFrame whose index is a MultiIndex of     (polygon_id, point_id) and includes at least weight and geometry columns. The edge key     has the form (\"polygon\", relation, \"point\"), where relation is derived from     predicate (e.g., covered_by -&gt; \"covers\", within -&gt; \"contains\"). G (networkx.Graph)     Returned when <code>as_nx=True</code>. A heterogeneous graph with node_type in nodes and     a typed edge_type reflecting the relation derived from predicate. Graph metadata     includes crs and is_hetero=True.</p> Notes <ul> <li>CRS must be present and identical for both inputs. For network metric, the   network's CRS must also match.</li> <li>Boundary points are included by default via <code>predicate=\"covered_by\"</code>.</li> <li>Distance calculations and edge geometries reuse internal helpers   (_prepare_nodes, _distance_matrix, _add_edges) to ensure consistency with other   proximity functions.</li> </ul>"},{"location":"api/proximity.html#contiguity-graphs","title":"Contiguity Graphs","text":"<p>Proximity-Based Graph Generation Module.</p> <p>This module provides comprehensive functionality for generating graph networks based on spatial proximity relationships between geographic features. It implements several classical proximity models commonly used in spatial network analysis and geographic information systems. The module is particularly useful for constructing heterogeneous graphs from multiple domains of geospatial relations, enabling complex spatial analysis across different feature types and scales.</p> <p>Functions:</p> Name Description <code>contiguity_graph</code> <p>Generate a contiguity-based spatial graph from polygon geometries.</p>"},{"location":"api/proximity.html#city2graph.proximity.contiguity_graph","title":"contiguity_graph","text":"<pre><code>contiguity_graph(\n    gdf,\n    contiguity=\"queen\",\n    *,\n    distance_metric=\"euclidean\",\n    network_gdf=None,\n    network_weight=None,\n    as_nx=False\n)\n</code></pre> <p>Generate a contiguity-based spatial graph from polygon geometries.</p> <p>This function creates a spatial graph where nodes represent polygons and edges connect spatially contiguous (adjacent) polygons based on Queen or Rook contiguity rules. It leverages libpysal's robust spatial weights functionality to accurately determine adjacency relationships, making it ideal for spatial analysis of administrative boundaries, urban morphology studies, land use patterns, and geographic network analysis.</p> <p>The function supports both Queen contiguity (polygons sharing edges or vertices) and Rook contiguity (polygons sharing only edges), providing flexibility for different spatial analysis requirements. Edge weights are calculated as distances between polygon centroids using the selected <code>distance_metric</code>. Supported metrics:</p> <ul> <li><code>euclidean</code> (default): straight-line distance; edge geometry is a direct   centroid-to-centroid LineString.</li> <li><code>manhattan</code>: L1 distance; edge geometry is an L-shaped polyline (two segments)   following an axis-aligned path between centroids.</li> <li><code>network</code>: shortest-path distance over <code>network_gdf</code> (a line network in the   same CRS); edge geometry is the polyline path traced along the network.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>Input GeoDataFrame containing polygon geometries. Must contain valid polygon geometries in the 'geometry' column. The index of this GeoDataFrame will be preserved as node identifiers in the output graph. All original attributes are maintained in the nodes output.</p> required <code>contiguity</code> <code>('queen', 'rook')</code> <p>Type of spatial contiguity rule to apply for determining adjacency:</p> <ul> <li>\"queen\": Polygons are considered adjacent if they share any boundary (edges or   vertices). This is more inclusive and typically results in more connections.</li> <li>\"rook\": Polygons are considered adjacent only if they share an edge (not just   vertices). This is more restrictive and results in fewer connections.</li> </ul> <code>\"queen\"</code> <code>distance_metric</code> <code>('euclidean', 'manhattan', 'network')</code> <p>Metric used to compute edge weights and geometries.</p> <code>\"euclidean\"</code> <code>network_gdf</code> <code>GeoDataFrame</code> <p>Required when <code>distance_metric='network'</code>. A line-based network whose CRS matches <code>gdf</code>.</p> <code>None</code> <code>network_weight</code> <code>str</code> <p>Edge attribute in <code>network_gdf</code> to use for shortest-path weights. Defaults to geometry length when omitted.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>Output format control. If True, returns a NetworkX Graph object with spatial attributes. If False, returns a tuple of GeoDataFrames for nodes and edges, compatible with other city2graph functions.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>When <code>as_nx=False</code> (default), returns <code>(nodes_gdf, edges_gdf)</code> as GeoDataFrames. When <code>as_nx=True</code>, returns a NetworkX Graph with spatial attributes and metadata.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>gdf</code> is not a geopandas.GeoDataFrame instance.</p> <code>ValueError</code> <p>If <code>contiguity</code> is not one of {\"queen\", \"rook\"}. If <code>gdf</code> contains geometries that are not polygons (Point, LineString, etc.). If <code>gdf</code> contains invalid or corrupt polygon geometries. If libpysal fails to create spatial weights matrix.</p> See Also <p>libpysal.weights.Queen : Spatial weights based on Queen contiguity. libpysal.weights.Rook : Spatial weights based on Rook contiguity. knn_graph : Generate k-nearest neighbor graphs from point data. delaunay_graph : Generate Delaunay triangulation graphs from point data. fixed_radius_graph : Generate fixed-radius proximity graphs. gabriel_graph : Generate Gabriel graphs from point data. relative_neighborhood_graph : Generate relative neighborhood graphs. waxman_graph : Generate probabilistic Waxman graphs.</p>"},{"location":"api/transportation.html","title":"Transportation Module","text":"<p>The transportation module provides functions for processing GTFS (General Transit Feed Specification) data and creating transportation network graphs.</p>"},{"location":"api/transportation.html#gtfs-processing","title":"GTFS Processing","text":"<p>Transportation Network Analysis Module.</p> <p>This module provides comprehensive functionality for processing General Transit Feed Specification (GTFS) data and creating transportation network representations. It specializes in converting public transit data into graph structures suitable for network analysis and accessibility studies.</p> <p>All functions return ready-to-use pandas/GeoPandas objects or NetworkX graphs that can be seamlessly integrated into analysis pipelines, notebooks, or model training workflows.</p> <p>Functions:</p> Name Description <code>load_gtfs</code> <p>Parse a GTFS zip file and enrich stops/shapes with geometry.</p> <code>get_od_pairs</code> <p>Materialise origin-destination pairs for every trip and service day.</p>"},{"location":"api/transportation.html#city2graph.transportation.load_gtfs","title":"load_gtfs","text":"<pre><code>load_gtfs(path)\n</code></pre> <p>Parse a GTFS zip file and enrich stops/shapes with geometry.</p> <p>This function loads a GTFS (General Transit Feed Specification) zip file and converts it into a dictionary of pandas/GeoPandas DataFrames. Stop locations and route shapes are automatically converted to geometric objects for spatial analysis.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Location of the zipped GTFS feed (e.g. <code>\"./rome_gtfs.zip\"</code>).</p> required <p>Returns:</p> Type Description <code>dict[str, DataFrame or GeoDataFrame]</code> <p>Keys are the original GTFS file names (without extension) and values are pandas or GeoPandas DataFrames ready for analysis.</p> See Also <p>get_od_pairs : Create origin-destination pairs from GTFS data. travel_summary_graph : Create network representation from GTFS data.</p> Notes <ul> <li>The function never mutates the original file - everything is kept     in memory.</li> <li>Geometry columns are added only when the relevant coordinate     columns are present and valid.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; gtfs = load_gtfs(Path(\"data/rome_gtfs.zip\"))\n&gt;&gt;&gt; print(list(gtfs))\n['agency', 'routes', 'trips', 'stops', ...]\n&gt;&gt;&gt; gtfs['stops'].head(3)[['stop_name', 'geometry']]\n       stop_name                     geometry\n0  Termini (MA)  POINT (12.50118 41.90088)\n1   Colosseo(MB)  POINT (12.49224 41.89021)\n</code></pre>"},{"location":"api/transportation.html#city2graph.transportation.get_od_pairs","title":"get_od_pairs","text":"<pre><code>get_od_pairs(gtfs, start_date=None, end_date=None, include_geometry=True)\n</code></pre> <p>Materialise origin-destination pairs for every trip and service day.</p> <p>This function creates a comprehensive dataset of all origin-destination pairs for transit trips within the specified date range, optionally including geometric information for spatial analysis.</p> <p>Parameters:</p> Name Type Description Default <code>gtfs</code> <code>dict</code> <p>Dictionary returned by :func:<code>load_gtfs</code>.</p> required <code>start_date</code> <code>str or None</code> <p>Restrict the calendar expansion to the closed interval <code>[start_date, end_date]</code> (format YYYYMMDD).  When None the period is inferred from <code>calendar.txt</code>.</p> <code>None</code> <code>end_date</code> <code>str or None</code> <p>Restrict the calendar expansion to the closed interval <code>[start_date, end_date]</code> (format YYYYMMDD).  When None the period is inferred from <code>calendar.txt</code>.</p> <code>None</code> <code>include_geometry</code> <code>bool</code> <p>If True the result is a GeoDataFrame whose geometry is a straight LineString connecting the two stops.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame or GeoDataFrame</code> <p>One row per trip-day-leg with departure / arrival timestamps, travel time in seconds and, optionally, geometry.</p> See Also <p>load_gtfs : Load GTFS data from zip file. travel_summary_graph : Create network representation from GTFS data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gtfs = load_gtfs(\"data/rome_gtfs.zip\")\n&gt;&gt;&gt; od = get_od_pairs(gtfs, start_date=\"20230101\", end_date=\"20230107\")\n&gt;&gt;&gt; od.head(3)[['orig_stop_id', 'dest_stop_id', 'travel_time_sec']]\n  orig_stop_id dest_stop_id  travel_time_sec\n0      7045490      7045491            120.0\n1      7045491      7045492            180.0\n2      7045492      7045493            240.0\n</code></pre>"},{"location":"api/transportation.html#graph-construction","title":"Graph Construction","text":"<p>Transportation Network Analysis Module.</p> <p>This module provides comprehensive functionality for processing General Transit Feed Specification (GTFS) data and creating transportation network representations. It specializes in converting public transit data into graph structures suitable for network analysis and accessibility studies.</p> <p>All functions return ready-to-use pandas/GeoPandas objects or NetworkX graphs that can be seamlessly integrated into analysis pipelines, notebooks, or model training workflows.</p> <p>Functions:</p> Name Description <code>travel_summary_graph</code> <p>Aggregate stop-to-stop travel time &amp; frequency into an edge list.</p>"},{"location":"api/transportation.html#city2graph.transportation.travel_summary_graph","title":"travel_summary_graph","text":"<pre><code>travel_summary_graph(\n    gtfs,\n    start_time=None,\n    end_time=None,\n    calendar_start=None,\n    calendar_end=None,\n    as_nx=False,\n)\n</code></pre> <p>Aggregate stop-to-stop travel time &amp; frequency into an edge list.</p> <p>This function analyzes GTFS data to create a network representation of transit connections, computing average travel times and service frequencies between consecutive stops.</p> <p>Parameters:</p> Name Type Description Default <code>gtfs</code> <code>dict</code> <p>A dictionary produced by :func:<code>load_gtfs</code> - must contain at least <code>stop_times</code> and <code>stops</code>.</p> required <code>start_time</code> <code>str or None</code> <p>Consider only trips whose departure falls inside <code>[start_time, end_time]</code> (format HH:MM:SS).  When None the whole service day is used.</p> <code>None</code> <code>end_time</code> <code>str or None</code> <p>Consider only trips whose departure falls inside <code>[start_time, end_time]</code> (format HH:MM:SS).  When None the whole service day is used.</p> <code>None</code> <code>calendar_start</code> <code>str or None</code> <p>Period over which service-days are counted (format YYYYMMDD).  If omitted it spans the native range in <code>calendar.txt</code>.</p> <code>None</code> <code>calendar_end</code> <code>str or None</code> <p>Period over which service-days are counted (format YYYYMMDD).  If omitted it spans the native range in <code>calendar.txt</code>.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True return a NetworkX graph, otherwise two GeoDataFrames <code>(nodes_gdf, edges_gdf)</code>.  The latter follow the convention used in utils.py.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame] or Graph</code> <p>\u2022 Nodes - every stop with a valid geometry. \u2022 Edges - columns = <code>from_stop_id, to_stop_id, travel_time_sec,   frequency, geometry</code>.</p> See Also <p>get_od_pairs : Create origin-destination pairs from GTFS data. load_gtfs : Load GTFS data from zip file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gtfs = load_gtfs(\"data/rome_gtfs.zip\")\n&gt;&gt;&gt; nodes, edges = travel_summary_graph(\n...     gtfs,\n...     start_time=\"07:00:00\",\n...     end_time=\"10:00:00\",\n... )\n&gt;&gt;&gt; print(edges.head(3)[['travel_time_sec', 'frequency']])\n                   travel_time_sec  frequency\nfrom_stop_id to_stop_id\n7045490      7045491            120.0        42\n7045491      7045492            180.0        42\n7045492      7045493            240.0        42\n</code></pre> <p>You can directly obtain a NetworkX object too:</p> <pre><code>&gt;&gt;&gt; G = travel_summary_graph(gtfs, as_nx=True)\n&gt;&gt;&gt; print(G.number_of_nodes(), G.number_of_edges())\n2564 3178\n</code></pre>"},{"location":"api/utils.html","title":"Utils Module","text":"<p>The utils module provides core utility functions for graph conversion, validation, and visualization.</p>"},{"location":"api/utils.html#conversion-functions","title":"Conversion Functions","text":"<p>Core Utilities Module.</p> <p>This module provides essential utilities for graph conversion, data validation, and spatial analysis operations. It serves as the foundation for the city2graph package, offering a standardized data format for handling geospatial relations across GeoPandas, NetworkX objects, and eventually PyTorch Geometric objects. The module enables seamless integration between different graph representations and geospatial data formats through robust data structures and conversion functions.</p> <p>Functions:</p> Name Description <code>gdf_to_nx</code> <p>Convert GeoDataFrames of nodes and edges to a NetworkX graph.</p> <code>nx_to_gdf</code> <p>Convert a NetworkX graph to GeoDataFrames for nodes and/or edges.</p> <code>nx_to_rx</code> <p>Convert a NetworkX graph to a rustworkx graph.</p> <code>rx_to_nx</code> <p>Convert a rustworkx graph to a NetworkX graph.</p>"},{"location":"api/utils.html#city2graph.utils.gdf_to_nx","title":"gdf_to_nx","text":"<pre><code>gdf_to_nx(\n    nodes=None, edges=None, keep_geom=True, multigraph=False, directed=False\n)\n</code></pre> <p>Convert GeoDataFrames of nodes and edges to a NetworkX graph.</p> <p>This function provides a high-level interface to convert geospatial data, represented as GeoDataFrames, into a NetworkX graph. It supports both homogeneous and heterogeneous graphs.</p> <p>For homogeneous graphs, provide a single GeoDataFrame for nodes and edges. For heterogeneous graphs, provide dictionaries mapping type names to GeoDataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>GeoDataFrame or dict[str, GeoDataFrame]</code> <p>Node data. For homogeneous graphs, a single GeoDataFrame. For heterogeneous graphs, a dictionary mapping node type names to GeoDataFrames. Node IDs are taken from the GeoDataFrame index.</p> <code>None</code> <code>edges</code> <code>GeoDataFrame or dict[tuple[str, str, str], GeoDataFrame]</code> <p>Edge data. For homogeneous graphs, a single GeoDataFrame. For heterogeneous graphs, a dictionary mapping edge type tuples (source_type, relation_type, target_type) to GeoDataFrames. Edge relationships are defined by a MultiIndex on the edge GeoDataFrame (source ID, target ID). For MultiGraphs, a third level in the index can be used for edge keys.</p> <code>None</code> <code>keep_geom</code> <code>bool</code> <p>If True, the geometry of the nodes and edges GeoDataFrames will be preserved as attributes in the NetworkX graph.</p> <code>True</code> <code>multigraph</code> <code>bool</code> <p>If True, a <code>networkx.MultiGraph</code> is created, which can store multiple edges between the same two nodes.</p> <code>False</code> <code>directed</code> <code>bool</code> <p>If True, a directed graph (<code>networkx.DiGraph</code> or <code>networkx.MultiDiGraph</code>) is created. Otherwise, an undirected graph is created.</p> <code>False</code> <p>Returns:</p> Type Description <code>Graph or MultiGraph or DiGraph or MultiDiGraph</code> <p>A NetworkX graph object representing the spatial network. Graph-level metadata, such as CRS and heterogeneity information, is stored in <code>graph.graph</code>.</p> See Also <p>nx_to_gdf : Convert a NetworkX graph back to GeoDataFrames.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Homogeneous graph\n&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from shapely.geometry import Point, LineString\n&gt;&gt;&gt; nodes_gdf = gpd.GeoDataFrame(\n...     geometry=[Point(0, 0), Point(1, 1)],\n...     index=pd.Index([10, 20], name=\"node_id\")\n... )\n&gt;&gt;&gt; edges_gdf = gpd.GeoDataFrame(\n...     {\"length\": [1.414]},\n...     geometry=[LineString([(0, 0), (1, 1)])],\n...     index=pd.MultiIndex.from_tuples([(10, 20)], names=[\"u\", \"v\"])\n... )\n&gt;&gt;&gt; G = gdf_to_nx(nodes=nodes_gdf, edges=edges_gdf)\n&gt;&gt;&gt; print(G.nodes(data=True))\n&gt;&gt;&gt; [(0, {'geometry': &lt;POINT (0 0)&gt;,\n...       '_original_index': 10,\n...       'pos': (0.0, 0.0)}),\n...  (1, {'geometry': &lt;POINT (1 1)&gt;,\n...       '_original_index': 20,\n...       'pos': (1.0, 1.0)})]\n&gt;&gt;&gt; print(G.edges(data=True))\n&gt;&gt;&gt; [(0, 1, {'length': 1.414,\n...          'geometry': &lt;LINESTRING (0 0, 1 1)&gt;,\n...          '_original_edge_index': (10, 20)})]\n</code></pre> <pre><code>&gt;&gt;&gt; # Heterogeneous graph\n&gt;&gt;&gt; buildings_gdf = gpd.GeoDataFrame(geometry=[Point(0, 0)], index=pd.Index(['b1'], name=\"b_id\"))\n&gt;&gt;&gt; streets_gdf = gpd.GeoDataFrame(geometry=[Point(1, 1)], index=pd.Index(['s1'], name=\"s_id\"))\n&gt;&gt;&gt; connections_gdf = gpd.GeoDataFrame(\n...     geometry=[LineString([(0,0), (1,1)])],\n...     index=pd.MultiIndex.from_tuples([('b1', 's1')])\n... )\n&gt;&gt;&gt; nodes_dict = {\"building\": buildings_gdf, \"street\": streets_gdf}\n&gt;&gt;&gt; edges_dict = {(\"building\", \"connects_to\", \"street\"): connections_gdf}\n&gt;&gt;&gt; H = gdf_to_nx(nodes=nodes_dict, edges=edges_dict)\n&gt;&gt;&gt; print(H.nodes(data=True))\n&gt;&gt;&gt; [(0, {'geometry': &lt;POINT (0 0)&gt;,\n...       'node_type': 'building',\n...       '_original_index': 'b1',\n...       'pos': (0.0, 0.0)}),\n...  (1, {'geometry': &lt;POINT (1 1)&gt;,\n...       'node_type': 'street',\n...       '_original_index': 's1',\n...       'pos': (1.0, 1.0)})]\n&gt;&gt;&gt; print(H.edges(data=True))\n&gt;&gt;&gt; [(0, 1, {'geometry': &lt;LINESTRING (0 0, 1 1)&gt;,\n...          'full_edge_type': ('building', 'connects_to', 'street'),\n...          '_original_edge_index': ('b1', 's1')})]\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.nx_to_gdf","title":"nx_to_gdf","text":"<pre><code>nx_to_gdf(G, nodes=True, edges=True, set_missing_pos_from=('x', 'y'))\n</code></pre> <p>Convert a NetworkX graph to GeoDataFrames for nodes and/or edges.</p> <p>This function reconstructs GeoDataFrames from a NetworkX graph that was created by <code>gdf_to_nx</code> or follows a similar structure. It can handle both homogeneous and heterogeneous graphs, extracting node and edge attributes and reconstructing geometries from position data.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph or MultiGraph</code> <p>The NetworkX graph to convert. It is expected to have metadata stored in <code>G.graph</code> to guide the conversion, including CRS and heterogeneity information. Node positions are expected in a 'pos' attribute.</p> required <code>nodes</code> <code>bool</code> <p>If True, a GeoDataFrame for nodes will be created and returned.</p> <code>True</code> <code>edges</code> <code>bool</code> <p>If True, a GeoDataFrame for edges will be created and returned.</p> <code>True</code> <code>set_missing_pos_from</code> <code>tuple[str, ...] | None</code> <p>If provided (or None implies (\"x\", \"y\")) set missing node 'pos' from the given attribute name(s). With two names use them as x/y; with one name expect a 2-length coordinate.</p> <code>(\"x\", \"y\")</code> <p>Returns:</p> Type Description <code>GeoDataFrame or tuple</code> <p>The reconstructed GeoDataFrames. The return type depends on the graph structure (homogeneous vs heterogeneous) and the requested components (<code>nodes</code>, <code>edges</code>).</p> <p>Homogeneous Graphs:</p> <ul> <li>If nodes=True and edges=True: Returns (nodes_gdf, edges_gdf)     where both are geopandas.GeoDataFrame.</li> <li>If only nodes=True: Returns nodes_gdf (geopandas.GeoDataFrame).</li> <li>If only edges=True: Returns edges_gdf (geopandas.GeoDataFrame).</li> </ul> <p>Heterogeneous Graphs:</p> <ul> <li> <p>Returns (nodes_dict, edges_dict) where:</p> <ul> <li>nodes_dict is dict[str, geopandas.GeoDataFrame] mapping node types to GeoDataFrames.</li> <li>edges_dict is dict[tuple[str, str, str], geopandas.GeoDataFrame] mapping edge types to GeoDataFrames.</li> </ul> </li> </ul> <p>Note: For heterogeneous graphs, the return value is always a tuple of dictionaries, even if only one component is requested (the other will be an empty dict).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>nodes</code> and <code>edges</code> are False.</p> See Also <p>gdf_to_nx : Convert GeoDataFrames to a NetworkX graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; # Create a simple graph with spatial attributes\n&gt;&gt;&gt; G = nx.Graph(is_hetero=False, crs=\"EPSG:4326\")\n&gt;&gt;&gt; G.add_node(0, pos=(0, 0), population=100, geometry=Point(0,0))\n&gt;&gt;&gt; G.add_node(1, pos=(1, 1), population=200, geometry=Point(1,1))\n&gt;&gt;&gt; G.add_edge(0, 1, weight=1.5, geometry=LineString([(0, 0), (1, 1)]))\n&gt;&gt;&gt; # Convert back to GeoDataFrames\n&gt;&gt;&gt; nodes_gdf, edges_gdf = nx_to_gdf(G)\n&gt;&gt;&gt; print(nodes_gdf)\n&gt;&gt;&gt; print(edges_gdf)\n&gt;&gt;&gt;           population     geometry\n... 0         100           POINT (0 0)\n... 1         200           POINT (1 1)\n...           weight        geometry\n... 0 1       1.5           LINESTRING (0 0, 1 1)\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.nx_to_rx","title":"nx_to_rx","text":"<pre><code>nx_to_rx(graph)\n</code></pre> <p>Convert a NetworkX graph to a rustworkx graph.</p> <p>This function converts a NetworkX graph object into a rustworkx graph object, preserving node, edge, and graph attributes. It handles both directed and undirected graphs, as well as multigraphs.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or MultiGraph</code> <p>The NetworkX graph to convert.</p> required <p>Returns:</p> Type Description <code>PyGraph or PyDiGraph</code> <p>The converted rustworkx graph.</p> See Also <p>rx_to_nx : Convert a rustworkx graph back to NetworkX.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rx_G = nx_to_rx(G)\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.rx_to_nx","title":"rx_to_nx","text":"<pre><code>rx_to_nx(graph)\n</code></pre> <p>Convert a rustworkx graph to a NetworkX graph.</p> <p>This function converts a rustworkx graph object into a NetworkX graph object, restoring node, edge, and graph attributes.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>PyGraph or PyDiGraph</code> <p>The rustworkx graph to convert.</p> required <p>Returns:</p> Type Description <code>Graph or MultiGraph</code> <p>The converted NetworkX graph.</p> See Also <p>nx_to_rx : Convert a NetworkX graph to rustworkx.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Assuming rx_G is a rustworkx graph\n&gt;&gt;&gt; nx_G = rx_to_nx(rx_G)\n</code></pre>"},{"location":"api/utils.html#validation-functions","title":"Validation Functions","text":"<p>Core Utilities Module.</p> <p>This module provides essential utilities for graph conversion, data validation, and spatial analysis operations. It serves as the foundation for the city2graph package, offering a standardized data format for handling geospatial relations across GeoPandas, NetworkX objects, and eventually PyTorch Geometric objects. The module enables seamless integration between different graph representations and geospatial data formats through robust data structures and conversion functions.</p> <p>Functions:</p> Name Description <code>validate_gdf</code> <p>Validate node and edge GeoDataFrames with type detection.</p> <code>validate_nx</code> <p>Validate a NetworkX graph with comprehensive type checking.</p>"},{"location":"api/utils.html#city2graph.utils.validate_gdf","title":"validate_gdf","text":"<pre><code>validate_gdf(nodes_gdf=None, edges_gdf=None, allow_empty=True)\n</code></pre> <p>Validate node and edge GeoDataFrames with type detection.</p> <p>This function validates both homogeneous and heterogeneous GeoDataFrame inputs, performs type checking, and determines whether the input represents a heterogeneous graph structure.</p> <p>Parameters:</p> Name Type Description Default <code>nodes_gdf</code> <code>GeoDataFrame or dict[str, GeoDataFrame]</code> <p>The GeoDataFrame containing node data to validate, or a dictionary mapping node type names to GeoDataFrames for heterogeneous graphs.</p> <code>None</code> <code>edges_gdf</code> <code>GeoDataFrame or dict[tuple[str, str, str], GeoDataFrame]</code> <p>The GeoDataFrame containing edge data to validate, or a dictionary mapping edge type tuples to GeoDataFrames for heterogeneous graphs.</p> <code>None</code> <code>allow_empty</code> <code>bool</code> <p>If True, allows the GeoDataFrames to be empty. If False, raises an error.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:</p> <ul> <li>validated nodes_gdf (same type as input)</li> <li>validated edges_gdf (same type as input)</li> <li>is_hetero: boolean indicating if this is a heterogeneous graph</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If an input is not a GeoDataFrame or appropriate dictionary type.</p> <code>ValueError</code> <p>If the input types are inconsistent or invalid.</p> See Also <p>validate_nx : Validate a NetworkX graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from shapely.geometry import Point, LineString\n&gt;&gt;&gt; nodes = gpd.GeoDataFrame(geometry=[Point(0, 0)])\n&gt;&gt;&gt; edges = gpd.GeoDataFrame(geometry=[LineString([(0, 0), (1, 1)])])\n&gt;&gt;&gt; try:\n...     validated_nodes, validated_edges, is_hetero = validate_gdf(nodes, edges)\n...     print(f\"Validation successful. Heterogeneous: {is_hetero}\")\n... except (TypeError, ValueError) as e:\n...     print(f\"Validation failed: {e}\")\nValidation successful. Heterogeneous: False\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.validate_nx","title":"validate_nx","text":"<pre><code>validate_nx(graph)\n</code></pre> <p>Validate a NetworkX graph with comprehensive type checking.</p> <p>Checks if the input is a NetworkX graph, ensures it is not empty (i.e., it has both nodes and edges), and verifies that it contains the necessary metadata for conversion back to GeoDataFrames or PyG objects.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or MultiGraph</code> <p>The NetworkX graph to validate.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This function does not return a value.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a NetworkX graph.</p> <code>ValueError</code> <p>If the graph has no nodes, no edges, or is missing essential metadata.</p> See Also <p>validate_gdf : Validate GeoDataFrames for graph conversion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; from shapely.geometry import Point\n&gt;&gt;&gt; G = nx.Graph(is_hetero=False, crs=\"EPSG:4326\")\n&gt;&gt;&gt; G.add_node(0, pos=(0, 0))\n&gt;&gt;&gt; G.add_node(1, pos=(1, 1))\n&gt;&gt;&gt; G.add_edge(0, 1)\n&gt;&gt;&gt; try:\n...     validate_nx(G)\n...     print(\"Validation successful.\")\n... except (TypeError, ValueError) as e:\n...     print(f\"Validation failed: {e}\")\nValidation successful.\n</code></pre>"},{"location":"api/utils.html#graph-operations","title":"Graph Operations","text":"<p>Core Utilities Module.</p> <p>This module provides essential utilities for graph conversion, data validation, and spatial analysis operations. It serves as the foundation for the city2graph package, offering a standardized data format for handling geospatial relations across GeoPandas, NetworkX objects, and eventually PyTorch Geometric objects. The module enables seamless integration between different graph representations and geospatial data formats through robust data structures and conversion functions.</p> <p>Functions:</p> Name Description <code>dual_graph</code> <p>Convert a primal graph represented by nodes and edges GeoDataFrames to its dual graph.</p> <code>filter_graph_by_distance</code> <p>Filter a graph to include only elements within a specified threshold from a center point.</p>"},{"location":"api/utils.html#city2graph.utils.dual_graph","title":"dual_graph","text":"<pre><code>dual_graph(\n    graph,\n    edge_id_col=None,\n    keep_original_geom=False,\n    source_col=None,\n    target_col=None,\n    as_nx=False,\n)\n</code></pre> <p>Convert a primal graph represented by nodes and edges GeoDataFrames to its dual graph.</p> <p>In the dual graph, original edges become nodes and original nodes become edges connecting adjacent original edges.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>tuple[GeoDataFrame, GeoDataFrame] or Graph or MultiGraph</code> <p>A graph containing nodes and edges GeoDataFrames or a NetworkX graph of the primal graph.</p> required <code>edge_id_col</code> <code>str</code> <p>The name of the column in the edges GeoDataFrame to be used as unique identifiers for dual graph nodes. If None, the index of the edges GeoDataFrame is used. Default is None.</p> <code>None</code> <code>keep_original_geom</code> <code>bool</code> <p>If True, preserve the original geometry of the edges in a new column named 'original_geometry' in the dual nodes GeoDataFrame.</p> <code>False</code> <code>source_col</code> <code>str</code> <p>Name of the column or index level representing the source node ID in the edges GeoDataFrame. If provided, it overrides automatic detection.</p> <code>None</code> <code>target_col</code> <code>str</code> <p>Name of the column or index level representing the target node ID in the edges GeoDataFrame. If provided, it overrides automatic detection.</p> <code>None</code> <code>as_nx</code> <code>bool</code> <p>If True, return the dual graph as a NetworkX graph instead of GeoDataFrames.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[GeoDataFrame, GeoDataFrame]</code> <p>A tuple containing the nodes and edges of the dual graph as GeoDataFrames.</p> <ul> <li>Dual nodes GeoDataFrame: Nodes represent original edges. The geometry is the   centroid of the original edge's geometry. The index is derived from <code>edge_id_col</code>   or the original edge index.</li> <li>Dual edges GeoDataFrame: Edges represent adjacency between original edges (i.e.,   they shared a node in the primal graph). The geometry is a LineString connecting   the centroids of the two dual nodes. The index is a MultiIndex of the connected   dual node IDs.</li> </ul> See Also <p>segments_to_graph : Convert LineString segments to a graph structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from shapely.geometry import Point, LineString\n&gt;&gt;&gt; # Primal graph nodes\n&gt;&gt;&gt; nodes = gpd.GeoDataFrame(\n...     {\"node_id\": [0, 1, 2]},\n...     geometry=[Point(0, 0), Point(1, 1), Point(1, 0)],\n...     crs=\"EPSG:32633\"\n... ).set_index(\"node_id\")\n&gt;&gt;&gt; # Primal graph edges\n&gt;&gt;&gt; edges = gpd.GeoDataFrame(\n...     {\"u\": [0, 1], \"v\": [1, 2]},\n...     geometry=[LineString([(0, 0), (1, 1)]), LineString([(1, 1), (1, 0)])],\n...     crs=\"EPSG:32633\"\n... )\n&gt;&gt;&gt; # Convert to dual graph\n&gt;&gt;&gt; dual_nodes, dual_edges = dual_graph((nodes, edges))\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.filter_graph_by_distance","title":"filter_graph_by_distance","text":"<pre><code>filter_graph_by_distance(\n    graph, center_point, threshold, edge_attr=\"length\", node_id_col=None\n)\n</code></pre> <p>Filter a graph to include only elements within a specified threshold from a center point.</p> <p>This function calculates the shortest path from a center point to all nodes in the graph and returns a subgraph containing only the nodes (and their induced edges) that are within the given threshold. The input can be a NetworkX graph or an edges GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>GeoDataFrame or Graph or MultiGraph</code> <p>The graph to filter. If a GeoDataFrame, it represents the edges of the graph and will be converted to a NetworkX graph internally.</p> required <code>center_point</code> <code>Point or GeoSeries or GeoDataFrame</code> <p>The origin point(s) for the distance calculation. If multiple points are provided, the filter will include nodes reachable from any of them.</p> required <code>threshold</code> <code>float</code> <p>The maximum shortest-path distance (or cost) for a node to be included in the filtered graph.</p> required <code>edge_attr</code> <code>str</code> <p>The name of the edge attribute to use as weight for shortest path calculations (e.g., 'length', 'travel_time').</p> <code>\"length\"</code> <code>node_id_col</code> <code>str</code> <p>The name of the node identifier column if the input graph is a GeoDataFrame. Defaults to the index.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame or Graph or MultiGraph</code> <p>The filtered subgraph. The return type matches the input <code>graph</code> type. If the input was a GeoDataFrame, the output is a GeoDataFrame of the filtered edges.</p> See Also <p>create_isochrone : Generate an isochrone polygon from a graph.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; from shapely.geometry import Point\n&gt;&gt;&gt; # Create a graph\n&gt;&gt;&gt; G = nx.Graph()\n&gt;&gt;&gt; G.add_node(0, pos=(0, 0))\n&gt;&gt;&gt; G.add_node(1, pos=(10, 0))\n&gt;&gt;&gt; G.add_node(2, pos=(20, 0))\n&gt;&gt;&gt; G.add_edge(0, 1, length=10)\n&gt;&gt;&gt; G.add_edge(1, 2, length=10)\n&gt;&gt;&gt; # Filter the graph\n&gt;&gt;&gt; center = Point(1, 0)\n&gt;&gt;&gt; filtered_graph = filter_graph_by_distance(G, center, threshold=12)\n&gt;&gt;&gt; print(list(filtered_graph.nodes))\n&gt;&gt;&gt; [0, 1]\n</code></pre>"},{"location":"api/utils.html#spatial-operations","title":"Spatial Operations","text":"<p>Core Utilities Module.</p> <p>This module provides essential utilities for graph conversion, data validation, and spatial analysis operations. It serves as the foundation for the city2graph package, offering a standardized data format for handling geospatial relations across GeoPandas, NetworkX objects, and eventually PyTorch Geometric objects. The module enables seamless integration between different graph representations and geospatial data formats through robust data structures and conversion functions.</p> <p>Functions:</p> Name Description <code>create_tessellation</code> <p>Create tessellations from given geometries, with optional barriers.</p> <code>create_isochrone</code> <p>Generate an isochrone polygon from a graph.</p>"},{"location":"api/utils.html#city2graph.utils.create_tessellation","title":"create_tessellation","text":"<pre><code>create_tessellation(\n    geometry,\n    primary_barriers=None,\n    shrink=0.4,\n    segment=0.5,\n    threshold=0.05,\n    n_jobs=-1,\n    **kwargs\n)\n</code></pre> <p>Create tessellations from given geometries, with optional barriers.</p> <p>This function generates either morphological or enclosed tessellations based on the input geometries. If <code>primary_barriers</code> are provided, it creates an enclosed tessellation; otherwise, it generates a morphological tessellation.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>GeoDataFrame or GeoSeries</code> <p>The geometries (typically building footprints) to tessellate around.</p> required <code>primary_barriers</code> <code>GeoDataFrame or GeoSeries</code> <p>Geometries (typically road network) to use as barriers for enclosed tessellation. If provided, <code>momepy.enclosed_tessellation</code> is used. Default is None.</p> <code>None</code> <code>shrink</code> <code>float</code> <p>The distance to shrink the geometry for the skeleton endpoint generation. Passed to <code>momepy.morphological_tessellation</code> or <code>momepy.enclosed_tessellation</code>.</p> <code>0.4</code> <code>segment</code> <code>float</code> <p>The segment length for discretizing the geometry. Passed to <code>momepy.morphological_tessellation</code> or <code>momepy.enclosed_tessellation</code>.</p> <code>0.5</code> <code>threshold</code> <code>float</code> <p>The threshold for snapping skeleton endpoints to the boundary. Only used for enclosed tessellation.</p> <code>0.05</code> <code>n_jobs</code> <code>int</code> <p>The number of jobs to use for parallel processing. -1 means using all available processors. Only used for enclosed tessellation.</p> <code>-1</code> <code>**kwargs</code> <code>object</code> <p>Additional keyword arguments passed to the underlying <code>momepy</code> tessellation function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing the tessellation cells as polygons. Each cell has a unique <code>tess_id</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>primary_barriers</code> are not provided and the geometry is in a geographic CRS (e.g., EPSG:4326), as morphological tessellation requires a projected CRS.</p> See Also <p>momepy.morphological_tessellation : Generate morphological tessellation. momepy.enclosed_tessellation : Generate enclosed tessellation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; # Create some building footprints\n&gt;&gt;&gt; buildings = gpd.GeoDataFrame(\n...     geometry=[Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]),\n...               Polygon([(2, 2), (3, 2), (3, 3), (2, 3)])],\n...     crs=\"EPSG:32633\"\n... )\n&gt;&gt;&gt; # Generate morphological tessellation\n&gt;&gt;&gt; tessellation = create_tessellation(buildings)\n&gt;&gt;&gt; print(tessellation.head())\n</code></pre> <pre><code>&gt;&gt;&gt; # Generate enclosed tessellation with roads as barriers\n&gt;&gt;&gt; from shapely.geometry import LineString\n&gt;&gt;&gt; roads = gpd.GeoDataFrame(\n...     geometry=[LineString([(0, -1), (3, -1)]), LineString([(1.5, -1), (1.5, 4)])],\n...     crs=\"EPSG:32633\"\n... )\n&gt;&gt;&gt; enclosed_tess = create_tessellation(buildings, primary_barriers=roads)\n&gt;&gt;&gt; print(enclosed_tess.head())\n</code></pre>"},{"location":"api/utils.html#city2graph.utils.create_isochrone","title":"create_isochrone","text":"<pre><code>create_isochrone(\n    graph=None,\n    nodes=None,\n    edges=None,\n    center_point=None,\n    threshold=None,\n    edge_attr=None,\n    cut_edge_types=None,\n    method=\"concave_hull_knn\",\n    **kwargs\n)\n</code></pre> <p>Generate an isochrone polygon from a graph.</p> <p>An isochrone represents the area reachable from a center point within a given travel threshold (distance or time). This function computes the set of reachable edges and nodes in a network and generates a polygon that encloses this reachable area.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or MultiGraph</code> <p>The network graph.</p> <code>None</code> <code>nodes</code> <code>GeoDataFrame or dict</code> <p>Nodes of the graph.</p> <code>None</code> <code>edges</code> <code>GeoDataFrame or dict</code> <p>Edges of the graph.</p> <code>None</code> <code>center_point</code> <code>Point or GeoSeries or GeoDataFrame</code> <p>The origin point(s) for the isochrone calculation.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum travel distance (or time) that defines the boundary of the isochrone.</p> <code>None</code> <code>edge_attr</code> <code>str</code> <p>The edge attribute to use for distance calculation (e.g., 'length', 'travel_time'). If None, the function will use the default edge attribute.</p> <code>\"travel_time\"</code> <code>cut_edge_types</code> <code>list[tuple[str, str, str]] | None</code> <p>List of edge types to remove from the graph before processing (e.g., [(\"bus_stop\", \"is_next_to\", \"bus_stop\")]).</p> <code>None</code> <code>method</code> <code>str</code> <p>The method to generate the isochrone polygon. Options are:</p> <ul> <li>\"concave_hull_knn\": Creates a concave hull (k-NN) around reachable nodes.</li> <li>\"concave_hull_alpha\": Creates a concave hull (alpha shape) around reachable nodes.</li> <li>\"convex_hull\": Creates a convex hull around reachable nodes.</li> <li>\"buffer\": Creates a buffer around reachable edges/nodes.</li> </ul> <code>\"concave_hull_knn\"</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for specific isochrone generation methods:</p> <p>For method=\"concave_hull_knn\":     k : int, default 100         The number of nearest neighbors to consider.</p> <p>For method=\"concave_hull_alpha\":     hull_ratio : float, default 0.3         The ratio for concave hull generation (0.0 to 1.0). Higher values mean tighter fit.     allow_holes : bool, default False         Whether to allow holes in the concave hull.</p> <p>For method=\"buffer\":     buffer_distance : float, default 100         The distance to buffer reachable geometries.     cap_style : int, default 1         The cap style for buffering. 1=Round, 2=Flat, 3=Square.     join_style : int, default 1         The join style for buffering. 1=Round, 2=Mitre, 3=Bevel.     resolution : int, default 16         The resolution of the buffer (number of segments per quarter circle).</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame containing a single Polygon or MultiPolygon geometry that represents the isochrone.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required inputs are missing or invalid.</p>"},{"location":"api/utils.html#visualization","title":"Visualization","text":"<p>Core Utilities Module.</p> <p>This module provides essential utilities for graph conversion, data validation, and spatial analysis operations. It serves as the foundation for the city2graph package, offering a standardized data format for handling geospatial relations across GeoPandas, NetworkX objects, and eventually PyTorch Geometric objects. The module enables seamless integration between different graph representations and geospatial data formats through robust data structures and conversion functions.</p> <p>Functions:</p> Name Description <code>plot_graph</code> <p>Plot a graph with a unified interface.</p>"},{"location":"api/utils.html#city2graph.utils.plot_graph","title":"plot_graph","text":"<pre><code>plot_graph(\n    graph=None,\n    nodes=None,\n    edges=None,\n    ax=None,\n    bgcolor=\"#000000\",\n    figsize=(12, 12),\n    subplots=True,\n    ncols=None,\n    legend_position=\"upper left\",\n    labelcolor=\"white\",\n    title_color=None,\n    node_color=None,\n    node_alpha=None,\n    node_zorder=None,\n    node_edgecolor=None,\n    markersize=None,\n    edge_color=None,\n    edge_linewidth=None,\n    edge_alpha=None,\n    edge_zorder=None,\n    **kwargs\n)\n</code></pre> <p>Plot a graph with a unified interface.</p> <p>This function provides a unified interface for plotting spatial network data, supporting both GeoDataFrame-based and NetworkX-based inputs. NetworkX graphs are automatically converted to GeoDataFrames before plotting. It can handle homogeneous and heterogeneous graphs with customizable styling.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>Graph or MultiGraph</code> <p>The NetworkX graph to plot. If provided without nodes/edges, the function will convert it to GeoDataFrames before plotting.</p> <code>None</code> <code>nodes</code> <code>GeoDataFrame or dict[str, GeoDataFrame]</code> <p>Nodes to plot. Can be a single GeoDataFrame (homogeneous) or a dictionary mapping node type names to GeoDataFrames (heterogeneous).</p> <code>None</code> <code>edges</code> <code>GeoDataFrame or dict[tuple[str, str, str], GeoDataFrame]</code> <p>Edges to plot. Can be a single GeoDataFrame (homogeneous) or a dictionary mapping edge type tuples (src_type, rel_type, dst_type) to GeoDataFrames (heterogeneous).</p> <code>None</code> <code>ax</code> <code>Axes or ndarray</code> <p>The axes on which to plot. If None, a new figure and axes are created.</p> <code>None</code> <code>bgcolor</code> <code>str</code> <p>Background color for the plot (Black theme).</p> <code>\"#000000\"</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as (width, height) in inches.</p> <code>(12, 12)</code> <code>subplots</code> <code>bool</code> <p>If True and the graph is heterogeneous, plot each node/edge type in a separate subplot. Uses 'ax' as array of subplots if provided.</p> <code>True</code> <code>ncols</code> <code>int</code> <p>Number of columns (subplots per row) when plotting heterogeneous graphs with subplots=True. If None, defaults to min(3, number_of_edge_types).</p> <code>None</code> <code>legend_position</code> <code>str or None</code> <p>Position of the legend for heterogeneous graphs. Common values include \"upper left\", \"upper right\", \"lower left\", \"lower right\", \"center\", etc. If None, no legend is displayed.</p> <code>\"upper left\"</code> <code>labelcolor</code> <code>str</code> <p>Color of the legend text labels.</p> <code>\"white\"</code> <code>title_color</code> <code>str</code> <p>Color for subplot titles when <code>subplots=True</code>. Falls back to a white title on black backgrounds if not provided.</p> <code>None</code> <code>node_color</code> <code>str, float, pd.Series, or dict</code> <p>Color for nodes. Can be a scalar, column name, Series, or a dictionary mapping node types to colors for heterogeneous graphs.</p> <code>None</code> <code>node_alpha</code> <code>float, pd.Series, or dict</code> <p>Transparency for nodes (0.0-1.0). Can be a scalar, column name, Series, or a dictionary mapping node types to transparency values.</p> <code>None</code> <code>node_zorder</code> <code>int, pd.Series, or dict</code> <p>Drawing order for nodes. Can be a scalar, column name, Series, or a dictionary mapping node types to zorder values.</p> <code>None</code> <code>node_edgecolor</code> <code>str, pd.Series, or dict</code> <p>Color for node borders. Can be a scalar, column name, Series, or a dictionary mapping node types to edge colors.</p> <code>None</code> <code>markersize</code> <code>float, pd.Series, or dict</code> <p>Size of the node markers. Can be a scalar, column name, Series, or a dictionary mapping node types to marker sizes.</p> <code>None</code> <code>edge_color</code> <code>str, float, pd.Series, or dict</code> <p>Color for edges. Can be a scalar, column name, Series, or a dictionary mapping edge types to colors for heterogeneous graphs.</p> <code>None</code> <code>edge_linewidth</code> <code>float, pd.Series, or dict</code> <p>Line width for edges. Can be a scalar, column name, Series, or a dictionary mapping edge types to line widths.</p> <code>None</code> <code>edge_alpha</code> <code>float, pd.Series, or dict</code> <p>Transparency for edges (0.0-1.0). Can be a scalar, column name, Series, or a dictionary mapping edge types to transparency values.</p> <code>None</code> <code>edge_zorder</code> <code>int, pd.Series, or dict</code> <p>Drawing order for edges. Can be a scalar, column name, Series, or a dictionary mapping edge types to zorder values.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the GeoPandas plotting functions.</p> <p>Supports attribute-based styling where parameters can be specified as:</p> <ul> <li>Scalar values (str/float): Applied uniformly to all geometries</li> <li>Column names (str): If the string matches a column in the GeoDataFrame,   that column's values are used for styling</li> <li>pd.Series: Direct values for each geometry</li> </ul> <p>Other common options: etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes or ndarray or None</code> <p>The axes object(s) used for plotting.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If matplotlib is not installed.</p> <code>ValueError</code> <p>If no valid input is provided (all parameters are None).</p> <code>TypeError</code> <p>If the input data types are not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import geopandas as gpd\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import networkx as nx\n&gt;&gt;&gt; # Plot from NetworkX graph (automatically converted to GeoDataFrames)\n&gt;&gt;&gt; G = nx.Graph()\n&gt;&gt;&gt; G.add_node(0, pos=(0, 0))\n&gt;&gt;&gt; G.add_edge(0, 1)\n&gt;&gt;&gt; plot_graph(graph=G)\n&gt;&gt;&gt; # Plot from GeoDataFrames with scalar styling\n&gt;&gt;&gt; plot_graph(nodes=nodes_gdf, edges=edges_gdf, node_color='red')\n&gt;&gt;&gt; # Plot with attribute-based node colors (by column name)\n&gt;&gt;&gt; plot_graph(nodes=nodes_gdf, edges=edges_gdf, node_color='building_type')\n&gt;&gt;&gt; # Plot with pd.Series for edge linewidth\n&gt;&gt;&gt; edge_widths = pd.Series([1.0, 2.0, 1.5], index=edges_gdf.index)\n&gt;&gt;&gt; plot_graph(nodes=nodes_gdf, edges=edges_gdf, edge_linewidth=edge_widths)\n&gt;&gt;&gt; # Plot heterogeneous graph\n&gt;&gt;&gt; plot_graph(nodes=nodes_dict, edges=edges_dict)\n</code></pre>"},{"location":"examples/index.html","title":"Examples","text":"<p>This section provides examples of how to use City2Graph in various urban analysis scenarios.</p> <ul> <li>Metapaths</li> <li>Generating Graphs by Proximity</li> <li>Generating Graphs from OD Matrix</li> <li>GTFS</li> <li>Morphological Graph from OvertureMaps</li> </ul>"},{"location":"examples/add_metapaths.html","title":"Metapaths","text":"<p>This notebook demonstrates how to construct a metapath on a heterogeneous graph using <code>City2Graph</code>.</p> <p>A metapath defines a composite relation between nodes in a heterogeneous graph, widely used in Graph Neural Networks (GNN).</p> <p>For example, <code>Amenity -&gt; Segment -&gt; Segment -&gt; Amenity</code> connects two amenities if they are accessible via a short walk (two street segments).</p> <p>We will:</p> <ol> <li>Fetch Data: Get the street network and amenities for Soho, London using <code>osmnx</code> (OpenStreetMap).</li> <li>Construct Graph: Create a dual graph of the streets using <code>NetworkX</code> concepts.</li> <li>Bridge Nodes: Connect amenities to the street network using spatial joins with <code>GeoPandas</code>.</li> <li>Add Metapaths: Materialize the <code>Amenity-Segment-Segment-Amenity</code> relationship to densify the graph.</li> <li>Visualization: Visualize the metapaths with an animation.</li> <li>Add Metapaths by Weight: Connect amenities based on travel distance for weighted graph analysis.</li> </ol> In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport osmnx as ox\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\nfrom matplotlib.animation import FuncAnimation\nimport city2graph as c2g\n</pre> import geopandas as gpd import osmnx as ox import pandas as pd import matplotlib.pyplot as plt from matplotlib.lines import Line2D from matplotlib.animation import FuncAnimation import city2graph as c2g <p>A metapath is a sequence of relations between node types in a heterogeneous graph. It describes a composite relationship between two nodes and is fundamental for capturing semantic information in Graph Neural Networks (GNN).</p> <p>For example, in our city graph:</p> <ol> <li>Amenity (e.g., a Cafe) is connected to a Street Segment (is_nearby).</li> <li>Street Segment is connected to another Street Segment (connects_to).</li> <li>Street Segment is connected to another Amenity (is_nearby).</li> </ol> <p>This forms the metapath <code>Amenity -&gt; Segment -&gt; Segment -&gt; Amenity</code>, representing that two amenities are within a short walking distance (2 segments) of each other. This structure allows GNNs to learn embeddings based on connectivity patterns.</p> <p></p> In\u00a0[2]: Copied! <pre># Download and project the street network to British National Grid (EPSG:27700) for metric distances\n# Data should be obtained from Only in Soho, London\nG = ox.graph_from_place(\n    \"Soho, London\",\n    network_type=\"all\",\n)\n\nstreet_primary_nodes, street_primary_edges = c2g.nx_to_gdf(G)\nstreet_primary_nodes = street_primary_nodes.to_crs(epsg=27700)\nstreet_primary_edges = street_primary_edges.to_crs(epsg=27700)\n\namenity_tags = [\"cafe\", \"restaurant\", \"pub\", \"bar\", \"museum\", \"theatre\", \"cinema\"]\namenity_candidates = ox.features_from_place(\n    \"Soho, London\",\n    tags={\"amenity\": amenity_tags},\n).to_crs(epsg=27700)\n</pre> # Download and project the street network to British National Grid (EPSG:27700) for metric distances # Data should be obtained from Only in Soho, London G = ox.graph_from_place(     \"Soho, London\",     network_type=\"all\", )  street_primary_nodes, street_primary_edges = c2g.nx_to_gdf(G) street_primary_nodes = street_primary_nodes.to_crs(epsg=27700) street_primary_edges = street_primary_edges.to_crs(epsg=27700)  amenity_tags = [\"cafe\", \"restaurant\", \"pub\", \"bar\", \"museum\", \"theatre\", \"cinema\"] amenity_candidates = ox.features_from_place(     \"Soho, London\",     tags={\"amenity\": amenity_tags}, ).to_crs(epsg=27700) <p>For the analysis, we clean up the amenities.</p> In\u00a0[3]: Copied! <pre># Collapse complex Amenity geometries to points within the projected CRS\namenities = (\n    amenity_candidates[[\"name\", \"amenity\", \"geometry\"]]\n    .copy()\n    .explode(index_parts=False)\n    .dropna(subset=[\"geometry\"])\n)\nnon_point_mask = ~amenities.geometry.geom_type.isin([\"Point\"])\namenities.loc[non_point_mask, \"geometry\"] = amenities.loc[non_point_mask, \"geometry\"].centroid\namenities = amenities.set_geometry(\"geometry\")\namenities[\"name\"] = amenities[\"name\"].fillna(amenities[\"amenity\"].str.title())\namenities = amenities[~amenities.geometry.is_empty]\namenities = amenities.drop_duplicates(subset=\"geometry\").reset_index(drop=True)\n</pre> # Collapse complex Amenity geometries to points within the projected CRS amenities = (     amenity_candidates[[\"name\", \"amenity\", \"geometry\"]]     .copy()     .explode(index_parts=False)     .dropna(subset=[\"geometry\"]) ) non_point_mask = ~amenities.geometry.geom_type.isin([\"Point\"]) amenities.loc[non_point_mask, \"geometry\"] = amenities.loc[non_point_mask, \"geometry\"].centroid amenities = amenities.set_geometry(\"geometry\") amenities[\"name\"] = amenities[\"name\"].fillna(amenities[\"amenity\"].str.title()) amenities = amenities[~amenities.geometry.is_empty] amenities = amenities.drop_duplicates(subset=\"geometry\").reset_index(drop=True) In\u00a0[4]: Copied! <pre># Display street network data\nprint(\"Street Primary Nodes:\")\ndisplay(street_primary_nodes.head(3))\nprint(\"\\nStreet Primary Edges:\")\ndisplay(street_primary_edges.head(3))\nprint(\"\\nAmenities:\")\ndisplay(amenities.head(3))\n</pre> # Display street network data print(\"Street Primary Nodes:\") display(street_primary_nodes.head(3)) print(\"\\nStreet Primary Edges:\") display(street_primary_edges.head(3)) print(\"\\nAmenities:\") display(amenities.head(3)) <pre>Street Primary Nodes:\n</pre> y x street_count geometry highway railway ref 107324 51.515651 -0.132443 4 POINT (529683.159 181289.359) NaN NaN NaN 107326 51.515148 -0.132727 4 POINT (529664.875 181232.921) NaN NaN NaN 107328 51.514837 -0.132323 3 POINT (529693.803 181199.041) NaN NaN NaN <pre>\nStreet Primary Edges:\n</pre> osmid highway maxspeed name oneway reversed length geometry lanes access width tunnel service 107324 12437701118 0 59207650 residential 20 mph Soho Street False False 8.366709 LINESTRING (529683.159 181289.359, 529679.695 ... NaN NaN NaN NaN NaN 11310505522 0 395757466 footway NaN NaN False False 6.567612 LINESTRING (529683.159 181289.359, 529684.78 1... NaN NaN NaN NaN NaN 1694551556 0 4082521 residential 20 mph Soho Square True False 74.927392 LINESTRING (529683.159 181289.359, 529706.44 1... NaN NaN NaN NaN NaN <pre>\nAmenities:\n</pre> name amenity geometry 0 Curzon Soho cinema POINT (529818.965 180959.788) 1 Pastaio restaurant POINT (529233.765 180972.225) 2 Yauatcha restaurant POINT (529498.558 181064.047) In\u00a0[5]: Copied! <pre>street_dual_nodes, street_dual_edges = c2g.dual_graph((street_primary_nodes, street_primary_edges))\n\nstreet_dual_nodes.geometry = street_dual_nodes.geometry.centroid\n</pre> street_dual_nodes, street_dual_edges = c2g.dual_graph((street_primary_nodes, street_primary_edges))  street_dual_nodes.geometry = street_dual_nodes.geometry.centroid In\u00a0[6]: Copied! <pre># Display dual graph data\nprint(\"Street Dual Nodes (Segments):\")\ndisplay(street_dual_nodes.head(3))\nprint(\"\\nStreet Dual Edges (Connections):\")\ndisplay(street_dual_edges.head(3))\n</pre> # Display dual graph data print(\"Street Dual Nodes (Segments):\") display(street_dual_nodes.head(3)) print(\"\\nStreet Dual Edges (Connections):\") display(street_dual_edges.head(3)) <pre>Street Dual Nodes (Segments):\n</pre> osmid highway maxspeed name oneway reversed length geometry lanes access width tunnel service 107324 12437701118 0 59207650 residential 20 mph Soho Street False False 8.366709 POINT (529681.427 181293.171) NaN NaN NaN NaN NaN 11310505522 0 395757466 footway NaN NaN False False 6.567612 POINT (529683.97 181286.175) NaN NaN NaN NaN NaN 1694551556 0 4082521 residential 20 mph Soho Square True False 74.927392 POINT (529714.059 181289.894) NaN NaN NaN NaN NaN <pre>\nStreet Dual Edges (Connections):\n</pre> geometry from_edge_id to_edge_id (10693880886, 10693880887, 0) (10693880886, 11815774945, 0) LINESTRING (529790.105 181134.445, 529782.217 ... (10693880886, 12437444593, 0) LINESTRING (529790.105 181134.445, 529809.944 ... (10693880887, 10693880886, 0) LINESTRING (529790.105 181134.445, 529790.105 ... In\u00a0[7]: Copied! <pre>c2g.plot_graph(nodes=street_primary_nodes, \n               edges=street_primary_edges)\n</pre> c2g.plot_graph(nodes=street_primary_nodes,                 edges=street_primary_edges) In\u00a0[8]: Copied! <pre>c2g.plot_graph(nodes=street_dual_nodes, \n               edges=street_dual_edges)\n</pre> c2g.plot_graph(nodes=street_dual_nodes,                 edges=street_dual_edges) In\u00a0[9]: Copied! <pre>nodes_dict = {\n    \"amenity\": amenities,\n    \"segment\": street_dual_nodes\n}\n\nedges_dict = {\n    (\"segment\", \"connects_to\", \"segment\"): street_dual_edges\n}\n\n# Connect amenities to segments\n# bridge_nodes returns the node dictionary and a new dictionary of proximity edges\n_, bridged_edges = c2g.bridge_nodes(\n    nodes_dict=nodes_dict,\n    proximity_method=\"knn\",\n    source_node_types=[\"amenity\"],\n    target_node_types=[\"segment\"],\n    k=1  # Connect to the single nearest segment\n)\n\n# Add the street network edges to the edges dictionary\nedges_dict.update(bridged_edges)\n</pre> nodes_dict = {     \"amenity\": amenities,     \"segment\": street_dual_nodes }  edges_dict = {     (\"segment\", \"connects_to\", \"segment\"): street_dual_edges }  # Connect amenities to segments # bridge_nodes returns the node dictionary and a new dictionary of proximity edges _, bridged_edges = c2g.bridge_nodes(     nodes_dict=nodes_dict,     proximity_method=\"knn\",     source_node_types=[\"amenity\"],     target_node_types=[\"segment\"],     k=1  # Connect to the single nearest segment )  # Add the street network edges to the edges dictionary edges_dict.update(bridged_edges) In\u00a0[10]: Copied! <pre>bridged_edges.keys()\n</pre> bridged_edges.keys() Out[10]: <pre>dict_keys([('amenity', 'is_nearby', 'segment')])</pre> In\u00a0[11]: Copied! <pre>bridged_edges[('amenity', 'is_nearby', 'segment')].head(3)\n</pre> bridged_edges[('amenity', 'is_nearby', 'segment')].head(3) Out[11]: weight geometry source target 0 (12437452142, 12437452112, 0) 17.075425 LINESTRING (529818.965 180959.788, 529802.062 ... 1 (21665930, 25473373, 0) 7.276304 LINESTRING (529233.765 180972.225, 529227.711 ... 2 (11310267304, 11310267309, 0) 6.238117 LINESTRING (529498.558 181064.047, 529492.905 ... In\u00a0[12]: Copied! <pre># Define sequence for 1 to 10 street hops\nsequence = []\nhops = 3\n# Start: Amenity -&gt; Segment\nsequence = [(\"amenity\", \"is_nearby\", \"segment\")]\n\n# Middle: Segment -&gt; Segment (i times)\nfor _ in range(hops):\n    sequence.append((\"segment\", \"connects_to\", \"segment\"))\n\n# End: Segment -&gt; Amenity\nsequence.append((\"segment\", \"is_nearby\", \"amenity\"))\n\nprint(sequence)\n</pre> # Define sequence for 1 to 10 street hops sequence = [] hops = 3 # Start: Amenity -&gt; Segment sequence = [(\"amenity\", \"is_nearby\", \"segment\")]  # Middle: Segment -&gt; Segment (i times) for _ in range(hops):     sequence.append((\"segment\", \"connects_to\", \"segment\"))  # End: Segment -&gt; Amenity sequence.append((\"segment\", \"is_nearby\", \"amenity\"))  print(sequence) <pre>[('amenity', 'is_nearby', 'segment'), ('segment', 'connects_to', 'segment'), ('segment', 'connects_to', 'segment'), ('segment', 'connects_to', 'segment'), ('segment', 'is_nearby', 'amenity')]\n</pre> In\u00a0[13]: Copied! <pre># Materialize the metapath edges\nresult_nodes, result_edges = c2g.add_metapaths(nodes=nodes_dict,\n                                               edges=edges_dict,\n                                               sequence=sequence,\n                                               new_relation_name=\"is_3_hop_nearby\")\n</pre> # Materialize the metapath edges result_nodes, result_edges = c2g.add_metapaths(nodes=nodes_dict,                                                edges=edges_dict,                                                sequence=sequence,                                                new_relation_name=\"is_3_hop_nearby\") In\u00a0[14]: Copied! <pre>for key in result_nodes.keys():\n    print(key)\n</pre> for key in result_nodes.keys():     print(key) <pre>amenity\nsegment\n</pre> In\u00a0[15]: Copied! <pre>for key in result_edges.keys():\n    print(key)\n</pre> for key in result_edges.keys():     print(key) <pre>('segment', 'connects_to', 'segment')\n('amenity', 'is_nearby', 'segment')\n('amenity', 'is_3_hop_nearby', 'amenity')\n</pre> In\u00a0[16]: Copied! <pre>print(result_edges[('amenity', 'is_3_hop_nearby', 'amenity')].head(3))\n</pre> print(result_edges[('amenity', 'is_3_hop_nearby', 'amenity')].head(3)) <pre>               weight                                           geometry\nsource source                                                           \n1      305          1  LINESTRING (529233.765 180972.225, 529228.454 ...\n       161          1  LINESTRING (529233.765 180972.225, 529277.738 ...\n       417          7  LINESTRING (529233.765 180972.225, 529245.603 ...\n</pre> In\u00a0[17]: Copied! <pre># Visualize the graph with metapaths\n# We want to highlight the metapath connections\n# Plot\nc2g.plot_graph(\n    nodes=result_nodes,\n    edges=result_edges,\n    node_color={\n        \"amenity\": \"red\",\n        \"segment\": \"gray\"\n    },\n    node_zorder={\n        \"amenity\": 3,\n        \"segment\": 1\n    },\n    node_alpha={\n        \"amenity\": 1.0,\n        \"segment\": 0.5\n    },\n    markersize={\n        \"amenity\": 50,\n        \"segment\": 5\n    },\n    edge_color={\n        (\"segment\", \"connects_to\", \"segment\"): \"gray\",\n        (\"amenity\", \"is_nearby\", \"segment\"): \"gray\",\n        (\"amenity\", \"is_3_hop_nearby\", \"amenity\"): \"cyan\",\n    },\n    edge_zorder={\n        (\"segment\", \"connects_to\", \"segment\"): 3,\n        (\"amenity\", \"is_nearby\", \"segment\"): 1\n    },\n    edge_linewidth={\n        (\"segment\", \"connects_to\", \"segment\"): 0.5,\n        (\"amenity\", \"is_nearby\", \"segment\"): 0.5,\n        (\"amenity\", \"is_3_hop_nearby\", \"amenity\"): 2.0,\n    },\n    bgcolor=\"black\",\n    legend_position=\"lower right\",\n    subplots=False\n)\n</pre> # Visualize the graph with metapaths # We want to highlight the metapath connections # Plot c2g.plot_graph(     nodes=result_nodes,     edges=result_edges,     node_color={         \"amenity\": \"red\",         \"segment\": \"gray\"     },     node_zorder={         \"amenity\": 3,         \"segment\": 1     },     node_alpha={         \"amenity\": 1.0,         \"segment\": 0.5     },     markersize={         \"amenity\": 50,         \"segment\": 5     },     edge_color={         (\"segment\", \"connects_to\", \"segment\"): \"gray\",         (\"amenity\", \"is_nearby\", \"segment\"): \"gray\",         (\"amenity\", \"is_3_hop_nearby\", \"amenity\"): \"cyan\",     },     edge_zorder={         (\"segment\", \"connects_to\", \"segment\"): 3,         (\"amenity\", \"is_nearby\", \"segment\"): 1     },     edge_linewidth={         (\"segment\", \"connects_to\", \"segment\"): 0.5,         (\"amenity\", \"is_nearby\", \"segment\"): 0.5,         (\"amenity\", \"is_3_hop_nearby\", \"amenity\"): 2.0,     },     bgcolor=\"black\",     legend_position=\"lower right\",     subplots=False ) In\u00a0[18]: Copied! <pre>nodes_dict = {\n    \"amenity\": amenities,\n    \"intersection\": street_primary_nodes\n}\n\nedges_dict = {\n    (\"intersection\", \"connects_to\", \"intersection\"): street_primary_edges\n}\n\n_, bridged_edges = c2g.bridge_nodes(\n    nodes_dict=nodes_dict,\n    proximity_method=\"knn\",\n    source_node_types=[\"amenity\"],\n    target_node_types=[\"intersection\"],\n    k=1\n)\n\nedges_dict.update(bridged_edges)\n\n# set travel time in seconds assuming average walking speed of 4 km/h\nwalking_speed_kmh = 4\nwalking_speed_mps = walking_speed_kmh * 1000 / 3600  # convert km/h to m/s\n\n# Add travel time attribute to edges\nfor edge_type, edge_gdf in edges_dict.items():\n    edges_dict[edge_type][\"travel_time_sec\"] = edge_gdf.length / walking_speed_mps\n</pre> nodes_dict = {     \"amenity\": amenities,     \"intersection\": street_primary_nodes }  edges_dict = {     (\"intersection\", \"connects_to\", \"intersection\"): street_primary_edges }  _, bridged_edges = c2g.bridge_nodes(     nodes_dict=nodes_dict,     proximity_method=\"knn\",     source_node_types=[\"amenity\"],     target_node_types=[\"intersection\"],     k=1 )  edges_dict.update(bridged_edges)  # set travel time in seconds assuming average walking speed of 4 km/h walking_speed_kmh = 4 walking_speed_mps = walking_speed_kmh * 1000 / 3600  # convert km/h to m/s  # Add travel time attribute to edges for edge_type, edge_gdf in edges_dict.items():     edges_dict[edge_type][\"travel_time_sec\"] = edge_gdf.length / walking_speed_mps <p>In this case, endpoint is specified as <code>amenity</code>. Between each amenity across the edge types, metapaths are calculated by the threshold <code>60</code> of accumulative weight by <code>travel_time_sec</code>.</p> In\u00a0[19]: Copied! <pre># Connect amenities within 500 meters walking distance\nweight_nodes, weight_edges = c2g.add_metapaths_by_weight(\n    nodes=nodes_dict,\n    edges=edges_dict,\n    weight=\"travel_time_sec\",\n    threshold=60,\n    new_relation_name=\"is_within_1_min\",\n    endpoint_type=\"amenity\",\n    directed=False\n)\n</pre> # Connect amenities within 500 meters walking distance weight_nodes, weight_edges = c2g.add_metapaths_by_weight(     nodes=nodes_dict,     edges=edges_dict,     weight=\"travel_time_sec\",     threshold=60,     new_relation_name=\"is_within_1_min\",     endpoint_type=\"amenity\",     directed=False ) In\u00a0[20]: Copied! <pre>c2g.plot_graph(\n    nodes=weight_nodes,\n    edges=weight_edges,\n    node_color={\n        \"amenity\": \"red\",\n        \"intersection\": \"gray\"\n    },\n    node_zorder={\n        \"amenity\": 3,\n        \"intersection\": 1\n    },\n    node_alpha={\n        \"amenity\": 1.0,\n        \"intersection\": 0.5\n    },\n    markersize={\n        \"amenity\": 50,\n        \"intersection\": 5\n    },\n    edge_color={\n        (\"intersection\", \"connects_to\", \"intersection\"): \"gray\",\n        (\"amenity\", \"is_nearby\", \"intersection\"): \"gray\",\n        (\"amenity\", \"is_within_1_min\", \"amenity\"): \"cyan\"\n    },\n    edge_zorder={\n        (\"intersection\", \"connects_to\", \"intersection\"): 1,\n        (\"amenity\", \"is_nearby\", \"intersection\"): 1,\n        (\"amenity\", \"is_within_1_min\", \"amenity\"): 2\n    },\n    edge_linewidth={\n        (\"intersection\", \"connects_to\", \"intersection\"): 0.5,\n        (\"amenity\", \"is_nearby\", \"intersection\"): 0.5,\n        (\"amenity\", \"is_within_1_min\", \"amenity\"): 2.0\n    },\n    bgcolor=\"black\",\n    title=\"Metapaths by Weight (Travel Time &lt; 1 min)\",\n    legend_position=\"lower right\",\n    subplots=False\n)\n</pre> c2g.plot_graph(     nodes=weight_nodes,     edges=weight_edges,     node_color={         \"amenity\": \"red\",         \"intersection\": \"gray\"     },     node_zorder={         \"amenity\": 3,         \"intersection\": 1     },     node_alpha={         \"amenity\": 1.0,         \"intersection\": 0.5     },     markersize={         \"amenity\": 50,         \"intersection\": 5     },     edge_color={         (\"intersection\", \"connects_to\", \"intersection\"): \"gray\",         (\"amenity\", \"is_nearby\", \"intersection\"): \"gray\",         (\"amenity\", \"is_within_1_min\", \"amenity\"): \"cyan\"     },     edge_zorder={         (\"intersection\", \"connects_to\", \"intersection\"): 1,         (\"amenity\", \"is_nearby\", \"intersection\"): 1,         (\"amenity\", \"is_within_1_min\", \"amenity\"): 2     },     edge_linewidth={         (\"intersection\", \"connects_to\", \"intersection\"): 0.5,         (\"amenity\", \"is_nearby\", \"intersection\"): 0.5,         (\"amenity\", \"is_within_1_min\", \"amenity\"): 2.0     },     bgcolor=\"black\",     title=\"Metapaths by Weight (Travel Time &lt; 1 min)\",     legend_position=\"lower right\",     subplots=False )"},{"location":"examples/add_metapaths.html#building-metapaths-by-osmnx-and-city2graph","title":"Building Metapaths by OSMNx and City2Graph\u00b6","text":""},{"location":"examples/add_metapaths.html#0-what-is-a-metapath-in-heterogeneous-graphs","title":"0. What is a Metapath in Heterogeneous Graphs?\u00b6","text":""},{"location":"examples/add_metapaths.html#1-fetch-data-from-openstreetmap","title":"1. Fetch Data from OpenStreetMap\u00b6","text":"<p>We download the street network and amenities (cafes, pubs, etc.) for Soho, London. This time we use OpenStreetMap via <code>OSMnx</code>. While <code>City2Graph</code> supports a variety of data sources, it has direct compatibility to <code>OSMnx</code> objects (e.g. <code>c2g.nx_to_gdf(), c2g.dual_graph(), c2g.nx_to_pyg()</code> and many others), making it easy to integrate with existing geospatial workflows.</p>"},{"location":"examples/add_metapaths.html#2-construct-dual-graph-for-street-networks","title":"2. Construct Dual Graph for Street Networks\u00b6","text":"<p>We convert the primary street graph (intersections as nodes) to a dual graph (streets as nodes). In urban analytics, dual graphs are often better for analyzing connectivity and flow between streets, as edges represent the connections between street segments rather than physical intersections.</p>"},{"location":"examples/add_metapaths.html#3-bridge-nodes-connect-amenities","title":"3. Bridge Nodes (Connect Amenities)\u00b6","text":"<p>We attach amenities to their nearest street segment (dual node) using <code>bridge_nodes</code>. This creates a heterogeneous graph with two node types: <code>amenity</code> and <code>segment</code>.</p>"},{"location":"examples/add_metapaths.html#4-add-metapaths-materializing-composite-relations","title":"4. Add Metapaths: Materializing Composite Relations\u00b6","text":"<p>We now define and add the metapath <code>Amenity -&gt; Segment -&gt; Segment -&gt; Segment -&gt; Amenity</code>.</p> <p>The function <code>add_metapaths</code> takes a sequence of edge types (triplets) and computes the composite edges. It returns the updated graph with new metapath edges. This \"materialization\" of metapaths explicitly adds edges between amenities that are topologically close, which can significantly improve the performance of graph learning algorithms.</p>"},{"location":"examples/add_metapaths.html#5-visualization-of-metapath-connections","title":"5. Visualization of Metapath Connections\u00b6","text":"<p>Let's visualize the connections. We'll pick a random amenity and show which other amenities are reachable via this metapath. Visualizing these connections helps verify the graph structure and understand the reachability of amenities within the street network.</p>"},{"location":"examples/add_metapaths.html#6-add-metapaths-by-weight-distance-based-connectivity","title":"6. Add Metapaths by Weight: Distance-Based Connectivity\u00b6","text":"<p>Alternatively, we can connect amenities based on a weight threshold (e.g., distance or time) using <code>add_metapaths_by_weight</code>. This uses Dijkstra's algorithm to find all reachable nodes within a specified limit and edge types.</p>"},{"location":"examples/generating_graphs_by_proximity.html","title":"Proximity Graphs","text":"In\u00a0[1]: Copied! <pre>import warnings\n\nimport geopandas as gpd\nimport contextily as ctx\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport osmnx as ox\nfrom IPython.display import HTML\nfrom matplotlib import animation\n\nimport city2graph as c2g\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  import geopandas as gpd import contextily as ctx import matplotlib.pyplot as plt import networkx as nx import osmnx as ox from IPython.display import HTML from matplotlib import animation  import city2graph as c2g  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>poi_tags = {\n    \"amenity\": [\"restaurant\"]\n    }\n\n#poi_gdf = ox.features_from_place(\"Shibuya, Tokyo, Japan\", poi_tags)\npoi_gdf = ox.features_from_point(\n    (35.658514, 139.70133),  # Tokyo Tower coordinates\n    tags=poi_tags,\n    dist=1000,  # Search radius in meters\n    )\n\n# Filter to include only nodes, not ways and relations\npoi_gdf = poi_gdf[poi_gdf.index.get_level_values(\"element\") == \"node\"]\n\n# Reproject to a projected CRS for accurate centroids\npoi_gdf = poi_gdf.to_crs(epsg=6677)\n</pre> poi_tags = {     \"amenity\": [\"restaurant\"]     }  #poi_gdf = ox.features_from_place(\"Shibuya, Tokyo, Japan\", poi_tags) poi_gdf = ox.features_from_point(     (35.658514, 139.70133),  # Tokyo Tower coordinates     tags=poi_tags,     dist=1000,  # Search radius in meters     )  # Filter to include only nodes, not ways and relations poi_gdf = poi_gdf[poi_gdf.index.get_level_values(\"element\") == \"node\"]  # Reproject to a projected CRS for accurate centroids poi_gdf = poi_gdf.to_crs(epsg=6677) In\u00a0[3]: Copied! <pre>segments_G = ox.graph_from_point(\n    (35.658514, 139.70133),  # Tokyo Tower coordinates\n    dist=1000,  # Search radius in meters\n    )\n\nsegments_gdf = c2g.nx_to_gdf(segments_G, nodes=False, edges=True)\n</pre> segments_G = ox.graph_from_point(     (35.658514, 139.70133),  # Tokyo Tower coordinates     dist=1000,  # Search radius in meters     )  segments_gdf = c2g.nx_to_gdf(segments_G, nodes=False, edges=True) In\u00a0[4]: Copied! <pre>import matplotlib.colors as mcolors\n\ndef get_degree_colors(graph, cmap_name='plasma'):\n    \"\"\"Generate colors based on node degree.\"\"\"\n    if not graph:\n        return []\n    \n    degree_dict = dict(graph.degree())\n    values = list(degree_dict.values())\n    \n    if not values:\n        return []\n        \n    norm = mcolors.Normalize(vmin=min(values), vmax=max(values))\n    cmap = plt.get_cmap(cmap_name)\n    \n    # Match order of nodes in graph\n    return [mcolors.to_hex(cmap(norm(degree_dict[n]))) for n in graph.nodes()]\n</pre> import matplotlib.colors as mcolors  def get_degree_colors(graph, cmap_name='plasma'):     \"\"\"Generate colors based on node degree.\"\"\"     if not graph:         return []          degree_dict = dict(graph.degree())     values = list(degree_dict.values())          if not values:         return []              norm = mcolors.Normalize(vmin=min(values), vmax=max(values))     cmap = plt.get_cmap(cmap_name)          # Match order of nodes in graph     return [mcolors.to_hex(cmap(norm(degree_dict[n]))) for n in graph.nodes()] In\u00a0[5]: Copied! <pre>knn_l1_nodes, knn_l1_edges = c2g.knn_graph(\n    poi_gdf,\n    distance_metric=\"manhattan\",\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n\nknn_l2_nodes, knn_l2_edges = c2g.knn_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n\nknn_net_nodes, knn_net_edges = c2g.knn_graph(\n    poi_gdf,\n    k=10,\n    distance_metric=\"network\",\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n</pre> knn_l1_nodes, knn_l1_edges = c2g.knn_graph(     poi_gdf,     distance_metric=\"manhattan\",     network_gdf=segments_gdf.to_crs(epsg=6677)     )  knn_l2_nodes, knn_l2_edges = c2g.knn_graph(     poi_gdf,     distance_metric=\"euclidean\",     network_gdf=segments_gdf.to_crs(epsg=6677)     )  knn_net_nodes, knn_net_edges = c2g.knn_graph(     poi_gdf,     k=10,     distance_metric=\"network\",     network_gdf=segments_gdf.to_crs(epsg=6677)     ) In\u00a0[6]: Copied! <pre>fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot Manhattan distance KNN Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=knn_l1_edges,\n    ax=axes[0],\n    node_color='darkred',\n    edge_color='red',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6\n    )\n\nctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[0].set_title('KNN Graph - Manhattan Distance', fontsize=12, fontweight='bold')\naxes[0].set_axis_off()\n\n# Plot Euclidean distance KNN Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=knn_l2_edges,\n    ax=axes[1],\n    node_color='darkblue', \n    edge_color='blue',\n    markersize=20, \n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6\n    )\n\nctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[1].set_title('KNN Graph - Euclidean Distance', fontsize=12, fontweight='bold')\naxes[1].set_axis_off()\n\n# Plot Network distance KNN Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=knn_net_edges,\n    ax=axes[2],\n    node_color='darkgreen',\n    edge_color='green',\n    markersize=20, \n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6\n    )\n\nctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[2].set_title('KNN Graph - Network Distance', fontsize=12, fontweight='bold')\naxes[2].set_axis_off()\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(1, 3, figsize=(18, 6))  # Plot Manhattan distance KNN Graph c2g.plot_graph(     nodes=poi_gdf,     edges=knn_l1_edges,     ax=axes[0],     node_color='darkred',     edge_color='red',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6     )  ctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[0].set_title('KNN Graph - Manhattan Distance', fontsize=12, fontweight='bold') axes[0].set_axis_off()  # Plot Euclidean distance KNN Graph c2g.plot_graph(     nodes=poi_gdf,     edges=knn_l2_edges,     ax=axes[1],     node_color='darkblue',      edge_color='blue',     markersize=20,      node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6     )  ctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[1].set_title('KNN Graph - Euclidean Distance', fontsize=12, fontweight='bold') axes[1].set_axis_off()  # Plot Network distance KNN Graph c2g.plot_graph(     nodes=poi_gdf,     edges=knn_net_edges,     ax=axes[2],     node_color='darkgreen',     edge_color='green',     markersize=20,      node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6     )  ctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[2].set_title('KNN Graph - Network Distance', fontsize=12, fontweight='bold') axes[2].set_axis_off()  plt.tight_layout() plt.show() <p>You can obtain the output as <code>nx.Graph</code> object.</p> In\u00a0[7]: Copied! <pre>knn_l2_G = c2g.knn_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    as_nx=True\n)\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nc2g.plot_graph(\n    graph=knn_l2_G,\n    ax=ax,\n    node_color=get_degree_colors(knn_l2_G),\n    edge_color=\"grey\",\n    edge_alpha=0.5,\n    edge_linewidth=0.5,\n    node_alpha=0.9,\n    markersize=30,\n    bgcolor=\"white\"\n    )\n\nif poi_gdf.crs:\n    ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\nax.set_title(\"KNN Graph - Euclidean Distance\", fontsize=14, fontweight=\"bold\", pad=20)\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n</pre> knn_l2_G = c2g.knn_graph(     poi_gdf,     distance_metric=\"euclidean\",     as_nx=True )  fig, ax = plt.subplots(figsize=(12, 10))  c2g.plot_graph(     graph=knn_l2_G,     ax=ax,     node_color=get_degree_colors(knn_l2_G),     edge_color=\"grey\",     edge_alpha=0.5,     edge_linewidth=0.5,     node_alpha=0.9,     markersize=30,     bgcolor=\"white\"     )  if poi_gdf.crs:     ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  ax.set_title(\"KNN Graph - Euclidean Distance\", fontsize=14, fontweight=\"bold\", pad=20) ax.set_axis_off() plt.tight_layout() plt.show() In\u00a0[8]: Copied! <pre>HTML(\"\"\"\n&lt;video controls style=\"width: 100%; max-width: 800px; height: auto;\"&gt;\n    &lt;source src=\"../assets/videos/knn_graph.mp4\" type=\"video/mp4\"&gt;\n&lt;/video&gt;\n\"\"\")\n</pre> HTML(\"\"\"   \"\"\") Out[8]: In\u00a0[9]: Copied! <pre>del_l1_nodes, del_l1_edges = c2g.delaunay_graph(\n    poi_gdf,\n    distance_metric=\"manhattan\"\n    )\n\ndel_l2_nodes, del_l2_edges = c2g.delaunay_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\"\n    )\n\ndel_net_nodes, del_net_edges = c2g.delaunay_graph(\n    poi_gdf,\n    distance_metric=\"network\",\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n</pre> del_l1_nodes, del_l1_edges = c2g.delaunay_graph(     poi_gdf,     distance_metric=\"manhattan\"     )  del_l2_nodes, del_l2_edges = c2g.delaunay_graph(     poi_gdf,     distance_metric=\"euclidean\"     )  del_net_nodes, del_net_edges = c2g.delaunay_graph(     poi_gdf,     distance_metric=\"network\",     network_gdf=segments_gdf.to_crs(epsg=6677)     ) In\u00a0[10]: Copied! <pre>fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot Manhattan distance Delaunay Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=del_l1_edges,\n    ax=axes[0],\n    node_color='darkred',\n    edge_color='red',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6\n    )\n\nctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[0].set_title(\n    'Delaunay Graph - Manhattan Distance', \n    fontsize=12, \n    fontweight='bold'\n    )\naxes[0].set_axis_off()\n\n# Plot Euclidean distance Delaunay Graph\nc2g.plot_graph(nodes=poi_gdf,\n               edges=del_l2_edges,\n               ax=axes[1],\n               node_color='darkblue',\n               edge_color='blue',\n               markersize=20,\n               node_alpha=0.8,\n               edge_linewidth=0.8,\n               edge_alpha=0.6\n               )\n\nctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[1].set_title(\n    'Delaunay Graph - Euclidean Distance',\n    fontsize=12, \n    fontweight='bold'\n    )\naxes[1].set_axis_off()\n\n# Plot Network distance Delaunay Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=del_net_edges,\n    ax=axes[2],\n    node_color='darkgreen',\n    edge_color='green',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6\n    )\n\nctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\naxes[2].set_title(\n    'Delaunay Graph - Network Distance', \n    fontsize=12, \n    fontweight='bold'\n    )\naxes[2].set_axis_off()\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(1, 3, figsize=(18, 6))  # Plot Manhattan distance Delaunay Graph c2g.plot_graph(     nodes=poi_gdf,     edges=del_l1_edges,     ax=axes[0],     node_color='darkred',     edge_color='red',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6     )  ctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[0].set_title(     'Delaunay Graph - Manhattan Distance',      fontsize=12,      fontweight='bold'     ) axes[0].set_axis_off()  # Plot Euclidean distance Delaunay Graph c2g.plot_graph(nodes=poi_gdf,                edges=del_l2_edges,                ax=axes[1],                node_color='darkblue',                edge_color='blue',                markersize=20,                node_alpha=0.8,                edge_linewidth=0.8,                edge_alpha=0.6                )  ctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[1].set_title(     'Delaunay Graph - Euclidean Distance',     fontsize=12,      fontweight='bold'     ) axes[1].set_axis_off()  # Plot Network distance Delaunay Graph c2g.plot_graph(     nodes=poi_gdf,     edges=del_net_edges,     ax=axes[2],     node_color='darkgreen',     edge_color='green',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6     )  ctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron) axes[2].set_title(     'Delaunay Graph - Network Distance',      fontsize=12,      fontweight='bold'     ) axes[2].set_axis_off()  plt.tight_layout() plt.show() In\u00a0[11]: Copied! <pre>del_l2_G = c2g.delaunay_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    as_nx=True\n    )\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nc2g.plot_graph(\n    graph=del_l2_G,\n    ax=ax,\n    node_color=get_degree_colors(del_l2_G),\n    edge_color=\"grey\",\n    edge_alpha=0.5,\n    edge_linewidth=0.5,\n    node_alpha=0.9,\n    markersize=30,\n    bgcolor=\"white\"\n    )\n\nif poi_gdf.crs:\n    ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\nax.set_title(\n    \"Delaunay Graph - Euclidean Distance\", \n    fontsize=14,\n    fontweight=\"bold\",\n    pad=20\n    )\n\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n</pre> del_l2_G = c2g.delaunay_graph(     poi_gdf,     distance_metric=\"euclidean\",     as_nx=True     )  fig, ax = plt.subplots(figsize=(12, 10))  c2g.plot_graph(     graph=del_l2_G,     ax=ax,     node_color=get_degree_colors(del_l2_G),     edge_color=\"grey\",     edge_alpha=0.5,     edge_linewidth=0.5,     node_alpha=0.9,     markersize=30,     bgcolor=\"white\"     )  if poi_gdf.crs:     ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  ax.set_title(     \"Delaunay Graph - Euclidean Distance\",      fontsize=14,     fontweight=\"bold\",     pad=20     )  ax.set_axis_off() plt.tight_layout() plt.show() In\u00a0[12]: Copied! <pre>fix_l1_nodes, fix_l1_edges = c2g.fixed_radius_graph(\n    poi_gdf,\n    distance_metric=\"manhattan\",\n    radius=100\n    )\n\nfix_l2_nodes, fix_l2_edges = c2g.fixed_radius_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    radius=100\n    )\n\nfix_net_nodes, fix_net_edges = c2g.fixed_radius_graph(\n    poi_gdf,\n    distance_metric=\"network\",\n    radius=100,\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n</pre> fix_l1_nodes, fix_l1_edges = c2g.fixed_radius_graph(     poi_gdf,     distance_metric=\"manhattan\",     radius=100     )  fix_l2_nodes, fix_l2_edges = c2g.fixed_radius_graph(     poi_gdf,     distance_metric=\"euclidean\",     radius=100     )  fix_net_nodes, fix_net_edges = c2g.fixed_radius_graph(     poi_gdf,     distance_metric=\"network\",     radius=100,     network_gdf=segments_gdf.to_crs(epsg=6677)     ) In\u00a0[13]: Copied! <pre>fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot Manhattan distance Fixed Radius Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=fix_l1_edges,\n    ax=axes[0],\n    node_color='darkred',\n    edge_color='red',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[0].set_title(\n    'Fixed Radius Graph - Manhattan Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[0].set_axis_off()\n\n# Plot Euclidean distance Fixed Radius Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=fix_l2_edges,\n    ax=axes[1],\n    node_color='darkblue',\n    edge_color='blue',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[1].set_title(\n    'Fixed Radius Graph - Euclidean Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[1].set_axis_off()\n\n# Plot Network distance Fixed Radius Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=fix_net_edges,\n    ax=axes[2],\n    node_color='darkgreen',\n    edge_color='green',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[2].set_title(\n    'Fixed Radius Graph - Network Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[2].set_axis_off()\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(1, 3, figsize=(18, 6))  # Plot Manhattan distance Fixed Radius Graph c2g.plot_graph(     nodes=poi_gdf,     edges=fix_l1_edges,     ax=axes[0],     node_color='darkred',     edge_color='red',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[0].set_title(     'Fixed Radius Graph - Manhattan Distance',     fontsize=12,     fontweight='bold'     ) axes[0].set_axis_off()  # Plot Euclidean distance Fixed Radius Graph c2g.plot_graph(     nodes=poi_gdf,     edges=fix_l2_edges,     ax=axes[1],     node_color='darkblue',     edge_color='blue',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[1].set_title(     'Fixed Radius Graph - Euclidean Distance',     fontsize=12,     fontweight='bold'     ) axes[1].set_axis_off()  # Plot Network distance Fixed Radius Graph c2g.plot_graph(     nodes=poi_gdf,     edges=fix_net_edges,     ax=axes[2],     node_color='darkgreen',     edge_color='green',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[2].set_title(     'Fixed Radius Graph - Network Distance',     fontsize=12,     fontweight='bold'     ) axes[2].set_axis_off()  plt.tight_layout() plt.show() In\u00a0[14]: Copied! <pre>gil_l2_G = c2g.fixed_radius_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    radius=100,\n    as_nx=True\n    )\n\nfig, ax = plt.subplots(figsize=(12, 10))\n\nc2g.plot_graph(\n    graph=gil_l2_G,\n    ax=ax,\n    node_color=get_degree_colors(gil_l2_G),\n    edge_color=\"grey\",\n    edge_alpha=0.5,\n    edge_linewidth=0.5,\n    node_alpha=0.9,\n    markersize=30,\n    bgcolor=\"white\"\n    )\n\nif poi_gdf.crs:\n    ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\nax.set_title(\n    \"Fixed Radius Graph - Euclidean Distance\",\n    fontsize=14,\n    fontweight=\"bold\",\n    pad=20\n    )\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n</pre> gil_l2_G = c2g.fixed_radius_graph(     poi_gdf,     distance_metric=\"euclidean\",     radius=100,     as_nx=True     )  fig, ax = plt.subplots(figsize=(12, 10))  c2g.plot_graph(     graph=gil_l2_G,     ax=ax,     node_color=get_degree_colors(gil_l2_G),     edge_color=\"grey\",     edge_alpha=0.5,     edge_linewidth=0.5,     node_alpha=0.9,     markersize=30,     bgcolor=\"white\"     )  if poi_gdf.crs:     ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  ax.set_title(     \"Fixed Radius Graph - Euclidean Distance\",     fontsize=14,     fontweight=\"bold\",     pad=20     ) ax.set_axis_off() plt.tight_layout() plt.show() In\u00a0[15]: Copied! <pre>HTML(\"\"\"\n&lt;video controls style=\"width: 100%; max-width: 800px; height: auto;\"&gt;\n    &lt;source src=\"../assets/videos/gilbert_graph.mp4\" type=\"video/mp4\"&gt;\n&lt;/video&gt;\n\"\"\")\n</pre> HTML(\"\"\"   \"\"\") Out[15]: In\u00a0[16]: Copied! <pre>wax_l1_nodes, wax_l1_edges = c2g.waxman_graph(\n    poi_gdf,\n    distance_metric=\"manhattan\",\n    r0=100,\n    beta=0.5\n    )\n    \nwax_l2_nodes, wax_l2_edges = c2g.waxman_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    r0=100,\n    beta=0.5\n    )\n\nwax_net_nodes, wax_net_edges = c2g.waxman_graph(\n    poi_gdf,\n    distance_metric=\"network\",\n    r0=100,\n    beta=0.5,\n    network_gdf=segments_gdf.to_crs(epsg=6677)\n    )\n</pre> wax_l1_nodes, wax_l1_edges = c2g.waxman_graph(     poi_gdf,     distance_metric=\"manhattan\",     r0=100,     beta=0.5     )      wax_l2_nodes, wax_l2_edges = c2g.waxman_graph(     poi_gdf,     distance_metric=\"euclidean\",     r0=100,     beta=0.5     )  wax_net_nodes, wax_net_edges = c2g.waxman_graph(     poi_gdf,     distance_metric=\"network\",     r0=100,     beta=0.5,     network_gdf=segments_gdf.to_crs(epsg=6677)     ) In\u00a0[17]: Copied! <pre>fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot Manhattan distance Waxman Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=wax_l1_edges,\n    ax=axes[0],\n    node_color='darkred',\n    edge_color='red',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[0].set_title(\n    'Waxman Graph - Manhattan Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[0].set_axis_off()\n\n# Plot Euclidean distance Waxman Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=wax_l2_edges,\n    ax=axes[1],\n    node_color='darkblue',\n    edge_color='blue',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[1].set_title(\n    'Waxman Graph - Euclidean Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[1].set_axis_off()\n\n# Plot Network distance Waxman Graph\nc2g.plot_graph(\n    nodes=poi_gdf,\n    edges=wax_net_edges,\n    ax=axes[2],\n    node_color='darkgreen',\n    edge_color='green',\n    markersize=20,\n    node_alpha=0.8,\n    edge_linewidth=0.8,\n    edge_alpha=0.6,\n    bgcolor=\"white\"\n    )\n\nctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\naxes[2].set_title(\n    'Waxman Graph - Network Distance',\n    fontsize=12,\n    fontweight='bold'\n    )\naxes[2].set_axis_off()\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(1, 3, figsize=(18, 6))  # Plot Manhattan distance Waxman Graph c2g.plot_graph(     nodes=poi_gdf,     edges=wax_l1_edges,     ax=axes[0],     node_color='darkred',     edge_color='red',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[0], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[0].set_title(     'Waxman Graph - Manhattan Distance',     fontsize=12,     fontweight='bold'     ) axes[0].set_axis_off()  # Plot Euclidean distance Waxman Graph c2g.plot_graph(     nodes=poi_gdf,     edges=wax_l2_edges,     ax=axes[1],     node_color='darkblue',     edge_color='blue',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[1], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[1].set_title(     'Waxman Graph - Euclidean Distance',     fontsize=12,     fontweight='bold'     ) axes[1].set_axis_off()  # Plot Network distance Waxman Graph c2g.plot_graph(     nodes=poi_gdf,     edges=wax_net_edges,     ax=axes[2],     node_color='darkgreen',     edge_color='green',     markersize=20,     node_alpha=0.8,     edge_linewidth=0.8,     edge_alpha=0.6,     bgcolor=\"white\"     )  ctx.add_basemap(axes[2], crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  axes[2].set_title(     'Waxman Graph - Network Distance',     fontsize=12,     fontweight='bold'     ) axes[2].set_axis_off()  plt.tight_layout() plt.show() In\u00a0[18]: Copied! <pre>wax_l2_G = c2g.waxman_graph(\n    poi_gdf,\n    distance_metric=\"euclidean\",\n    r0=100,\n    beta=0.5,\n    as_nx=True\n    )\nfig, ax = plt.subplots(figsize=(12, 10))\n\nc2g.plot_graph(\n    graph=wax_l2_G,\n    ax=ax,\n    node_color=get_degree_colors(wax_l2_G),\n    edge_color=\"grey\",\n    edge_alpha=0.5,\n    edge_linewidth=0.5,\n    node_alpha=0.9,\n    markersize=30,\n    bgcolor=\"white\"\n    )\n\nif poi_gdf.crs:\n    ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)\n\nax.set_title(\n    \"Waxman Graph - Euclidean Distance\",\n    fontsize=14,\n    fontweight=\"bold\",\n    pad=20\n    )\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n</pre> wax_l2_G = c2g.waxman_graph(     poi_gdf,     distance_metric=\"euclidean\",     r0=100,     beta=0.5,     as_nx=True     ) fig, ax = plt.subplots(figsize=(12, 10))  c2g.plot_graph(     graph=wax_l2_G,     ax=ax,     node_color=get_degree_colors(wax_l2_G),     edge_color=\"grey\",     edge_alpha=0.5,     edge_linewidth=0.5,     node_alpha=0.9,     markersize=30,     bgcolor=\"white\"     )  if poi_gdf.crs:     ctx.add_basemap(ax, crs=poi_gdf.crs, source=ctx.providers.CartoDB.Positron)  ax.set_title(     \"Waxman Graph - Euclidean Distance\",     fontsize=14,     fontweight=\"bold\",     pad=20     ) ax.set_axis_off() plt.tight_layout() plt.show() In\u00a0[19]: Copied! <pre>HTML(\"\"\"\n&lt;video controls style=\"width: 100%; max-width: 800px; height: auto;\"&gt;\n    &lt;source src=\"../assets/videos/waxman_graph.mp4\" type=\"video/mp4\"&gt;\n&lt;/video&gt;\n\"\"\")\n</pre> HTML(\"\"\"   \"\"\") Out[19]: <p>In this example, three types of nodes (restaurants, hospitals, and commercials) are extracted from OpenStreetMap in Shibuya, Tokyo.</p> In\u00a0[20]: Copied! <pre># Create different layers of POIs for multi-layer analysis\n# Let's create hospitals and commercial POIs in addition to restaurants\n\n# Hospitals layer\nhospital_tags = {\n    \"amenity\": [\n        \"hospital\"]}\n\nhospital_gdf = ox.features_from_point(\n    (35.658514, 139.70133),  # Tokyo Tower coordinates\n    tags=hospital_tags,\n    dist=1000,  # Search radius in meters\n    )\n\n# Filter to include only nodes, not ways and relations\nhospital_gdf = hospital_gdf[hospital_gdf.index.get_level_values(\"element\") == \"node\"]\nhospital_gdf = hospital_gdf.to_crs(epsg=6677)\n\n# Commercial layer (shops)\ncommercial_tags = {\n    \"shop\": True}\n\ncommercial_gdf = ox.features_from_point(\n    (35.658514, 139.70133),  # Tokyo Tower coordinates\n    tags=commercial_tags,\n    dist=1000,  # Search radius in meters\n    )\n\n# Filter to include only nodes and take a subset to avoid too many points\ncommercial_gdf = commercial_gdf[commercial_gdf.index.get_level_values(\"element\") == \"node\"]\ncommercial_gdf = commercial_gdf.to_crs(epsg=6677)\n\n# Take a subset for better visualization\ncommercial_gdf = commercial_gdf.sample(min(30, len(commercial_gdf)), random_state=42)\n\nprint(f\"Restaurants: {len(poi_gdf)} nodes\")\nprint(f\"Hospitals: {len(hospital_gdf)} nodes\") \nprint(f\"Commercial: {len(commercial_gdf)} nodes\")\n</pre> # Create different layers of POIs for multi-layer analysis # Let's create hospitals and commercial POIs in addition to restaurants  # Hospitals layer hospital_tags = {     \"amenity\": [         \"hospital\"]}  hospital_gdf = ox.features_from_point(     (35.658514, 139.70133),  # Tokyo Tower coordinates     tags=hospital_tags,     dist=1000,  # Search radius in meters     )  # Filter to include only nodes, not ways and relations hospital_gdf = hospital_gdf[hospital_gdf.index.get_level_values(\"element\") == \"node\"] hospital_gdf = hospital_gdf.to_crs(epsg=6677)  # Commercial layer (shops) commercial_tags = {     \"shop\": True}  commercial_gdf = ox.features_from_point(     (35.658514, 139.70133),  # Tokyo Tower coordinates     tags=commercial_tags,     dist=1000,  # Search radius in meters     )  # Filter to include only nodes and take a subset to avoid too many points commercial_gdf = commercial_gdf[commercial_gdf.index.get_level_values(\"element\") == \"node\"] commercial_gdf = commercial_gdf.to_crs(epsg=6677)  # Take a subset for better visualization commercial_gdf = commercial_gdf.sample(min(30, len(commercial_gdf)), random_state=42)  print(f\"Restaurants: {len(poi_gdf)} nodes\") print(f\"Hospitals: {len(hospital_gdf)} nodes\")  print(f\"Commercial: {len(commercial_gdf)} nodes\") <pre>Restaurants: 563 nodes\nHospitals: 6 nodes\nCommercial: 30 nodes\n</pre> <p>A dictionary of nodes with their label names are made as <code>nodes_dict</code>. It is then passed to <code>bridge_nodes</code> to generate edges by proximity.</p> In\u00a0[21]: Copied! <pre># Create a nodes dictionary for multi-layer network\nnodes_dict = {\n    \"restaurants\": poi_gdf,\n    \"hospitals\": hospital_gdf,\n    \"commercial\": commercial_gdf\n}\n\n# Generate proximity edges between layers using KNN method\nproximity_nodes, proximity_edges = c2g.bridge_nodes(\n    nodes_dict, \n    proximity_method=\"knn\", \n    k=5,  # Connect to 5 nearest neighbors in each target layer\n    distance_metric=\"euclidean\"\n)\n\nprint(\"Generated edge types:\")\nfor edge_key in proximity_edges.keys():\n    print(\n        f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_edges[edge_key])} edges\"\n        )\n</pre> # Create a nodes dictionary for multi-layer network nodes_dict = {     \"restaurants\": poi_gdf,     \"hospitals\": hospital_gdf,     \"commercial\": commercial_gdf }  # Generate proximity edges between layers using KNN method proximity_nodes, proximity_edges = c2g.bridge_nodes(     nodes_dict,      proximity_method=\"knn\",      k=5,  # Connect to 5 nearest neighbors in each target layer     distance_metric=\"euclidean\" )  print(\"Generated edge types:\") for edge_key in proximity_edges.keys():     print(         f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_edges[edge_key])} edges\"         ) <pre>Generated edge types:\n  restaurants \u2192 hospitals: 2815 edges\n  restaurants \u2192 commercial: 2815 edges\n  hospitals \u2192 restaurants: 30 edges\n  hospitals \u2192 commercial: 30 edges\n  commercial \u2192 restaurants: 150 edges\n  commercial \u2192 hospitals: 150 edges\n</pre> <p>As shown in the plot, there are six types of proximity in the result.</p> In\u00a0[22]: Copied! <pre># Prepare for axes in advance\nfig, ax = plt.subplots(2, 3, figsize=(18, 12))\n\n# Visualize the multi-layer network connections\nc2g.plot_graph(\n    nodes=proximity_nodes,\n    edges=proximity_edges,\n    ax=ax,\n    subplots=True,\n    node_color={\n        \"restaurants\": \"blue\",\n        \"hospitals\": \"yellow\",\n        \"commercial\": \"red\"\n    },\n    edge_color=\"black\",\n    edge_alpha=0.4,\n    edge_linewidth=0.4,\n    node_alpha=0.9,\n    markersize={\"restaurants\": 25, \"hospitals\": 25, \"commercial\": 25},\n    bgcolor=\"white\",\n    title_color=\"black\"\n)\n\n# Set basemap\nfor a in ax.flatten():\n    ctx.add_basemap(\n        a,\n        crs=proximity_nodes[\"restaurants\"].crs,\n        source=ctx.providers.CartoDB.Positron\n        )\n    a.set_axis_off()\n</pre> # Prepare for axes in advance fig, ax = plt.subplots(2, 3, figsize=(18, 12))  # Visualize the multi-layer network connections c2g.plot_graph(     nodes=proximity_nodes,     edges=proximity_edges,     ax=ax,     subplots=True,     node_color={         \"restaurants\": \"blue\",         \"hospitals\": \"yellow\",         \"commercial\": \"red\"     },     edge_color=\"black\",     edge_alpha=0.4,     edge_linewidth=0.4,     node_alpha=0.9,     markersize={\"restaurants\": 25, \"hospitals\": 25, \"commercial\": 25},     bgcolor=\"white\",     title_color=\"black\" )  # Set basemap for a in ax.flatten():     ctx.add_basemap(         a,         crs=proximity_nodes[\"restaurants\"].crs,         source=ctx.providers.CartoDB.Positron         )     a.set_axis_off() In\u00a0[23]: Copied! <pre># Compare with fixed-radius method\nradius_nodes, radius_edges = c2g.bridge_nodes(\n    nodes_dict,\n    proximity_method=\"fixed_radius\",\n    radius=500,  # 500 meter radius\n    distance_metric=\"euclidean\"\n)\n\nprint(\"\\nFixed-radius method (500m radius):\")\nprint(\"Generated edge types:\")\ntotal_knn_edges = sum(len(gdf) for gdf in proximity_edges.values())\ntotal_radius_edges = sum(len(gdf) for gdf in radius_edges.values())\n\nfor edge_key in proximity_edges.keys():\n    knn_count = len(proximity_edges[edge_key])\n    radius_count = len(radius_edges[edge_key]) if edge_key in radius_edges else 0\n    print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: KNN(k=2)={knn_count}, Fixed-radius(200m)={radius_count}\")\n\nprint(f\"\\nTotal edges: KNN={total_knn_edges}, Fixed-radius={total_radius_edges}\")\n</pre> # Compare with fixed-radius method radius_nodes, radius_edges = c2g.bridge_nodes(     nodes_dict,     proximity_method=\"fixed_radius\",     radius=500,  # 500 meter radius     distance_metric=\"euclidean\" )  print(\"\\nFixed-radius method (500m radius):\") print(\"Generated edge types:\") total_knn_edges = sum(len(gdf) for gdf in proximity_edges.values()) total_radius_edges = sum(len(gdf) for gdf in radius_edges.values())  for edge_key in proximity_edges.keys():     knn_count = len(proximity_edges[edge_key])     radius_count = len(radius_edges[edge_key]) if edge_key in radius_edges else 0     print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: KNN(k=2)={knn_count}, Fixed-radius(200m)={radius_count}\")  print(f\"\\nTotal edges: KNN={total_knn_edges}, Fixed-radius={total_radius_edges}\") <pre>\nFixed-radius method (500m radius):\nGenerated edge types:\n  restaurants \u2192 hospitals: KNN(k=2)=2815, Fixed-radius(200m)=958\n  restaurants \u2192 commercial: KNN(k=2)=2815, Fixed-radius(200m)=4967\n  hospitals \u2192 restaurants: KNN(k=2)=30, Fixed-radius(200m)=958\n  hospitals \u2192 commercial: KNN(k=2)=30, Fixed-radius(200m)=46\n  commercial \u2192 restaurants: KNN(k=2)=150, Fixed-radius(200m)=4967\n  commercial \u2192 hospitals: KNN(k=2)=150, Fixed-radius(200m)=46\n\nTotal edges: KNN=5990, Fixed-radius=11942\n</pre> In\u00a0[24]: Copied! <pre># Prepare for axes in advance\nfig, ax = plt.subplots(2, 3, figsize=(18, 12))\n\n# Visualize the multi-layer network connections\nc2g.plot_graph(\n    nodes=radius_nodes,\n    edges=radius_edges,\n    ax=ax,\n    subplots=True,\n    node_color={\n        \"restaurants\": \"blue\",\n        \"hospitals\": \"yellow\",\n        \"commercial\": \"red\"\n    },\n    edge_color=\"black\",\n    edge_alpha=0.4,\n    edge_linewidth=0.4,\n    node_alpha=0.9,\n    markersize={\"restaurants\": 25, \"hospitals\": 25, \"commercial\": 25},\n    bgcolor=\"white\",\n    title_color=\"black\"\n)\n\n\n# Set basemap\nfor a in ax.flatten():\n    ctx.add_basemap(\n        a,\n        crs=radius_nodes[\"restaurants\"].crs,\n        source=ctx.providers.CartoDB.Positron\n        )\n    a.set_axis_off()\n</pre> # Prepare for axes in advance fig, ax = plt.subplots(2, 3, figsize=(18, 12))  # Visualize the multi-layer network connections c2g.plot_graph(     nodes=radius_nodes,     edges=radius_edges,     ax=ax,     subplots=True,     node_color={         \"restaurants\": \"blue\",         \"hospitals\": \"yellow\",         \"commercial\": \"red\"     },     edge_color=\"black\",     edge_alpha=0.4,     edge_linewidth=0.4,     node_alpha=0.9,     markersize={\"restaurants\": 25, \"hospitals\": 25, \"commercial\": 25},     bgcolor=\"white\",     title_color=\"black\" )   # Set basemap for a in ax.flatten():     ctx.add_basemap(         a,         crs=radius_nodes[\"restaurants\"].crs,         source=ctx.providers.CartoDB.Positron         )     a.set_axis_off() <p>You can stack multiple layers of networks by <code>bridge_nodes</code> to construct a heterogenous graph. In another example below, streets network and bus transportation network will be stacked. For the behaviour of <code>load_gtfs</code> and <code>travel_summary_graph</code>, see transportation.py for detailed documentation.</p> <p>In this case, OpenStreetMap and GTFS from the Greater London are used as samples.</p> In\u00a0[25]: Copied! <pre># Load GTFS data for travel summary graph generation\nsample_gtfs_path = \"./data/itm_london_gtfs.zip\"\ngtfs_data = c2g.load_gtfs(sample_gtfs_path)\n\n# Generate travel summary graph for a specific date\ntravel_summary_nodes, travel_summary_edges = c2g.travel_summary_graph(\n    gtfs_data,\n    calendar_start=\"20250601\",\n    calendar_end=\"20250601\"\n    )\n\n# Get the boundary polygon for London from OSMnx\nlondon_boundary = ox.geocode_to_gdf(\"Greater London, UK\").to_crs(epsg=27700)\n\n# Project travel summary data to the same CRS as the bounding box\ntravel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700)\ntravel_summary_edges = travel_summary_edges.to_crs(epsg=27700)\n\n# Filter nodes and edges that are within the bounding box\nnodes_in_bound = gpd.sjoin(\n    travel_summary_nodes,\n    london_boundary,\n    how=\"inner\"\n    ).drop(columns=['index_right'])\n\nedges_in_bound = gpd.sjoin(\n    travel_summary_edges,\n    london_boundary,\n    how=\"inner\"\n    ).drop(columns=['index_right'])\n\n# Update the original variables with the filtered data\ntravel_summary_nodes = nodes_in_bound\ntravel_summary_edges = edges_in_bound\n\ntravel_summary_edges = travel_summary_edges[\n    travel_summary_edges.index.get_level_values('from_stop_id').isin(travel_summary_nodes.index) &amp;\n    travel_summary_edges.index.get_level_values('to_stop_id').isin(travel_summary_nodes.index)\n]\n\nprint(f\"Nodes within boundary: {len(travel_summary_nodes)}\")\nprint(f\"Edges within boundary: {len(travel_summary_edges)}\")\n</pre> # Load GTFS data for travel summary graph generation sample_gtfs_path = \"./data/itm_london_gtfs.zip\" gtfs_data = c2g.load_gtfs(sample_gtfs_path)  # Generate travel summary graph for a specific date travel_summary_nodes, travel_summary_edges = c2g.travel_summary_graph(     gtfs_data,     calendar_start=\"20250601\",     calendar_end=\"20250601\"     )  # Get the boundary polygon for London from OSMnx london_boundary = ox.geocode_to_gdf(\"Greater London, UK\").to_crs(epsg=27700)  # Project travel summary data to the same CRS as the bounding box travel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700) travel_summary_edges = travel_summary_edges.to_crs(epsg=27700)  # Filter nodes and edges that are within the bounding box nodes_in_bound = gpd.sjoin(     travel_summary_nodes,     london_boundary,     how=\"inner\"     ).drop(columns=['index_right'])  edges_in_bound = gpd.sjoin(     travel_summary_edges,     london_boundary,     how=\"inner\"     ).drop(columns=['index_right'])  # Update the original variables with the filtered data travel_summary_nodes = nodes_in_bound travel_summary_edges = edges_in_bound  travel_summary_edges = travel_summary_edges[     travel_summary_edges.index.get_level_values('from_stop_id').isin(travel_summary_nodes.index) &amp;     travel_summary_edges.index.get_level_values('to_stop_id').isin(travel_summary_nodes.index) ]  print(f\"Nodes within boundary: {len(travel_summary_nodes)}\") print(f\"Edges within boundary: {len(travel_summary_edges)}\")  <pre>Nodes within boundary: 20220\nEdges within boundary: 25182\n</pre> In\u00a0[26]: Copied! <pre># Download London's street network as a GeoDataFrame\nlondon_graph = ox.graph_from_place(\"Greater London, UK\", network_type=\"drive\")\nstreet_nodes, street_edges = c2g.nx_to_gdf(london_graph)\n\n# Add these lines to project the nodes as well\nstreet_nodes.to_crs(epsg=27700, inplace=True)\ntravel_summary_nodes.to_crs(epsg=27700, inplace=True)\n\nstreet_edges.to_crs(epsg=27700, inplace=True)\ntravel_summary_edges.to_crs(epsg=27700, inplace=True)\n</pre> # Download London's street network as a GeoDataFrame london_graph = ox.graph_from_place(\"Greater London, UK\", network_type=\"drive\") street_nodes, street_edges = c2g.nx_to_gdf(london_graph)  # Add these lines to project the nodes as well street_nodes.to_crs(epsg=27700, inplace=True) travel_summary_nodes.to_crs(epsg=27700, inplace=True)  street_edges.to_crs(epsg=27700, inplace=True) travel_summary_edges.to_crs(epsg=27700, inplace=True) <p>Now, <code>bridge_nodes</code> is applied to the two types of nodes.</p> In\u00a0[27]: Copied! <pre>proximity_nodes, proximity_edges = c2g.bridge_nodes(\n    {\"street\": street_nodes,\n     \"bus\": travel_summary_nodes}\n    )\n</pre> proximity_nodes, proximity_edges = c2g.bridge_nodes(     {\"street\": street_nodes,      \"bus\": travel_summary_nodes}     ) <p>The two types of edges <code>('bus', 'is_nearby', 'street')</code> and <code>('street', 'is_nearby', 'bus')</code> are visualized.</p> In\u00a0[28]: Copied! <pre>c2g.plot_graph(\n    nodes=proximity_nodes,\n    edges=proximity_edges,\n    ncols=2\n)\n</pre> c2g.plot_graph(     nodes=proximity_nodes,     edges=proximity_edges,     ncols=2 ) Out[28]: <pre>array([&lt;Axes: title={'center': \"('street', 'is_nearby', 'bus')\"}&gt;,\n       &lt;Axes: title={'center': \"('bus', 'is_nearby', 'street')\"}&gt;],\n      dtype=object)</pre> <p>In addition to the obtained edges by proximity, <code>street_edges</code> and <code>travel_summary_edges</code> are registered as two meta-paths of the heterogenous graph. <code>proximity_nodes</code> and <code>proximity_edges</code> are finally used to constructed a <code>HeteroData</code> for PyTorch Geometric by <code>gdf_to_pyg</code>.</p> In\u00a0[29]: Copied! <pre># Convert proximity_nodes and proximity_edges to HeteroData using gdf_to_pyg\nhetero_data = c2g.gdf_to_pyg(proximity_nodes, proximity_edges)\n</pre> # Convert proximity_nodes and proximity_edges to HeteroData using gdf_to_pyg hetero_data = c2g.gdf_to_pyg(proximity_nodes, proximity_edges) In\u00a0[30]: Copied! <pre>print(\"HeteroData structure:\")\nprint(hetero_data)\nprint(\"\\nNode types and their counts:\")\nfor node_type in hetero_data.node_types:\n    print(f\"  {node_type}: {hetero_data[node_type].x.shape[0]} nodes\")\nprint(\"\\nEdge types and their counts:\")\nfor edge_type in hetero_data.edge_types:\n    print(f\"  {edge_type}: {hetero_data[edge_type].edge_index.shape[1]} edges\")\n</pre> print(\"HeteroData structure:\") print(hetero_data) print(\"\\nNode types and their counts:\") for node_type in hetero_data.node_types:     print(f\"  {node_type}: {hetero_data[node_type].x.shape[0]} nodes\") print(\"\\nEdge types and their counts:\") for edge_type in hetero_data.edge_types:     print(f\"  {edge_type}: {hetero_data[edge_type].edge_index.shape[1]} edges\") <pre>HeteroData structure:\nHeteroData(\n  crs=EPSG:27700,\n  graph_metadata=&lt;city2graph.base.GraphMetadata object at 0x16b4c6f70&gt;,\n  street={\n    x=[130474, 0],\n    pos=[130474, 2],\n  },\n  bus={\n    x=[20220, 0],\n    pos=[20220, 2],\n  },\n  (street, is_nearby, bus)={\n    edge_index=[2, 130474],\n    edge_attr=[130474, 0],\n  },\n  (bus, is_nearby, street)={\n    edge_index=[2, 20220],\n    edge_attr=[20220, 0],\n  }\n)\n\nNode types and their counts:\n  street: 130474 nodes\n  bus: 20220 nodes\n\nEdge types and their counts:\n  ('street', 'is_nearby', 'bus'): 130474 edges\n  ('bus', 'is_nearby', 'street'): 20220 edges\n</pre> In\u00a0[31]: Copied! <pre>import geopandas as gpd\n\n# Load London wards shapefile and run contiguity_graph\nwards_path = \"./data/London-wards-2018/London-wards-2018_ESRI/London_Ward_CityMerged.shp\"\n\n# Read\nwards = gpd.read_file(wards_path)\nprint(\"Wards loaded:\", len(wards), \", CRS:\", wards.crs)\n</pre> import geopandas as gpd  # Load London wards shapefile and run contiguity_graph wards_path = \"./data/London-wards-2018/London-wards-2018_ESRI/London_Ward_CityMerged.shp\"  # Read wards = gpd.read_file(wards_path) print(\"Wards loaded:\", len(wards), \", CRS:\", wards.crs) <pre>Wards loaded: 633 , CRS: EPSG:27700\n</pre> In\u00a0[32]: Copied! <pre># Queen contiguity\nwn_q_nodes, wn_q_edges = c2g.contiguity_graph(wards, contiguity=\"queen\", as_nx=False)\n\n# Rook contiguity\nwn_r_nodes, wn_r_edges = c2g.contiguity_graph(wards, contiguity=\"rook\", as_nx=False)\n\nprint(f\"Queen \u2014 wards: {len(wn_q_nodes)}, edges: {len(wn_q_edges)}\")\nprint(f\"Rook  \u2014 wards: {len(wn_r_nodes)}, edges: {len(wn_r_edges)}\")\n</pre> # Queen contiguity wn_q_nodes, wn_q_edges = c2g.contiguity_graph(wards, contiguity=\"queen\", as_nx=False)  # Rook contiguity wn_r_nodes, wn_r_edges = c2g.contiguity_graph(wards, contiguity=\"rook\", as_nx=False)  print(f\"Queen \u2014 wards: {len(wn_q_nodes)}, edges: {len(wn_q_edges)}\") print(f\"Rook  \u2014 wards: {len(wn_r_nodes)}, edges: {len(wn_r_edges)}\") <pre>Queen \u2014 wards: 633, edges: 1865\nRook  \u2014 wards: 633, edges: 1797\n</pre> <p>As seen below, the output properly contains the contiguity.</p> In\u00a0[35]: Copied! <pre>wn_q_edges\n</pre> wn_q_edges Out[35]: weight geometry 0 6 2293.180212 LINESTRING (517652.344 162339.161, 518064.389 ... 1 3 1477.089130 LINESTRING (519124.935 165300.016, 520118.14 1... 6 1273.490894 LINESTRING (519124.935 165300.016, 518064.389 ... 7 1416.550272 LINESTRING (519124.935 165300.016, 518303.176 ... 2 7 1200.560634 LINESTRING (519108.407 167344.325, 518303.176 ... ... ... ... ... 626 631 1157.332290 LINESTRING (548034.582 186790.44, 548124.872 1... 627 628 1416.092005 LINESTRING (549443.328 186492.423, 548566.274 ... 629 1402.322724 LINESTRING (549443.328 186492.423, 550789.867 ... 631 1571.845404 LINESTRING (549443.328 186492.423, 548124.872 ... 628 630 1897.904259 LINESTRING (548566.274 187604.22, 548359.712 1... <p>1865 rows \u00d7 2 columns</p> In\u00a0[\u00a0]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(10, 10), dpi=150)\n\n# Normalize line widths from edge weights\nlw = 0.5 + 2.0 * (w - w.min()) / (w.max() - w.min() if w.max() &gt; w.min() else 1.0)\n\n\n# Use c2g.plot_graph for consistent plotting\n# For contiguity, we treat wards as nodes and the adjacency as edges\nc2g.plot_graph(\n    nodes=wn_q_nodes,\n    edges=wn_q_edges,\n    ax=ax,\n    bgcolor=\"white\",\n    \n    # Node styling (Wards polygons)\n    node_color=\"#f5f5f7\",   # near-white fill\n    node_edgecolor=\"#9aa0a6\", # soft gray outline\n    \n    # Edge styling (Contiguity links)\n    edge_color=\"#1f77b4\",   # vivid blue\n    edge_linewidth=1/lw,\n    edge_alpha=0.95,\n    edge_zorder=3\n)\n\n# Focus on content, remove axes clutter\nax.set_axis_off()\nax.set_title(\"London wards \u2014 Queen contiguity graph\", fontsize=14, fontweight=\"bold\", pad=12)\n\nplt.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(10, 10), dpi=150)  # Normalize line widths from edge weights lw = 0.5 + 2.0 * (w - w.min()) / (w.max() - w.min() if w.max() &gt; w.min() else 1.0)   # Use c2g.plot_graph for consistent plotting # For contiguity, we treat wards as nodes and the adjacency as edges c2g.plot_graph(     nodes=wn_q_nodes,     edges=wn_q_edges,     ax=ax,     bgcolor=\"white\",          # Node styling (Wards polygons)     node_color=\"#f5f5f7\",   # near-white fill     node_edgecolor=\"#9aa0a6\", # soft gray outline          # Edge styling (Contiguity links)     edge_color=\"#1f77b4\",   # vivid blue     edge_linewidth=1/lw,     edge_alpha=0.95,     edge_zorder=3 )  # Focus on content, remove axes clutter ax.set_axis_off() ax.set_title(\"London wards \u2014 Queen contiguity graph\", fontsize=14, fontweight=\"bold\", pad=12)  plt.tight_layout() plt.show() In\u00a0[41]: Copied! <pre># Basic connectivity using NetworkX\nG_wards = c2g.contiguity_graph(wards, contiguity=\"queen\", as_nx=True)\n\ndegree_centrality = nx.degree_centrality(G_wards)\nnx.set_node_attributes(G_wards, degree_centrality, 'degree_centrality')\n\nbetweenness_centrality = nx.betweenness_centrality(G_wards)\nnx.set_node_attributes(G_wards, betweenness_centrality, 'betweenness_centrality')\n\ncloseness_centrality = nx.closeness_centrality(G_wards)\nnx.set_node_attributes(G_wards, closeness_centrality, 'closeness_centrality')\n\nwn_q_nodes, wn_q_edges = c2g.nx_to_gdf(G_wards)\n</pre> # Basic connectivity using NetworkX G_wards = c2g.contiguity_graph(wards, contiguity=\"queen\", as_nx=True)  degree_centrality = nx.degree_centrality(G_wards) nx.set_node_attributes(G_wards, degree_centrality, 'degree_centrality')  betweenness_centrality = nx.betweenness_centrality(G_wards) nx.set_node_attributes(G_wards, betweenness_centrality, 'betweenness_centrality')  closeness_centrality = nx.closeness_centrality(G_wards) nx.set_node_attributes(G_wards, closeness_centrality, 'closeness_centrality')  wn_q_nodes, wn_q_edges = c2g.nx_to_gdf(G_wards) <p><code>contiguity_graph</code> preserves all original polygon attributes while adding computed centrality measures.</p> In\u00a0[42]: Copied! <pre>wn_q_nodes.head()\n</pre> wn_q_nodes.head() Out[42]: NAME GSS_CODE DISTRICT LAGSSCODE HECTARES NONLD_AREA geometry degree_centrality betweenness_centrality closeness_centrality 0 Chessington South E05000405 Kingston upon Thames E09000021 755.173 0.0 POLYGON ((516401.596 160201.802, 516407.302 16... 0.001582 0.000000 0.070004 1 Tolworth and Hook Rise E05000414 Kingston upon Thames E09000021 259.464 0.0 POLYGON ((519552.998 164295.6, 519508.096 1643... 0.004747 0.006319 0.081359 2 Berrylands E05000401 Kingston upon Thames E09000021 145.390 0.0 POLYGON ((518107.499 167303.399, 518114.301 16... 0.009494 0.002797 0.088157 3 Alexandra E05000400 Kingston upon Thames E09000021 268.506 0.0 POLYGON ((520336.7 165105.498, 520332.198 1651... 0.009494 0.011225 0.087924 4 Beverley E05000402 Kingston upon Thames E09000021 187.821 0.0 POLYGON ((521201.203 169275.505, 521204.303 16... 0.014241 0.036149 0.095700 <p>Now we can see the distribution of each centrality. As shown below, each distribution has unique pattern.</p> In\u00a0[43]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 3, figsize=(18, 6))\n\n# Plot Degree Centrality\naxes[0].hist(wn_q_nodes['degree_centrality'], bins=100, edgecolor='black', alpha=0.7)\naxes[0].set_title('Degree Centrality Distribution', fontsize=14, fontweight='bold')\naxes[0].set_xlabel('Degree Centrality', fontsize=12)\naxes[0].set_ylabel('Frequency', fontsize=12)\naxes[0].grid(axis='y', alpha=0.3)\n\n# Plot Betweenness Centrality\naxes[1].hist(wn_q_nodes['betweenness_centrality'], bins=100, edgecolor='black', alpha=0.7)\naxes[1].set_title('Betweenness Centrality Distribution', fontsize=14, fontweight='bold')\naxes[1].set_xlabel('Betweenness Centrality', fontsize=12)\naxes[1].set_ylabel('Frequency', fontsize=12)\naxes[1].grid(axis='y', alpha=0.3)\n\n# Plot Closeness Centrality\naxes[2].hist(wn_q_nodes['closeness_centrality'], bins=100, edgecolor='black', alpha=0.7)\naxes[2].set_title('Closeness Centrality Distribution', fontsize=14, fontweight='bold')\naxes[2].set_xlabel('Closeness Centrality', fontsize=12)\naxes[2].set_ylabel('Frequency', fontsize=12)\naxes[2].grid(axis='y', alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, axes = plt.subplots(1, 3, figsize=(18, 6))  # Plot Degree Centrality axes[0].hist(wn_q_nodes['degree_centrality'], bins=100, edgecolor='black', alpha=0.7) axes[0].set_title('Degree Centrality Distribution', fontsize=14, fontweight='bold') axes[0].set_xlabel('Degree Centrality', fontsize=12) axes[0].set_ylabel('Frequency', fontsize=12) axes[0].grid(axis='y', alpha=0.3)  # Plot Betweenness Centrality axes[1].hist(wn_q_nodes['betweenness_centrality'], bins=100, edgecolor='black', alpha=0.7) axes[1].set_title('Betweenness Centrality Distribution', fontsize=14, fontweight='bold') axes[1].set_xlabel('Betweenness Centrality', fontsize=12) axes[1].set_ylabel('Frequency', fontsize=12) axes[1].grid(axis='y', alpha=0.3)  # Plot Closeness Centrality axes[2].hist(wn_q_nodes['closeness_centrality'], bins=100, edgecolor='black', alpha=0.7) axes[2].set_title('Closeness Centrality Distribution', fontsize=14, fontweight='bold') axes[2].set_xlabel('Closeness Centrality', fontsize=12) axes[2].set_ylabel('Frequency', fontsize=12) axes[2].grid(axis='y', alpha=0.3)  plt.tight_layout() plt.show() <p>By plotting the spatial distribution as choropleth maps, we can visualize how centrality measures vary across London wards, revealing patterns of urban connectivity and importance.</p> <ul> <li><p>Degree Centrality (left) shows local connectivity, with higher values (darker colors) in densely connected central areas like the City of London and parts of Westminster, indicating wards with many adjacent neighbors. Peripheral wards have lower values, reflecting fewer connections.</p> </li> <li><p>Closeness Centrality (middle) measures accessibility, with central wards (e.g., around the Thames) scoring higher (brighter colors), as they are closer to all other wards in the network. Outlying areas show lower values, highlighting reduced overall reachability.</p> </li> <li><p>Betweenness Centrality (right) identifies bridge wards that connect different parts of London, with the highest values (darker colors) concentrated in central hubs like the City of London and key transport corridors. This pattern differs from the others by emphasizing wards that facilitate flow between regions.</p> </li> </ul> In\u00a0[44]: Copied! <pre>import matplotlib.pyplot as plt\n\n# Plot the wards with centrality measures as choropleth maps using quantile classification\nfig, axes = plt.subplots(1, 3, figsize=(18, 6), dpi=150)\n\n# Choropleth map for degree centrality\nwn_q_nodes.plot(\n    column='degree_centrality',\n    ax=axes[0],\n    cmap='plasma',\n    scheme='quantiles',\n    k=5,\n    legend=True,\n    legend_kwds={'loc': 'lower right'},\n    edgecolor='black',\n    linewidth=0.5\n)\naxes[0].set_title('London Wards - Degree Centrality (Quantiles)', fontsize=14, fontweight='bold')\naxes[0].set_axis_off()\n\n# Choropleth map for closeness centrality\nwn_q_nodes.plot(\n    column='closeness_centrality',\n    ax=axes[1],\n    cmap='inferno',\n    scheme='quantiles',\n    k=5,\n    legend=True,\n    legend_kwds={'loc': 'lower right'},\n    edgecolor='black',\n    linewidth=0.5\n)\naxes[1].set_title('London Wards - Closeness Centrality (Quantiles)', fontsize=14, fontweight='bold')\naxes[1].set_axis_off()\n\n# Choropleth map for betweenness centrality\nwn_q_nodes.plot(\n    column='betweenness_centrality',\n    ax=axes[2],\n    cmap='viridis',\n    scheme='quantiles',\n    k=5,\n    legend=True,\n    legend_kwds={'loc': 'lower right'},\n    edgecolor='black',\n    linewidth=0.5\n)\naxes[2].set_title('London Wards - Betweenness Centrality (Quantiles)', fontsize=14, fontweight='bold')\naxes[2].set_axis_off()\n\n# Add contiguity edges to all subplots for context\nfor ax in axes:\n    wn_q_edges.plot(\n        ax=ax,\n        color='gray',\n        linewidth=0.5,\n        alpha=0.5\n    )\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  # Plot the wards with centrality measures as choropleth maps using quantile classification fig, axes = plt.subplots(1, 3, figsize=(18, 6), dpi=150)  # Choropleth map for degree centrality wn_q_nodes.plot(     column='degree_centrality',     ax=axes[0],     cmap='plasma',     scheme='quantiles',     k=5,     legend=True,     legend_kwds={'loc': 'lower right'},     edgecolor='black',     linewidth=0.5 ) axes[0].set_title('London Wards - Degree Centrality (Quantiles)', fontsize=14, fontweight='bold') axes[0].set_axis_off()  # Choropleth map for closeness centrality wn_q_nodes.plot(     column='closeness_centrality',     ax=axes[1],     cmap='inferno',     scheme='quantiles',     k=5,     legend=True,     legend_kwds={'loc': 'lower right'},     edgecolor='black',     linewidth=0.5 ) axes[1].set_title('London Wards - Closeness Centrality (Quantiles)', fontsize=14, fontweight='bold') axes[1].set_axis_off()  # Choropleth map for betweenness centrality wn_q_nodes.plot(     column='betweenness_centrality',     ax=axes[2],     cmap='viridis',     scheme='quantiles',     k=5,     legend=True,     legend_kwds={'loc': 'lower right'},     edgecolor='black',     linewidth=0.5 ) axes[2].set_title('London Wards - Betweenness Centrality (Quantiles)', fontsize=14, fontweight='bold') axes[2].set_axis_off()  # Add contiguity edges to all subplots for context for ax in axes:     wn_q_edges.plot(         ax=ax,         color='gray',         linewidth=0.5,         alpha=0.5     )  plt.tight_layout() plt.show() <p><code>group_nodes</code> function can generate spatial relationships between polygon geometries (e.g., administrative boundaries like wards) and point geometries (e.g., bus stations) based on spatial predicates. It creates directed edges from polygons to points that satisfy the specified predicate, enabling analysis of hierarchical or containment-based graphs. This is particularly useful for modeling relationships where points are contained within polygons, such as POIs within administrative boundaries.</p> In\u00a0[45]: Copied! <pre># Generate proximity edges between wards (polygons) and bus stations (points) using group_nodes\nproximity_nodes, proximity_edges = c2g.group_nodes(\n    wn_q_nodes,  # polygons_gdf (wards)\n    travel_summary_nodes,  # points_gdf (bus stations)\n    distance_metric=\"euclidean\", # Distance metric\n    predicate=\"covered_by\"  # Default predicate for containment\n)\n\nprint(\"Generated edge types:\")\nfor edge_key in proximity_edges.keys():\n    print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_edges[edge_key])} edges\")\n</pre> # Generate proximity edges between wards (polygons) and bus stations (points) using group_nodes proximity_nodes, proximity_edges = c2g.group_nodes(     wn_q_nodes,  # polygons_gdf (wards)     travel_summary_nodes,  # points_gdf (bus stations)     distance_metric=\"euclidean\", # Distance metric     predicate=\"covered_by\"  # Default predicate for containment )  print(\"Generated edge types:\") for edge_key in proximity_edges.keys():     print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_edges[edge_key])} edges\")  <pre>Generated edge types:\n  polygon \u2192 point: 20220 edges\n</pre> <p>As seen in the visualization below, the point nodes are grouped by the polygon nodes, constructing edges between them.</p> In\u00a0[46]: Copied! <pre># Plot the proximity graph with enhanced styling and beautiful colors\nfig, ax = plt.subplots(1, 1, figsize=(16, 14))\n\n# Create dictionaries for plotting\nplot_nodes = {\n    'wards': proximity_nodes['polygon'],\n    'bus_stations': proximity_nodes['point']\n}\n\nplot_edges = {\n    ('wards', 'covers', 'bus_stations'): proximity_edges[('polygon', 'covers', 'point')]\n}\n\nc2g.plot_graph(\n    nodes=plot_nodes,\n    edges=plot_edges,\n    ax=ax,\n    node_color={\n        'wards': '#F8F9FA',\n        'bus_stations': '#3498DB'\n    },\n    node_edgecolor={\n        'wards': '#495057', \n        'bus_stations': 'white'\n    },\n    node_alpha={\n        'wards': 0.4,\n        'bus_stations': 0.8\n    },\n    markersize={'bus_stations': 8},\n    edge_color='#2980B9',\n    edge_linewidth=0.3,\n    edge_alpha=1,\n    bgcolor=\"white\"\n)\n\n# Add centroids of polygons with black 'x' markers\ncentroids = proximity_nodes['polygon'].centroid\nax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, label='Ward Centroids')\n\n# Add basemap with a clean, modern style\nctx.add_basemap(ax, crs=proximity_nodes['polygon'].crs, source=ctx.providers.CartoDB.Positron)\n\n# Enhanced title and styling\nax.set_title('London Ward-Bus Station Proximity Graph (Euclidean Distance)', \n             fontsize=18, fontweight='bold', pad=25, color='#2C3E50')\n\n# Beautiful legend with custom styling\nlegend = ax.legend(\n    loc='upper right', \n    fontsize=13, \n    framealpha=0.95,\n    fancybox=True,\n    shadow=True,\n    edgecolor='#34495E',\n    facecolor='white'\n)\nlegend.get_frame().set_linewidth(1.5)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add subtle border around the plot\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the proximity graph with enhanced styling and beautiful colors fig, ax = plt.subplots(1, 1, figsize=(16, 14))  # Create dictionaries for plotting plot_nodes = {     'wards': proximity_nodes['polygon'],     'bus_stations': proximity_nodes['point'] }  plot_edges = {     ('wards', 'covers', 'bus_stations'): proximity_edges[('polygon', 'covers', 'point')] }  c2g.plot_graph(     nodes=plot_nodes,     edges=plot_edges,     ax=ax,     node_color={         'wards': '#F8F9FA',         'bus_stations': '#3498DB'     },     node_edgecolor={         'wards': '#495057',          'bus_stations': 'white'     },     node_alpha={         'wards': 0.4,         'bus_stations': 0.8     },     markersize={'bus_stations': 8},     edge_color='#2980B9',     edge_linewidth=0.3,     edge_alpha=1,     bgcolor=\"white\" )  # Add centroids of polygons with black 'x' markers centroids = proximity_nodes['polygon'].centroid ax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, label='Ward Centroids')  # Add basemap with a clean, modern style ctx.add_basemap(ax, crs=proximity_nodes['polygon'].crs, source=ctx.providers.CartoDB.Positron)  # Enhanced title and styling ax.set_title('London Ward-Bus Station Proximity Graph (Euclidean Distance)',               fontsize=18, fontweight='bold', pad=25, color='#2C3E50')  # Beautiful legend with custom styling legend = ax.legend(     loc='upper right',      fontsize=13,      framealpha=0.95,     fancybox=True,     shadow=True,     edgecolor='#34495E',     facecolor='white' ) legend.get_frame().set_linewidth(1.5)  ax.set_aspect('equal') ax.axis('off')  # Add subtle border around the plot for spine in ax.spines.values():     spine.set_visible(False)  plt.tight_layout() plt.show() In\u00a0[\u00a0]: Copied! <pre>G_streets = ox.graph_from_place(\"Greater London, UK\", network_type=\"all\")\n\nstreet_nodes, street_edges = c2g.nx_to_gdf(G_streets)\nstreet_edges.to_crs(epsg=27700, inplace=True)\n</pre> G_streets = ox.graph_from_place(\"Greater London, UK\", network_type=\"all\")  street_nodes, street_edges = c2g.nx_to_gdf(G_streets) street_edges.to_crs(epsg=27700, inplace=True) In\u00a0[41]: Copied! <pre># Generate proximity edges between wards (polygons) and bus stations (points) using group_nodes\nproximity_net_nodes, proximity_net_edges = c2g.group_nodes(\n    wn_q_nodes,  # polygons_gdf (wards)\n    travel_summary_nodes,  # points_gdf (bus stations)\n    distance_metric=\"network\", # Network distance metric\n    network_gdf=street_edges,  # Network for distance calculations (not used for containment\n    predicate=\"covered_by\"  # Default predicate for containment\n)\n\nprint(\"Generated edge types:\")\nfor edge_key in proximity_net_edges.keys():\n    print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_net_edges[edge_key])} edges\")\n</pre> # Generate proximity edges between wards (polygons) and bus stations (points) using group_nodes proximity_net_nodes, proximity_net_edges = c2g.group_nodes(     wn_q_nodes,  # polygons_gdf (wards)     travel_summary_nodes,  # points_gdf (bus stations)     distance_metric=\"network\", # Network distance metric     network_gdf=street_edges,  # Network for distance calculations (not used for containment     predicate=\"covered_by\"  # Default predicate for containment )  print(\"Generated edge types:\") for edge_key in proximity_net_edges.keys():     print(f\"  {edge_key[0]} \u2192 {edge_key[2]}: {len(proximity_net_edges[edge_key])} edges\") <pre>Generated edge types:\n  polygon \u2192 point: 20220 edges\n</pre> In\u00a0[42]: Copied! <pre># Plot the proximity graph with enhanced styling and beautiful colors\nfig, ax = plt.subplots(1, 1, figsize=(16, 14))\n\n# Use c2g.plot_graph for consistent styling\nc2g.plot_graph(\n    nodes=proximity_net_nodes,\n    edges=proximity_net_edges,\n    ax=ax,\n    node_color={\n        'polygon': '#F8F9FA',\n        'point': '#3498DB'\n    },\n    node_edgecolor={\n        'polygon': '#495057',\n        'point': 'white'\n    },\n    node_alpha={\n        'polygon': 0.4,\n        'point': 0.8\n    },\n    markersize={'point': 8},\n    edge_color='#2980B9',\n    edge_linewidth=0.3,\n    edge_alpha=1,\n    bgcolor=\"white\"\n)\n\n# Add centroids of polygons with black 'x' markers\ncentroids = proximity_net_nodes['polygon'].centroid\nax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, label='Ward Centroids')\n\n# Add basemap with a clean, modern style\nctx.add_basemap(ax, crs=proximity_net_nodes['polygon'].crs, source=ctx.providers.CartoDB.Positron)\n\n# Enhanced title and styling\nax.set_title('London Ward-Bus Station Proximity Graph (Network Distance)', \n             fontsize=18, fontweight='bold', pad=25, color='#2C3E50')\n\n# Beautiful legend with custom styling\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='s', color='w', label='London Wards',\n           markerfacecolor='#F8F9FA', markersize=10, markeredgecolor='#495057', alpha=0.4),\n    Line2D([0], [0], marker='o', color='w', label='Bus Stations',\n           markerfacecolor='#3498DB', markersize=8, markeredgecolor='white', alpha=0.8),\n    Line2D([0], [0], color='#2980B9', lw=0.3, label='Ward-Station Connections'),\n    Line2D([0], [0], marker='o', color='w', label='Ward Centroids',\n           markerfacecolor='black', markersize=5, alpha=0.8)\n]\nlegend = ax.legend(\n    handles=legend_elements,\n    loc='upper right', \n    fontsize=13, \n    framealpha=0.95,\n    fancybox=True,\n    shadow=True,\n    edgecolor='#34495E',\n    facecolor='white'\n)\nlegend.get_frame().set_linewidth(1.5)\n\nax.set_aspect('equal')\nax.set_axis_off()\n\n# Add subtle border around the plot\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the proximity graph with enhanced styling and beautiful colors fig, ax = plt.subplots(1, 1, figsize=(16, 14))  # Use c2g.plot_graph for consistent styling c2g.plot_graph(     nodes=proximity_net_nodes,     edges=proximity_net_edges,     ax=ax,     node_color={         'polygon': '#F8F9FA',         'point': '#3498DB'     },     node_edgecolor={         'polygon': '#495057',         'point': 'white'     },     node_alpha={         'polygon': 0.4,         'point': 0.8     },     markersize={'point': 8},     edge_color='#2980B9',     edge_linewidth=0.3,     edge_alpha=1,     bgcolor=\"white\" )  # Add centroids of polygons with black 'x' markers centroids = proximity_net_nodes['polygon'].centroid ax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, label='Ward Centroids')  # Add basemap with a clean, modern style ctx.add_basemap(ax, crs=proximity_net_nodes['polygon'].crs, source=ctx.providers.CartoDB.Positron)  # Enhanced title and styling ax.set_title('London Ward-Bus Station Proximity Graph (Network Distance)',               fontsize=18, fontweight='bold', pad=25, color='#2C3E50')  # Beautiful legend with custom styling from matplotlib.lines import Line2D legend_elements = [     Line2D([0], [0], marker='s', color='w', label='London Wards',            markerfacecolor='#F8F9FA', markersize=10, markeredgecolor='#495057', alpha=0.4),     Line2D([0], [0], marker='o', color='w', label='Bus Stations',            markerfacecolor='#3498DB', markersize=8, markeredgecolor='white', alpha=0.8),     Line2D([0], [0], color='#2980B9', lw=0.3, label='Ward-Station Connections'),     Line2D([0], [0], marker='o', color='w', label='Ward Centroids',            markerfacecolor='black', markersize=5, alpha=0.8) ] legend = ax.legend(     handles=legend_elements,     loc='upper right',      fontsize=13,      framealpha=0.95,     fancybox=True,     shadow=True,     edgecolor='#34495E',     facecolor='white' ) legend.get_frame().set_linewidth(1.5)  ax.set_aspect('equal') ax.set_axis_off()  # Add subtle border around the plot for spine in ax.spines.values():     spine.set_visible(False)  plt.tight_layout() plt.show() <p>The outputs from <code>group_nodes</code> can be used for constructing a heterogeneous graph where multiple types of nodes and edges coexist. Especially for for <code>torch_geometric</code>, <code>gdf_to_pyg</code> (or if converted to <code>nx</code> objects: <code>nx_to_pyg</code>) supports such operations:</p> In\u00a0[47]: Copied! <pre># Combine nodes and edges into dictionaries for heterogeneous graph\ncombined_nodes = {\n    'wards': proximity_nodes[\"polygon\"],\n    'bus_stations': proximity_nodes[\"point\"]\n}\n\ncombined_edges = {\n    ('wards', 'is_contiguous_with', 'wards'): wn_q_edges,\n    ('wards', 'covers', 'bus_stations'): proximity_edges[('polygon', 'covers', 'point')],\n    ('bus_stations', 'connects', 'bus_stations'): travel_summary_edges\n}\n\n# Create heterogeneous graph using city2graph\nwards_bus_hetero_data = c2g.gdf_to_pyg(combined_nodes, combined_edges)\n\nprint(\"Combined Heterogeneous Graph Structure:\")\nprint(wards_bus_hetero_data)\nprint(\"\\nNode types and their counts:\")\nfor node_type in wards_bus_hetero_data.node_types:\n    print(f\"  {node_type}: {wards_bus_hetero_data[node_type].x.shape[0]} nodes\")\nprint(\"\\nEdge types and their counts:\")\nfor edge_type in wards_bus_hetero_data.edge_types:\n    print(f\"  {edge_type}: {wards_bus_hetero_data[edge_type].edge_index.shape[1]} edges\")\n</pre> # Combine nodes and edges into dictionaries for heterogeneous graph combined_nodes = {     'wards': proximity_nodes[\"polygon\"],     'bus_stations': proximity_nodes[\"point\"] }  combined_edges = {     ('wards', 'is_contiguous_with', 'wards'): wn_q_edges,     ('wards', 'covers', 'bus_stations'): proximity_edges[('polygon', 'covers', 'point')],     ('bus_stations', 'connects', 'bus_stations'): travel_summary_edges }  # Create heterogeneous graph using city2graph wards_bus_hetero_data = c2g.gdf_to_pyg(combined_nodes, combined_edges)  print(\"Combined Heterogeneous Graph Structure:\") print(wards_bus_hetero_data) print(\"\\nNode types and their counts:\") for node_type in wards_bus_hetero_data.node_types:     print(f\"  {node_type}: {wards_bus_hetero_data[node_type].x.shape[0]} nodes\") print(\"\\nEdge types and their counts:\") for edge_type in wards_bus_hetero_data.edge_types:     print(f\"  {edge_type}: {wards_bus_hetero_data[edge_type].edge_index.shape[1]} edges\") <pre>Combined Heterogeneous Graph Structure:\nHeteroData(\n  crs=EPSG:27700,\n  graph_metadata=&lt;city2graph.base.GraphMetadata object at 0x3dc65bee0&gt;,\n  wards={\n    x=[633, 0],\n    pos=[633, 2],\n  },\n  bus_stations={\n    x=[20220, 0],\n    pos=[20220, 2],\n  },\n  (wards, is_contiguous_with, wards)={\n    edge_index=[2, 1865],\n    edge_attr=[1865, 0],\n  },\n  (wards, covers, bus_stations)={\n    edge_index=[2, 20220],\n    edge_attr=[20220, 0],\n  },\n  (bus_stations, connects, bus_stations)={\n    edge_index=[2, 25182],\n    edge_attr=[25182, 0],\n  }\n)\n\nNode types and their counts:\n  wards: 633 nodes\n  bus_stations: 20220 nodes\n\nEdge types and their counts:\n  ('wards', 'is_contiguous_with', 'wards'): 1865 edges\n  ('wards', 'covers', 'bus_stations'): 20220 edges\n  ('bus_stations', 'connects', 'bus_stations'): 25182 edges\n</pre> <p>This heterogeneous graph could be visualized as follows:</p> In\u00a0[58]: Copied! <pre># Plot the combined heterogeneous graph with enhanced styling and beautiful colors\nfig, ax = plt.subplots(1, 1, figsize=(16, 14))\n\n# Use built-in plot_graph for heterogeneous graph plotting\nc2g.plot_graph(\n    nodes=combined_nodes,\n    edges=combined_edges,\n    ax=ax,\n    node_color={\n        'wards': '#F8F9FA',\n        'bus_stations': '#3498DB'\n    },\n    node_edgecolor={\n        'wards': '#495057',\n        'bus_stations': 'white'\n    },\n    node_alpha={\n        'wards': 0.4,\n        'bus_stations': 0.8\n    },\n    markersize={'bus_stations': 8},\n    edge_color={\n        ('wards', 'is_contiguous_with', 'wards'): 'black',\n        ('wards', 'covers', 'bus_stations'): 'blue',\n        ('bus_stations', 'connects', 'bus_stations'): 'gray' # Add valid color if needed, or it will use default\n    },\n    edge_linewidth={\n        ('wards', 'is_contiguous_with', 'wards'): 0.5,\n        ('wards', 'covers', 'bus_stations'): 0.3\n    },\n    edge_alpha={\n        ('wards', 'is_contiguous_with', 'wards'): 0.8,\n        ('wards', 'covers', 'bus_stations'): 1\n    },\n    bgcolor=\"white\",\n    subplots=False\n)\n\n# Add centroids of polygons with black 'x' markers\ncentroids = combined_nodes['wards'].centroid\nax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, marker='x', label='Ward Centroids')\n\n# Add basemap with a clean, modern style\nctx.add_basemap(ax, crs=combined_nodes['wards'].crs, source=ctx.providers.CartoDB.Positron)\n\n# Enhanced title and styling\nax.set_title('London Ward-Bus Station Proximity Graph with Ward Contiguity', \n             fontsize=18, fontweight='bold', pad=25, color='#2C3E50')\n\n# Beautiful legend with custom styling\nlegend = ax.legend(\n    loc='upper right', \n    fontsize=13, \n    framealpha=0.95,\n    fancybox=True,\n    shadow=True,\n    edgecolor='#34495E',\n    facecolor='white'\n)\nlegend.get_frame().set_linewidth(1.5)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add subtle border around the plot\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n\nplt.tight_layout()\nplt.show()\n</pre> # Plot the combined heterogeneous graph with enhanced styling and beautiful colors fig, ax = plt.subplots(1, 1, figsize=(16, 14))  # Use built-in plot_graph for heterogeneous graph plotting c2g.plot_graph(     nodes=combined_nodes,     edges=combined_edges,     ax=ax,     node_color={         'wards': '#F8F9FA',         'bus_stations': '#3498DB'     },     node_edgecolor={         'wards': '#495057',         'bus_stations': 'white'     },     node_alpha={         'wards': 0.4,         'bus_stations': 0.8     },     markersize={'bus_stations': 8},     edge_color={         ('wards', 'is_contiguous_with', 'wards'): 'black',         ('wards', 'covers', 'bus_stations'): 'blue',         ('bus_stations', 'connects', 'bus_stations'): 'gray' # Add valid color if needed, or it will use default     },     edge_linewidth={         ('wards', 'is_contiguous_with', 'wards'): 0.5,         ('wards', 'covers', 'bus_stations'): 0.3     },     edge_alpha={         ('wards', 'is_contiguous_with', 'wards'): 0.8,         ('wards', 'covers', 'bus_stations'): 1     },     bgcolor=\"white\",     subplots=False )  # Add centroids of polygons with black 'x' markers centroids = combined_nodes['wards'].centroid ax.scatter(centroids.x, centroids.y, color='black', s=20, alpha=0.8, marker='x', label='Ward Centroids')  # Add basemap with a clean, modern style ctx.add_basemap(ax, crs=combined_nodes['wards'].crs, source=ctx.providers.CartoDB.Positron)  # Enhanced title and styling ax.set_title('London Ward-Bus Station Proximity Graph with Ward Contiguity',               fontsize=18, fontweight='bold', pad=25, color='#2C3E50')  # Beautiful legend with custom styling legend = ax.legend(     loc='upper right',      fontsize=13,      framealpha=0.95,     fancybox=True,     shadow=True,     edgecolor='#34495E',     facecolor='white' ) legend.get_frame().set_linewidth(1.5)  ax.set_aspect('equal') ax.axis('off')  # Add subtle border around the plot for spine in ax.spines.values():     spine.set_visible(False)  plt.tight_layout() plt.show()"},{"location":"examples/generating_graphs_by_proximity.html#generating-various-types-of-graphs-by-proximity","title":"Generating Various Types of Graphs by Proximity\u00b6","text":"<p>This notebook illustrates how to generate and visualize different spatial graph types based on proximity metrics (KNN, Delaunay, Gilbert, Waxman) using City2Graph, OSMnx, and NetworkX.</p>"},{"location":"examples/generating_graphs_by_proximity.html#overview","title":"Overview\u00b6","text":"<p>This notebook covers:</p> <ul> <li>Setting up the environment and importing libraries</li> <li>Retrieving points of interest around a location</li> <li>Defining helper functions for node extraction and plotting</li> <li>Generating and visualizing KNN, Delaunay, Gilbert, and Waxman graphs interactively</li> </ul>"},{"location":"examples/generating_graphs_by_proximity.html#1-setup-and-environment","title":"1. Setup and Environment\u00b6","text":""},{"location":"examples/generating_graphs_by_proximity.html#2-retrieve-points-of-interest","title":"2. Retrieve Points of Interest\u00b6","text":"<p>Fetch restaurant POIs around Shibuya, Tokyo using OSMnx and filter to nodes only. Also, streets network is obtained for calculating network distances.</p>"},{"location":"examples/generating_graphs_by_proximity.html#3-k-nearest-neighbors-knn-graph","title":"3. K-Nearest Neighbors (KNN) Graph\u00b6","text":"<p>Create an interactive slider to plot KNN graphs for varying $k$ values. You can specify the distance metric from <code>\"manhattan\"</code>, <code>\"euclidean\"</code>,  and <code>\"network\"</code>. If you use network distance, you need to set the GeoDataFrame of network. You can save the output as GeoDataFrame or nx.Graph.</p>"},{"location":"examples/generating_graphs_by_proximity.html#5-delaunay-graph","title":"5. Delaunay Graph\u00b6","text":"<p>Generate and plot a Delaunay triangulation graph of the POIs.</p>"},{"location":"examples/generating_graphs_by_proximity.html#6-fixed-threshold-graph-gilbert-graph","title":"6. Fixed Threshold Graph (Gilbert Graph)\u00b6","text":"<p>Fixed Threshold Graph is a deterministic model to generate edges based on the Euclidean distance (Gilbert Graph is a generalised concept assuming points are randomly assigned). Given a parameter $r$ as radious, neighbours are connected if they are within the radious from a node.</p>"},{"location":"examples/generating_graphs_by_proximity.html#7-waxman-graph-soft-random-geometry-model","title":"7. Waxman Graph (Soft Random Geometry Model)\u00b6","text":"<p>Waxman graph with adjustable $r_0$ (<code>r_0</code>) and $\\beta$ (<code>beta</code>) as parameters. The probability of connection follows below: $$H_{ij} = \\beta e^{-\\frac{d_{ij}}{r_0}}$$</p> <p>where $d_{ij}$ is the Euclidean distance between node $i$ an $j$; $r_0$ is the maximum distance between nodes; and $\\beta$ denotes the scaling parameter.</p>"},{"location":"examples/generating_graphs_by_proximity.html#other-available-proximity-graph-types","title":"Other Available Proximity Graph Types\u00b6","text":"<p>The c2g library provides several additional proximity-based graph generation methods beyond the ones demonstrated above:</p>"},{"location":"examples/generating_graphs_by_proximity.html#euclidean-minimum-spanning-tree-emst","title":"Euclidean Minimum Spanning Tree (EMST)\u00b6","text":"<p>Creates a tree that connects all nodes with the minimum total edge weight using Euclidean distances. This ensures all nodes are connected with the fewest possible edges while minimizing total distance.</p>"},{"location":"examples/generating_graphs_by_proximity.html#gabriel-graph","title":"Gabriel Graph\u00b6","text":"<p>Two nodes are connected if no other node lies within the circle having these two nodes as diameter endpoints. This creates a sparser graph than Delaunay triangulation while maintaining good connectivity properties.</p>"},{"location":"examples/generating_graphs_by_proximity.html#relative-neighborhood-graph-rng","title":"Relative Neighborhood Graph (RNG)\u00b6","text":"<p>Two nodes are connected if no other node is closer to both nodes than they are to each other. This creates an even sparser graph than Gabriel graph, often used in computational geometry and network analysis.</p>"},{"location":"examples/generating_graphs_by_proximity.html#key-characteristics","title":"Key Characteristics\u00b6","text":"<ul> <li>EMST: Guarantees connectivity with minimum total cost; useful for infrastructure planning</li> <li>Gabriel Graph: Good balance between sparsity and connectivity; useful for wireless networks</li> <li>RNG: Sparsest among proximity graphs; useful for identifying strongest local relationships</li> <li>Fixed Radius: Already demonstrated; creates connections within a specified distance threshold</li> </ul>"},{"location":"examples/generating_graphs_by_proximity.html#comparison-of-graph-sparsity","title":"Comparison of Graph Sparsity\u00b6","text":"<p>In terms of edge density (from most to least dense):</p> <ol> <li>Delaunay - Most edges, captures all proximity relationships</li> <li>Gabriel - Subset of Delaunay, removes longer edges in dense areas</li> <li>RNG - Subset of Gabriel, keeps only the strongest local connections</li> <li>EMST - Sparsest connected graph, exactly n-1 edges for n nodes</li> </ol> <p>These different graph types are particularly useful for modeling different types of spatial relationships and constraints in urban networks.</p>"},{"location":"examples/generating_graphs_by_proximity.html#8-bridge-nodes-multi-layer-networks","title":"8. Bridge Nodes (Multi-layer Networks)\u00b6","text":"<p>The <code>bridge_nodes</code> function creates directed proximity edges between different layers of nodes, enabling multi-layer network analysis. This is particularly useful for modeling complex urban systems where different types of entities (e.g., schools, hospitals, parks) interact with each other.</p> <p>The function generates directed edges from every node in one layer to their nearest neighbors in another layer, using either KNN or fixed-radius methods.</p>"},{"location":"examples/generating_graphs_by_proximity.html#9-contiguity-graph-spatial-weights-matrix","title":"9. Contiguity Graph (Spatial Weights Matrix)\u00b6","text":"<p><code>contiguity_graph</code> creates spatial networks from polygon geometries based on adjacency relationships. Unlike point-based proximity graphs, contiguity graphs connect polygons that share boundaries, making them essential for analyzing administrative boundaries, urban districts, land parcels, and other areal units.</p> <p>This approach is particularly valuable for:</p> <ul> <li>Urban planning: Analyzing connectivity between neighborhoods, districts, or zones</li> <li>Administrative analysis: Understanding relationships between electoral districts, census areas, or municipal boundaries</li> <li>Land use studies: Examining adjacency patterns in zoning, parcels, or development areas</li> <li>Spatial autocorrelation: Measuring how attributes cluster across contiguous geographic units</li> <li>Network analysis of regions: Computing centrality measures for administrative or natural areas</li> </ul> <p>The function supports two contiguity rules:</p> <ul> <li>Queen contiguity: Polygons sharing any boundary (edges or vertices) are connected</li> <li>Rook contiguity: Only polygons sharing edges (not just corner points) are connected</li> </ul>"},{"location":"examples/generating_graphs_by_proximity.html#loading-sample-data","title":"Loading Sample Data\u00b6","text":"<p>First, let's load a real-world dataset of London administrative wards to demonstrate contiguity analysis on actual geographic boundaries. This dataset provides an excellent example of how <code>contiguity_graph</code> works with complex administrative polygons that have realistic adjacency patterns.</p> <p>The <code>contiguity_graph</code> function is specifically designed to handle polygon data and uses libpysal's robust spatial weights functionality to accurately determine which polygons are neighbors based on shared boundaries.</p>"},{"location":"examples/generating_graphs_by_proximity.html#generating-queen-and-rook-contiguity-graphs","title":"Generating Queen and Rook Contiguity Graphs\u00b6","text":"<p>Now we'll create both Queen and Rook contiguity graphs from the London wards data. The <code>contiguity_graph</code> function leverages libpysal's robust spatial weights functionality to accurately determine adjacency relationships between polygons, making it highly reliable for complex geographic data.</p> <p>Key differences between contiguity rules:</p> <ul> <li>Queen contiguity typically produces more edges since it considers both edge and vertex adjacency (like a chess queen's movement)</li> <li>Rook contiguity is more restrictive, only connecting polygons that share actual boundary edges (like a chess rook's movement)</li> </ul> <p>This distinction is crucial for different types of spatial analysis - Queen contiguity captures more nuanced neighborhood relationships, while Rook contiguity focuses on direct physical connections.</p>"},{"location":"examples/generating_graphs_by_proximity.html#computing-network-centrality-measures","title":"Computing Network Centrality Measures\u00b6","text":"<p>One of the key advantages of contiguity graphs is their ability to reveal the structural importance of different geographic units through network centrality measures. The <code>contiguity_graph</code> function seamlessly integrates with NetworkX, enabling sophisticated spatial network analysis.</p> <p>Here we compute three fundamental centrality metrics that provide different insights into urban structure:</p> <ul> <li>Degree centrality: Measures how many neighbors each ward has (local connectivity) - identifies areas with many adjacent districts</li> <li>Betweenness centrality: Identifies wards that serve as bridges between different parts of London - crucial for understanding urban connectivity patterns</li> <li>Closeness centrality: Measures how easily accessible each ward is from all other wards - important for accessibility analysis</li> </ul> <p>These metrics can be easily calculated using NetworkX, and c2g enables smooth transitions between NetworkX graphs and GeoPandas objects through the <code>nx_to_gdf</code> function, making spatial analysis workflows highly efficient.</p>"},{"location":"examples/generating_graphs_by_proximity.html#10-group-nodes","title":"10. Group Nodes\u00b6","text":""},{"location":"examples/generating_graphs_by_proximity.html#key-features","title":"Key Features:\u00b6","text":"<ul> <li>Spatial Predicates: Supports predicates like <code>\"covered_by\"</code> (default), <code>\"intersects\"</code>, <code>\"within\"</code>, etc., to define how points relate to polygons.</li> <li>Distance Metrics: Can incorporate distance calculations (e.g., <code>\"euclidean\"</code>, <code>\"manhattan\"</code>, <code>\"network\"</code>) when a network GeoDataFrame is provided, though primarily used for containment-based relationships.</li> <li>Output: Returns dictionaries of nodes and edges, compatible with heterogeneous graph construction for PyTorch Geometric.</li> <li>Applications: Ideal for urban planning, accessibility analysis, and multi-scale network modeling where polygon-point interactions are key.</li> </ul>"},{"location":"examples/generating_graphs_by_proximity.html#grouping-by-euclidean-distance","title":"Grouping by Euclidean Distance\u00b6","text":"<p>For the demonstration, we use the previous outputs of nodes from queen-based contiguity graph (polygon: wards) and travel summary graph (point: bus station). In this case, <code>distance_metric=euclidean</code> is chosen for the distance calculation.</p>"},{"location":"examples/generating_graphs_by_proximity.html#grouping-by-network-distance","title":"Grouping by Network Distance\u00b6","text":"<p>We can use network distance for the calculation of <code>group_nodes</code>, in the same way as the other functions in <code>proximity.py</code>. In this case, we use streets from OpenStreetMap via <code>osmnx</code>.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html","title":"OD Matrix","text":"In\u00a0[1]: Copied! <pre># Imports\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport city2graph as c2g\nplt.rcParams[\"figure.figsize\"] = (10, 8)\n</pre> # Imports import numpy as np import pandas as pd import geopandas as gpd import networkx as nx import matplotlib.pyplot as plt import city2graph as c2g plt.rcParams[\"figure.figsize\"] = (10, 8) In\u00a0[2]: Copied! <pre># Sixteen zones as a 4x4 grid of square cells (polygons) with explicit ids\nfrom shapely.geometry import box\ncells = []\nids = []\n# Iterate rows (y) and columns (x) to build 1x1 degree squares\nfor i in range(4):      # rows (y = 0..3)\n    for j in range(4):  # cols (x = 0..3)\n        cells.append(box(j, i, j + 1, i + 1))\n        ids.append(f\"G{j}{i}\")  # e.g., G00, G10, ..., G33\nzones_gdf = gpd.GeoDataFrame({\"zone_id\": ids}, geometry=cells, crs=\"EPSG:4326\")\nzones_gdf.head()\n</pre> # Sixteen zones as a 4x4 grid of square cells (polygons) with explicit ids from shapely.geometry import box cells = [] ids = [] # Iterate rows (y) and columns (x) to build 1x1 degree squares for i in range(4):      # rows (y = 0..3)     for j in range(4):  # cols (x = 0..3)         cells.append(box(j, i, j + 1, i + 1))         ids.append(f\"G{j}{i}\")  # e.g., G00, G10, ..., G33 zones_gdf = gpd.GeoDataFrame({\"zone_id\": ids}, geometry=cells, crs=\"EPSG:4326\") zones_gdf.head() Out[2]: zone_id geometry 0 G00 POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0)) 1 G10 POLYGON ((2 0, 2 1, 1 1, 1 0, 2 0)) 2 G20 POLYGON ((3 0, 3 1, 2 1, 2 0, 3 0)) 3 G30 POLYGON ((4 0, 4 1, 3 1, 3 0, 4 0)) 4 G01 POLYGON ((1 1, 1 2, 0 2, 0 1, 1 1)) In\u00a0[3]: Copied! <pre># Edge list with single weight column using grid zone ids (subset for clarity)\nE = pd.DataFrame({\n    \"source\": [\"G00\", \"G00\", \"G10\", \"G01\", \"G22\", \"G23\", \"G12\"],\n    \"target\": [\"G10\", \"G01\", \"G11\", \"G11\", \"G32\", \"G33\", \"G22\"],\n    \"flow\":   [5,     2,     3,     7,     4,     6,     5],\n})\nnodes_gdf1, edges_gdf1 = c2g.od_matrix_to_graph(\n    E, zones_gdf, zone_id_col=\"zone_id\",\n    matrix_type=\"edgelist\",\n    source_col=\"source\", target_col=\"target\",\n    weight_cols=[\"flow\"],\n    threshold=None,             # drop zeros only\n    include_self_loops=False,\n    compute_edge_geometry=True,\n    directed=True,\n    as_nx=False,\n )\n</pre> # Edge list with single weight column using grid zone ids (subset for clarity) E = pd.DataFrame({     \"source\": [\"G00\", \"G00\", \"G10\", \"G01\", \"G22\", \"G23\", \"G12\"],     \"target\": [\"G10\", \"G01\", \"G11\", \"G11\", \"G32\", \"G33\", \"G22\"],     \"flow\":   [5,     2,     3,     7,     4,     6,     5], }) nodes_gdf1, edges_gdf1 = c2g.od_matrix_to_graph(     E, zones_gdf, zone_id_col=\"zone_id\",     matrix_type=\"edgelist\",     source_col=\"source\", target_col=\"target\",     weight_cols=[\"flow\"],     threshold=None,             # drop zeros only     include_self_loops=False,     compute_edge_geometry=True,     directed=True,     as_nx=False,  ) <pre>/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:135: UserWarning: Geographic CRS detected; distance/length measures may be inaccurate (requirement 3.5)\n  _validate_crs(zones_gdf)\n/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:1101: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  centroids = zones_gdf.geometry.centroid\n</pre> <p>The function returns two GeoDataFrames: <code>nodes_gdf1</code> contains the zone geometries, and <code>edges_gdf1</code> contains the flow edges with geometries connecting zone centroids.</p> In\u00a0[4]: Copied! <pre>edges_gdf1.head()\n</pre> edges_gdf1.head() Out[4]: weight flow geometry source target G00 G01 2 2 LINESTRING (0.5 0.5, 0.5 1.5) G10 5 5 LINESTRING (0.5 0.5, 1.5 0.5) G01 G11 7 7 LINESTRING (0.5 1.5, 1.5 1.5) G10 G11 3 3 LINESTRING (1.5 0.5, 1.5 1.5) G12 G22 5 5 LINESTRING (1.5 2.5, 2.5 2.5) In\u00a0[46]: Copied! <pre># Quick plot of nodes (grid cells) and edges\nax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8)\nc2g.plot_graph(\n    nodes=nodes_gdf1.set_geometry(nodes_gdf1.centroid),\n    edges=edges_gdf1,\n    ax=ax,\n    bgcolor=\"#f8f9fa\",\n    node_color=\"#2E86AB\",\n    node_alpha=0.8,\n    markersize=20,\n    edge_color=\"#E67E22\",\n    edge_linewidth=np.log1p(edges_gdf1[\"weight\"]) * 1.2,\n)\nplt.title(\"Mock edgelist graph on 4x4 grid (directed)\")\nplt.axis(\"equal\"); plt.axis(\"off\")\nplt.show()\n</pre> # Quick plot of nodes (grid cells) and edges ax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8) c2g.plot_graph(     nodes=nodes_gdf1.set_geometry(nodes_gdf1.centroid),     edges=edges_gdf1,     ax=ax,     bgcolor=\"#f8f9fa\",     node_color=\"#2E86AB\",     node_alpha=0.8,     markersize=20,     edge_color=\"#E67E22\",     edge_linewidth=np.log1p(edges_gdf1[\"weight\"]) * 1.2, ) plt.title(\"Mock edgelist graph on 4x4 grid (directed)\") plt.axis(\"equal\"); plt.axis(\"off\") plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_20184/2848274737.py:4: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  nodes=nodes_gdf1.set_geometry(nodes_gdf1.centroid),\n</pre> In\u00a0[6]: Copied! <pre># Multi-weight undirected example on 4x4 grid (subset of pairs with reciprocals)\nE2 = pd.DataFrame({\n    \"source\": [\"G00\", \"G10\", \"G01\", \"G11\", \"G22\", \"G32\", \"G23\", \"G33\"],\n    \"target\": [\"G10\", \"G00\", \"G11\", \"G01\", \"G32\", \"G22\", \"G33\", \"G23\"],\n    \"trips\":  [5,     1,     7,     2,     4,     3,     8,     2],\n    \"cost\":   [10,    2,     12,    3,     7,     4,     15,    3],\n})\nnodes_gdf2, edges_gdf2 = c2g.od_matrix_to_graph(\n    E2, zones_gdf, zone_id_col=\"zone_id\",\n    matrix_type=\"edgelist\",\n    source_col=\"source\", target_col=\"target\",\n    weight_cols=[\"trips\", \"cost\"],\n    threshold=3, threshold_col=\"trips\",\n    include_self_loops=False,\n    compute_edge_geometry=True,\n    directed=False,  # undirected: sum reciprocals\n    as_nx=False,\n )\n</pre> # Multi-weight undirected example on 4x4 grid (subset of pairs with reciprocals) E2 = pd.DataFrame({     \"source\": [\"G00\", \"G10\", \"G01\", \"G11\", \"G22\", \"G32\", \"G23\", \"G33\"],     \"target\": [\"G10\", \"G00\", \"G11\", \"G01\", \"G32\", \"G22\", \"G33\", \"G23\"],     \"trips\":  [5,     1,     7,     2,     4,     3,     8,     2],     \"cost\":   [10,    2,     12,    3,     7,     4,     15,    3], }) nodes_gdf2, edges_gdf2 = c2g.od_matrix_to_graph(     E2, zones_gdf, zone_id_col=\"zone_id\",     matrix_type=\"edgelist\",     source_col=\"source\", target_col=\"target\",     weight_cols=[\"trips\", \"cost\"],     threshold=3, threshold_col=\"trips\",     include_self_loops=False,     compute_edge_geometry=True,     directed=False,  # undirected: sum reciprocals     as_nx=False,  ) <pre>/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:135: UserWarning: Geographic CRS detected; distance/length measures may be inaccurate (requirement 3.5)\n  _validate_crs(zones_gdf)\n/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:1101: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  centroids = zones_gdf.geometry.centroid\n</pre> In\u00a0[48]: Copied! <pre>ax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8)\nc2g.plot_graph(\n    nodes=nodes_gdf2.set_geometry(nodes_gdf2.centroid),\n    edges=edges_gdf2,\n    ax=ax,\n    bgcolor=\"#f8f9fa\",\n    node_color=\"#2E86AB\",\n    node_alpha=0.8,\n    markersize=20,\n    edge_color=\"#9B59B6\",\n    edge_linewidth=np.log1p(edges_gdf2[\"weight\"]) * 1.2,\n)\nplt.title(\"Mock edgelist graph on 4x4 grid (undirected, primary=trips)\")\nplt.axis(\"equal\"); plt.axis(\"off\")\nplt.show()\n</pre> ax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8) c2g.plot_graph(     nodes=nodes_gdf2.set_geometry(nodes_gdf2.centroid),     edges=edges_gdf2,     ax=ax,     bgcolor=\"#f8f9fa\",     node_color=\"#2E86AB\",     node_alpha=0.8,     markersize=20,     edge_color=\"#9B59B6\",     edge_linewidth=np.log1p(edges_gdf2[\"weight\"]) * 1.2, ) plt.title(\"Mock edgelist graph on 4x4 grid (undirected, primary=trips)\") plt.axis(\"equal\"); plt.axis(\"off\") plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_20184/1635354523.py:3: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  nodes=nodes_gdf2.set_geometry(nodes_gdf2.centroid),\n</pre> In\u00a0[8]: Copied! <pre># Build an adjacency DataFrame matching the 4x4 grid zone ids\nids = zones_gdf[\"zone_id\"]\n# Create a sparse 16x16 matrix with a few flows\nA = pd.DataFrame(0, index=ids, columns=ids, dtype=float)\n# add some directed flows\nA.loc[\"G00\", \"G10\"] = 5\nA.loc[\"G00\", \"G01\"] = 2\nA.loc[\"G10\", \"G11\"] = 3\nA.loc[\"G01\", \"G11\"] = 7\nA.loc[\"G22\", \"G32\"] = 4\nA.loc[\"G23\", \"G33\"] = 6\nA.loc[\"G12\", \"G22\"] = 5\nnodes_gdf3, edges_gdf3 = c2g.od_matrix_to_graph(\n    A, zones_gdf, zone_id_col=\"zone_id\",\n    matrix_type=\"adjacency\",\n    include_self_loops=False,\n    threshold=None,\n    directed=True,\n )\n</pre> # Build an adjacency DataFrame matching the 4x4 grid zone ids ids = zones_gdf[\"zone_id\"] # Create a sparse 16x16 matrix with a few flows A = pd.DataFrame(0, index=ids, columns=ids, dtype=float) # add some directed flows A.loc[\"G00\", \"G10\"] = 5 A.loc[\"G00\", \"G01\"] = 2 A.loc[\"G10\", \"G11\"] = 3 A.loc[\"G01\", \"G11\"] = 7 A.loc[\"G22\", \"G32\"] = 4 A.loc[\"G23\", \"G33\"] = 6 A.loc[\"G12\", \"G22\"] = 5 nodes_gdf3, edges_gdf3 = c2g.od_matrix_to_graph(     A, zones_gdf, zone_id_col=\"zone_id\",     matrix_type=\"adjacency\",     include_self_loops=False,     threshold=None,     directed=True,  ) <pre>/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:135: UserWarning: Geographic CRS detected; distance/length measures may be inaccurate (requirement 3.5)\n  _validate_crs(zones_gdf)\n/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:1101: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  centroids = zones_gdf.geometry.centroid\n</pre> In\u00a0[\u00a0]: Copied! <pre>ax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8)\nc2g.plot_graph(\n    nodes=nodes_gdf3.set_geometry(nodes_gdf3.centroid),\n    edges=edges_gdf3,\n    ax=ax,\n    bgcolor=\"#f8f9fa\",\n    node_color=\"#2E86AB\",\n    node_alpha=0.8, \n    markersize=20,\n    edge_color=\"#27AE60\",\n    edge_linewidth=np.log1p(edges_gdf3[\"weight\"]) * 1.2,\n)\nplt.title(\"Mock adjacency graph on 4x4 grid (directed)\")\nplt.axis(\"equal\"); plt.axis(\"off\")\nplt.show()\n</pre> ax = zones_gdf.boundary.plot(color=\"#2E86AB\", alpha=0.8, linewidth=0.8) c2g.plot_graph(     nodes=nodes_gdf3.set_geometry(nodes_gdf3.centroid),     edges=edges_gdf3,     ax=ax,     bgcolor=\"#f8f9fa\",     node_color=\"#2E86AB\",     node_alpha=0.8,      markersize=20,     edge_color=\"#27AE60\",     edge_linewidth=np.log1p(edges_gdf3[\"weight\"]) * 1.2, ) plt.title(\"Mock adjacency graph on 4x4 grid (directed)\") plt.axis(\"equal\"); plt.axis(\"off\") plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_20184/1234772101.py:3: UserWarning: Geometry is in a geographic CRS. Results from 'centroid' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.\n\n  nodes=nodes_gdf3.set_geometry(nodes_gdf3.centroid),\n</pre> In\u00a0[10]: Copied! <pre># Paths (adjust to your environment if needed)\n# Relative to repository root\nZONE_GPKG = \"../examples/data/Middle_layer_Super_Output_Areas_December_2021_Boundaries_EW_BGC_V3_-1334546435986816930.gpkg\"\nOD_CSV   = \"../examples/data/odmg/odmg01ew/ODMG01EW_MSOA.csv\"\n\nzones_london = gpd.read_file(ZONE_GPKG)\nod_london = pd.read_csv(OD_CSV)\nprint(f\"zones_london: {len(zones_london)} rows, CRS={zones_london.crs}\")\nod_london.head(3)\n</pre> # Paths (adjust to your environment if needed) # Relative to repository root ZONE_GPKG = \"../examples/data/Middle_layer_Super_Output_Areas_December_2021_Boundaries_EW_BGC_V3_-1334546435986816930.gpkg\" OD_CSV   = \"../examples/data/odmg/odmg01ew/ODMG01EW_MSOA.csv\"  zones_london = gpd.read_file(ZONE_GPKG) od_london = pd.read_csv(OD_CSV) print(f\"zones_london: {len(zones_london)} rows, CRS={zones_london.crs}\") od_london.head(3) <pre>zones_london: 7264 rows, CRS=EPSG:27700\n</pre> Out[10]: Migrant MSOA one year ago code Migrant MSOA one year ago label Middle layer Super Output Areas code Middle layer Super Output Areas label Count 0 -8 Does not apply E02000001 City of London 001 6237 1 -8 Does not apply E02000002 Barking and Dagenham 001 7622 2 -8 Does not apply E02000003 Barking and Dagenham 002 10285 In\u00a0[11]: Copied! <pre># Column mapping for ODMG dataset\nsource_col = \"Migrant MSOA one year ago code\"\ntarget_col = \"Middle layer Super Output Areas code\"\nweight_col = \"Count\"\nzone_id_col = \"MSOA21CD\"\n\nod_nodes, od_edges = c2g.od_matrix_to_graph(\n    od_london, zones_london, zone_id_col=zone_id_col,\n    matrix_type=\"edgelist\",\n    source_col=source_col, target_col=target_col,\n    weight_cols=[weight_col],\n    threshold=None,\n    include_self_loops=False,\n    compute_edge_geometry=True,\n    directed=False,\n    as_nx=False,\n )\nlen(od_nodes), len(od_edges)\n</pre> # Column mapping for ODMG dataset source_col = \"Migrant MSOA one year ago code\" target_col = \"Middle layer Super Output Areas code\" weight_col = \"Count\" zone_id_col = \"MSOA21CD\"  od_nodes, od_edges = c2g.od_matrix_to_graph(     od_london, zones_london, zone_id_col=zone_id_col,     matrix_type=\"edgelist\",     source_col=source_col, target_col=target_col,     weight_cols=[weight_col],     threshold=None,     include_self_loops=False,     compute_edge_geometry=True,     directed=False,     as_nx=False,  ) len(od_nodes), len(od_edges) <pre>/Users/yutasato/Projects/Liverpool/city2graph/city2graph/mobility.py:173: UserWarning: Dropped 36661 edges referencing unknown zone IDs (requirement 3.6)\n  aligned = _align_edgelist_zones(\n</pre> Out[11]: <pre>(7264, 1228547)</pre> In\u00a0[12]: Copied! <pre># Inspect a few rows\nod_nodes.head()\n</pre> # Inspect a few rows od_nodes.head() Out[12]: MSOA21CD MSOA21NM MSOA21NMW BNG_E BNG_N LAT LONG GlobalID geometry MSOA21CD E02000001 E02000001 City of London 001 532384 181355 51.515621 -0.093490 {71249043-B176-4306-BA6C-D1A993B1B741} MULTIPOLYGON (((532135.138 182198.131, 532071.... E02000002 E02000002 Barking and Dagenham 001 548267 189685 51.586521 0.138756 {997A80A8-0EBE-461C-91EB-3E4122571A6E} MULTIPOLYGON (((548881.563 190845.265, 548845.... E02000003 E02000003 Barking and Dagenham 002 548259 188520 51.576061 0.138149 {62DED9D9-F53A-454D-AF35-04404D9DBE9B} MULTIPOLYGON (((549102.438 189324.625, 549120.... E02000004 E02000004 Barking and Dagenham 003 551004 186412 51.556389 0.176828 {511181CD-E71F-4C63-81EE-E8E76744A627} MULTIPOLYGON (((551550.056 187364.705, 551551.... E02000005 E02000005 Barking and Dagenham 004 548733 186824 51.560692 0.144267 {B0C823EB-69E0-4AE7-9E1C-37715CF3FE87} MULTIPOLYGON (((549099.634 187656.076, 549057.... In\u00a0[13]: Copied! <pre>od_edges.head()\n</pre> od_edges.head() Out[13]: weight Count geometry source target E02000001 E02000012 1 1 LINESTRING (532485.482 181271.782, 545635.991 ... E02000024 1 1 LINESTRING (532485.482 181271.782, 524413.978 ... E02000029 1 1 LINESTRING (532485.482 181271.782, 527246.245 ... E02000030 1 1 LINESTRING (532485.482 181271.782, 522736.368 ... E02000035 3 3 LINESTRING (532485.482 181271.782, 525825.887 ... <p>We can easily calculate network properties from the graph via <code>networkx</code>.</p> In\u00a0[14]: Copied! <pre>G = c2g.gdf_to_nx(od_nodes, od_edges)\n</pre> G = c2g.gdf_to_nx(od_nodes, od_edges) In\u00a0[\u00a0]: Copied! <pre># Calculate centralities\ndegree_centrality = nx.degree_centrality(G)\n\n# Set as node attributes\nnx.set_node_attributes(G, degree_centrality, 'degree_centrality')\n\n# Convert back to GeoDataFrames\nod_nodes, od_edges = c2g.nx_to_gdf(G)\n</pre> # Calculate centralities degree_centrality = nx.degree_centrality(G)  # Set as node attributes nx.set_node_attributes(G, degree_centrality, 'degree_centrality')  # Convert back to GeoDataFrames od_nodes, od_edges = c2g.nx_to_gdf(G) In\u00a0[17]: Copied! <pre>od_nodes.head()\n</pre> od_nodes.head() Out[17]: MSOA21CD MSOA21NM MSOA21NMW BNG_E BNG_N LAT LONG GlobalID geometry degree_centrality MSOA21CD E02000001 E02000001 City of London 001 532384 181355 51.515621 -0.093490 {71249043-B176-4306-BA6C-D1A993B1B741} MULTIPOLYGON (((532135.138 182198.131, 532071.... 0.116205 E02000002 E02000002 Barking and Dagenham 001 548267 189685 51.586521 0.138756 {997A80A8-0EBE-461C-91EB-3E4122571A6E} MULTIPOLYGON (((548881.563 190845.265, 548845.... 0.039928 E02000003 E02000003 Barking and Dagenham 002 548259 188520 51.576061 0.138149 {62DED9D9-F53A-454D-AF35-04404D9DBE9B} MULTIPOLYGON (((549102.438 189324.625, 549120.... 0.061683 E02000004 E02000004 Barking and Dagenham 003 551004 186412 51.556389 0.176828 {511181CD-E71F-4C63-81EE-E8E76744A627} MULTIPOLYGON (((551550.056 187364.705, 551551.... 0.042269 E02000005 E02000005 Barking and Dagenham 004 548733 186824 51.560692 0.144267 {B0C823EB-69E0-4AE7-9E1C-37715CF3FE87} MULTIPOLYGON (((549099.634 187656.076, 549057.... 0.055349 <p>We can visualize the graph using <code>plot_graph</code>.</p> In\u00a0[\u00a0]: Copied! <pre># Filter for flows &gt;= 10\ntop_edges = od_edges[od_edges[weight_col] &gt;= 10]\n\nc2g.plot_graph(\n    nodes=zones_london.centroid,\n    edges=top_edges,\n    )\n</pre> # Filter for flows &gt;= 10 top_edges = od_edges[od_edges[weight_col] &gt;= 10]  c2g.plot_graph(     nodes=zones_london.centroid,     edges=top_edges,     ) Out[\u00a0]: <pre>&lt;Axes: &gt;</pre> <p>We can also set the edge alphas by their weights.</p> In\u00a0[\u00a0]: Copied! <pre># Compute percentile ranks for weights\npercentile_ranks = top_edges[weight_col].rank(pct=True)\n\nc2g.plot_graph(\n    nodes=zones_london.centroid,\n    edges=top_edges,\n    edge_alpha=percentile_ranks,\n    )\n</pre> # Compute percentile ranks for weights percentile_ranks = top_edges[weight_col].rank(pct=True)  c2g.plot_graph(     nodes=zones_london.centroid,     edges=top_edges,     edge_alpha=percentile_ranks,     )  Out[\u00a0]: <pre>&lt;Axes: &gt;</pre> <p>We can plot the degree centrality of the graph in parallel to the od matrix.</p> In\u00a0[54]: Copied! <pre># Create subplots: left for network, right for degree centrality\nfig, axs = plt.subplots(1, 2, figsize=(24, 12))\n\naxs[0].set_title(\"England &amp; Wales MSOA Migration Network: Flows \u226510\\n(Alpha by Percentile Rank)\", fontsize=22, color='white')\nc2g.plot_graph(\n    nodes=zones_london.centroid,\n    edges=top_edges,\n    ax=axs[0],\n    edge_alpha=percentile_ranks,\n    )\n\n# Right subplot: Degree centrality\naxs[1].set_title(\"England &amp; Wales MSOA Migration Network: Degree Centrality\\n(Migration Flows 2021 - Quantile Classification)\", fontsize=22, color='white')\nod_nodes.plot(\n    column='degree_centrality',\n    ax=axs[1],\n    cmap='viridis',\n    edgecolor='white',\n    linewidth=0.1,\n    legend=True,\n    scheme='quantiles',\n    k=4,\n    legend_kwds={'title': 'Degree Centrality (Quantiles)', 'loc': 'upper left', 'bbox_to_anchor': (1, 1), 'fontsize': 14}\n)\naxs[1].set_axis_off()\naxs[1].set_facecolor('#f8f9fa')\n\nplt.tight_layout()\nplt.show()\n</pre> # Create subplots: left for network, right for degree centrality fig, axs = plt.subplots(1, 2, figsize=(24, 12))  axs[0].set_title(\"England &amp; Wales MSOA Migration Network: Flows \u226510\\n(Alpha by Percentile Rank)\", fontsize=22, color='white') c2g.plot_graph(     nodes=zones_london.centroid,     edges=top_edges,     ax=axs[0],     edge_alpha=percentile_ranks,     )  # Right subplot: Degree centrality axs[1].set_title(\"England &amp; Wales MSOA Migration Network: Degree Centrality\\n(Migration Flows 2021 - Quantile Classification)\", fontsize=22, color='white') od_nodes.plot(     column='degree_centrality',     ax=axs[1],     cmap='viridis',     edgecolor='white',     linewidth=0.1,     legend=True,     scheme='quantiles',     k=4,     legend_kwds={'title': 'Degree Centrality (Quantiles)', 'loc': 'upper left', 'bbox_to_anchor': (1, 1), 'fontsize': 14} ) axs[1].set_axis_off() axs[1].set_facecolor('#f8f9fa')  plt.tight_layout() plt.show()"},{"location":"examples/generating_graphs_from_od_matrix.html#od-matrix-to-graph-tutorial","title":"OD matrix to Graph tutorial\u00b6","text":"<p>This notebook demonstrates the conversion of Origin Destination (OD) Matrix into graph. The function <code>od_matrix_to_graph</code> supports ODs from <code>edgelist</code> (a DataFrame with source, target, and weight columns) and <code>adjacency</code> (a square matrix DataFrame or NumPy array). To construct a geospatial graph, it needs the data of <code>zones_gdf</code> that contains the information of zones.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#1-overview","title":"1. Overview\u00b6","text":"<p>In this tutorial you will:</p> <ul> <li>Learn the function inputs and outputs</li> <li>Build a tiny mock example (both edgelist and adjacency)</li> <li>Build a real graph from London MSOA zones and an ODMG flow table</li> <li>Visualize results and optionally convert to NetworkX</li> </ul>"},{"location":"examples/generating_graphs_from_od_matrix.html#2-imports-and-setup","title":"2. Imports and setup\u00b6","text":""},{"location":"examples/generating_graphs_from_od_matrix.html#3-edge-list","title":"3. Edge list\u00b6","text":"<p>We'll create 4 toy zones laid out in a square, then an edge list with a single weight column.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#creating-sample-zones","title":"Creating sample zones\u00b6","text":"<p>First, we'll create a simple 4x4 grid of zones to work with. Each zone will be a 1\u00d71 degree square polygon with a unique identifier like \"G00\", \"G10\", etc. This gives us 16 zones total that we can reference in our OD data.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#creating-the-edge-list-and-converting-to-graph","title":"Creating the edge list and converting to graph\u00b6","text":"<p>Now we'll create a simple edge list DataFrame with source-target pairs and flow values. This represents movement between zones - for example, 5 units flowing from zone G00 to G10. We'll then use <code>od_matrix_to_graph()</code> to convert this into spatial graph format.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#visualizing-the-spatial-graph","title":"Visualizing the spatial graph\u00b6","text":"<p>Now let's create a visualization showing both the zone boundaries and the flow edges. The edge thickness will be proportional to the flow weight.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#4-undirected-with-multiple-weights","title":"4. Undirected with multiple weights\u00b6","text":"<p><code>od_matrix_to_graph</code> also supports undirected way of summing flows, and multiple weights. We'll add two weight columns and merge reciprocals by summing. We must choose a <code>threshold_col</code> as the primary weight (canonical <code>weight</code>).</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#creating-an-undirected-graph-with-multiple-weights","title":"Creating an undirected graph with multiple weights\u00b6","text":"<p>In this example, we'll create edge data with reciprocal pairs (e.g., G00\u2192G10 and G10\u2192G00) and multiple weight columns. When <code>directed=False</code>, reciprocal edges are merged by summing their weights.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#plotting-the-undirected-graph","title":"Plotting the undirected graph\u00b6","text":"<p>The visualization will show the merged edges with their combined weights. Notice how reciprocal flows are now represented as single undirected edges.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#5-adjacency-matrix","title":"5. Adjacency matrix\u00b6","text":"<p>You can pass a square pandas DataFrame (index and columns must match) or a NumPy array.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#building-an-adjacency-matrix","title":"Building an adjacency matrix\u00b6","text":"<p>Instead of an edge list, we can provide data as an adjacency matrix. Here we'll create a 16\u00d716 DataFrame where rows and columns represent zones, and cell values represent flows.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#visualizing-the-adjacency-matrix-graph","title":"Visualizing the adjacency matrix graph\u00b6","text":"<p>The result should be identical to our first example since we're using the same flow values, just in matrix format instead of edge list format.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#6-england-wales-msoa-example","title":"6. England &amp; Wales MSOA example\u00b6","text":"<p>This section mirrors the development notebook and uses local files under <code>dev/</code>. You can adjust paths as needed.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#loading-real-world-data","title":"Loading real-world data\u00b6","text":"<p>Now we'll work with actual migration data from the UK Office for National Statistics .  For the dataset, we employed the OD data of England and Wales from the UK Census 2021. We'll load MSOA (Middle Layer Super Output Areas) zone boundaries for the zone unit.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#converting-london-migration-data-to-graph","title":"Converting London migration data to graph\u00b6","text":"<p>The ODMG dataset has specific column names for the migration data. We'll map these to our function parameters and create an undirected graph to represent bidirectional migration flows.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#inspecting-the-london-graph-structure","title":"Inspecting the London graph structure\u00b6","text":"<p>Let's examine the structure of our London migration network to understand what we've created.</p>"},{"location":"examples/generating_graphs_from_od_matrix.html#calculating-network-centrality","title":"Calculating Network centrality\u00b6","text":""},{"location":"examples/gtfs.html","title":"GTFS","text":"In\u00a0[\u00a0]: Copied! <pre># Geospatial data processing\nimport geopandas as gpd\nimport networkx as nx\nimport rustworkx as rx\nimport pandas as pd\n\n# Mapping and visualization\nimport contextily as ctx\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\n\n# Network analysis\nimport osmnx as ox\n\n# Others\nfrom pathlib import Path\n\n# The star of the show: city2graph for transportation network analysis\nimport city2graph as c2g\n</pre> # Geospatial data processing import geopandas as gpd import networkx as nx import rustworkx as rx import pandas as pd  # Mapping and visualization import contextily as ctx import matplotlib.pyplot as plt import matplotlib.lines as mlines  # Network analysis import osmnx as ox  # Others from pathlib import Path  # The star of the show: city2graph for transportation network analysis import city2graph as c2g <pre>city2graph version: 0.1.7\n</pre> In\u00a0[2]: Copied! <pre># Load GTFS data\nsample_gtfs_path = Path(\"./data/itm_london_gtfs.zip\")\n\nprint(\"Loading London Transport GTFS data...\")\n\n# One function call loads and processes the entire GTFS dataset\ngtfs_data = c2g.load_gtfs(sample_gtfs_path)\n\nprint(f\"Found {len(gtfs_data)} data tables\")\nprint(f\"Total stops: {len(gtfs_data['stops']):,}\")\nprint(f\"Total routes: {len(gtfs_data['routes']):,}\")\nprint(f\"Total scheduled stop times: {len(gtfs_data['stop_times']):,}\")\n</pre> # Load GTFS data sample_gtfs_path = Path(\"./data/itm_london_gtfs.zip\")  print(\"Loading London Transport GTFS data...\")  # One function call loads and processes the entire GTFS dataset gtfs_data = c2g.load_gtfs(sample_gtfs_path)  print(f\"Found {len(gtfs_data)} data tables\") print(f\"Total stops: {len(gtfs_data['stops']):,}\") print(f\"Total routes: {len(gtfs_data['routes']):,}\") print(f\"Total scheduled stop times: {len(gtfs_data['stop_times']):,}\") <pre>Loading London Transport GTFS data...\nFound 10 data tables\nTotal stops: 24,745\nTotal routes: 1,087\nTotal scheduled stop times: 17,807,603\n</pre> In\u00a0[3]: Copied! <pre># Explore the structure of our GTFS data\nprint(\"Available GTFS tables:\")\nfor i, table_name in enumerate(gtfs_data.keys(), 1):\n    num_records = len(gtfs_data[table_name])\n    print(f\"  {i}. {table_name}: {num_records:,} records\")\n\nprint(\"\\n\" + \"=\"*50)\nprint(\"GTFS Table Descriptions:\")\nprint(\"=\"*50)\nprint(\"agency      - Transit operators (TfL, etc.)\")\nprint(\"calendar    - Service patterns (weekdays/weekends)\")\nprint(\"routes      - Transit lines (Central Line, Bus 25, etc.)\")\nprint(\"stops       - Physical stop locations (with coordinates)\")\nprint(\"stop_times  - Scheduled arrivals/departures\")\nprint(\"trips       - Individual vehicle journeys\")\nprint(\"calendar_dates - Service exceptions (holidays, etc.)\")\n\ngtfs_data.keys()\n</pre> # Explore the structure of our GTFS data print(\"Available GTFS tables:\") for i, table_name in enumerate(gtfs_data.keys(), 1):     num_records = len(gtfs_data[table_name])     print(f\"  {i}. {table_name}: {num_records:,} records\")  print(\"\\n\" + \"=\"*50) print(\"GTFS Table Descriptions:\") print(\"=\"*50) print(\"agency      - Transit operators (TfL, etc.)\") print(\"calendar    - Service patterns (weekdays/weekends)\") print(\"routes      - Transit lines (Central Line, Bus 25, etc.)\") print(\"stops       - Physical stop locations (with coordinates)\") print(\"stop_times  - Scheduled arrivals/departures\") print(\"trips       - Individual vehicle journeys\") print(\"calendar_dates - Service exceptions (holidays, etc.)\")  gtfs_data.keys() <pre>Available GTFS tables:\n  1. agency: 56 records\n  2. stops: 24,745 records\n  3. routes: 1,087 records\n  4. calendar: 576 records\n  5. calendar_dates: 40,264 records\n  6. trips: 488,935 records\n  7. shapes: 147,172 records\n  8. frequencies: 61 records\n  9. feed_info: 1 records\n  10. stop_times: 17,807,603 records\n\n==================================================\nGTFS Table Descriptions:\n==================================================\nagency      - Transit operators (TfL, etc.)\ncalendar    - Service patterns (weekdays/weekends)\nroutes      - Transit lines (Central Line, Bus 25, etc.)\nstops       - Physical stop locations (with coordinates)\nstop_times  - Scheduled arrivals/departures\ntrips       - Individual vehicle journeys\ncalendar_dates - Service exceptions (holidays, etc.)\n</pre> Out[3]: <pre>dict_keys(['agency', 'stops', 'routes', 'calendar', 'calendar_dates', 'trips', 'shapes', 'frequencies', 'feed_info', 'stop_times'])</pre> In\u00a0[4]: Copied! <pre># Agency information - Who operates the transit services?\nprint(\"Transit Agencies:\")\nprint(\"This table contains information about transportation operators\")\ngtfs_data['agency'].head()\n</pre> # Agency information - Who operates the transit services? print(\"Transit Agencies:\") print(\"This table contains information about transportation operators\") gtfs_data['agency'].head() <pre>Transit Agencies:\nThis table contains information about transportation operators\n</pre> Out[4]: agency_id agency_name agency_url agency_timezone agency_lang agency_phone agency_noc 0 OP11949 Golden Tours https://www.traveline.info Europe/London EN NaN GTSL 1 OP14145 Quality Line https://www.traveline.info Europe/London EN NaN QULN 2 OP14161 London Underground (TfL) https://www.traveline.info Europe/London EN NaN LULD 3 OP14162 NATIONAL EXPRESS OPERAT https://www.traveline.info Europe/London EN NaN SS 4 OP14163 London Docklands Light Railway - TfL https://www.traveline.info Europe/London EN NaN LDLR In\u00a0[5]: Copied! <pre>gtfs_data['calendar'].head()\n</pre> gtfs_data['calendar'].head() Out[5]: service_id monday tuesday wednesday thursday friday saturday sunday start_date end_date 0 1 True True True True True True False 20250530 20260228 1 2 True True True True True False False 20250530 20260228 2 3 False False False False False True False 20250530 20260228 3 19 False False False False False False True 20250530 20260228 4 21 True True True True True False False 20250530 20260228 In\u00a0[6]: Copied! <pre>gtfs_data['calendar_dates'].head()\n</pre> gtfs_data['calendar_dates'].head() Out[6]: service_id date exception_type 0 20458 20250903 1 1 31969 20251001 2 2 31438 20250711 2 3 20583 20251105 1 4 33097 20251201 1 In\u00a0[7]: Copied! <pre>gtfs_data['routes'].head()\n</pre> gtfs_data['routes'].head() Out[7]: route_id agency_id route_short_name route_long_name route_type 0 58 OP5050 025 NaN 200 1 89 OP5050 444 NaN 200 2 100 OP5050 007 NaN 200 3 116 OP5050 022 NaN 200 4 289 OP53 372 NaN 3 In\u00a0[8]: Copied! <pre># Stops - The spatial foundation of transit networks\nprint(\"Transit Stops (with Spatial Coordinates):\")\nprint(\"Notice how city2graph automatically creates a 'geometry' column\")\nprint(\"This makes stops immediately ready for geospatial analysis\")\nprint(f\"Coordinate Reference System: {gtfs_data['stops'].crs}\")\nprint(f\"Geometry type: {gtfs_data['stops'].geometry.geom_type.iloc[0]}\")\n\ngtfs_data['stops'].head()\n</pre> # Stops - The spatial foundation of transit networks print(\"Transit Stops (with Spatial Coordinates):\") print(\"Notice how city2graph automatically creates a 'geometry' column\") print(\"This makes stops immediately ready for geospatial analysis\") print(f\"Coordinate Reference System: {gtfs_data['stops'].crs}\") print(f\"Geometry type: {gtfs_data['stops'].geometry.geom_type.iloc[0]}\")  gtfs_data['stops'].head() <pre>Transit Stops (with Spatial Coordinates):\nNotice how city2graph automatically creates a 'geometry' column\nThis makes stops immediately ready for geospatial analysis\nCoordinate Reference System: EPSG:4326\nGeometry type: Point\n</pre> Out[8]: stop_id stop_code stop_name stop_lat stop_lon wheelchair_boarding location_type parent_station platform_code geometry 0 490014597S 48536 White Hart Ln Grt Cambridge Rd 51.60490 -0.085950 0 0 NaN NaN POINT (-0.08595 51.6049) 1 490007372S 74106 Granville Place 51.59650 -0.387280 0 0 NaN NaN POINT (-0.38728 51.5965) 2 490013521E 52358 The Ravensbury 51.39799 -0.157870 0 0 NaN NaN POINT (-0.15787 51.39799) 3 240G006160A NaN Bus Station 51.27127 0.193303 0 1 NaN NaN POINT (0.1933 51.27127) 4 490007476V 56036 Palmers Green / Green Lanes 51.61252 -0.107100 0 0 NaN NaN POINT (-0.1071 51.61252) In\u00a0[9]: Copied! <pre>gtfs_data['stop_times'].head()\n</pre> gtfs_data['stop_times'].head() Out[9]: trip_id arrival_time departure_time stop_id stop_sequence stop_headsign pickup_type drop_off_type shape_dist_traveled timepoint 0 VJ000015f02fdb2ffc0444ac5453798bd8befdca76 05:05:00 05:05:00 490006587C 1 NaN 0 0 NaN 0 1 VJ000015f02fdb2ffc0444ac5453798bd8befdca76 05:05:00 05:05:00 490009222A 0 NaN 0 1 NaN 0 2 VJ000015f02fdb2ffc0444ac5453798bd8befdca76 05:06:00 05:06:00 490006588R 2 NaN 0 0 NaN 0 3 VJ000015f02fdb2ffc0444ac5453798bd8befdca76 05:06:00 05:06:00 490009169S 3 NaN 0 0 NaN 0 4 VJ000015f02fdb2ffc0444ac5453798bd8befdca76 05:07:00 05:07:00 490004650S 5 NaN 0 0 NaN 0 In\u00a0[10]: Copied! <pre>gtfs_data['trips'].head()\n</pre> gtfs_data['trips'].head() Out[10]: route_id service_id trip_id trip_headsign direction_id block_id shape_id wheelchair_accessible vehicle_journey_code 0 58 32443 VJ0b7453c953d79096488dd30c8d67da29644842ed Brighton - Victoria, London 1 NaN NaN 0 VJ99 1 58 32443 VJ0873eade6dfa11f222109beac2b7504007554ccd Belgravia, Victoria - Brighton 0 NaN NaN 0 VJ109 2 58 32443 VJ01dbdf44f6d74ff8027d089fb3db5ae022559673 Worthing - Victoria, London 1 NaN NaN 0 VJ57 3 58 32445 VJ1218298147f26d820d17ed4344a4dc9dc5f24cb6 Brighton - Victoria, London 1 NaN NaN 0 VJ29 4 58 32444 VJ18b4d838cbdac9a9ab9de1d2f0ca0426719ba0a8 Belgravia, Victoria - Brighton 0 NaN NaN 0 VJ142 In\u00a0[11]: Copied! <pre># Reproject to British National Grid for accurate distance calculations\nstops_gdf_bng = gtfs_data['stops'].to_crs(epsg=27700)\n\n# Visualize using c2g.plot_graph\nprint(\"Visualizing London's Transit Network\")\nax = c2g.plot_graph(\n    nodes=stops_gdf_bng,\n)\nctx.add_basemap(ax, crs=stops_gdf_bng.crs, source=ctx.providers.CartoDB.DarkMatter)\nplt.show()\n</pre> # Reproject to British National Grid for accurate distance calculations stops_gdf_bng = gtfs_data['stops'].to_crs(epsg=27700)  # Visualize using c2g.plot_graph print(\"Visualizing London's Transit Network\") ax = c2g.plot_graph(     nodes=stops_gdf_bng, ) ctx.add_basemap(ax, crs=stops_gdf_bng.crs, source=ctx.providers.CartoDB.DarkMatter) plt.show()  <pre>Visualizing London's Transit Network\n</pre> <p>After loading the GTFS, <code>travel_summary_graph()</code> can summarize the trips between stops. The output contains the origin and destination of stops, with average travel times in seconds and frequency in the specified time intervals.</p> <p>What it does:</p> <ul> <li>Processes thousands of individual trips into meaningful connections between stops</li> <li>Calculates average travel times between consecutive stops</li> <li>Counts service frequency (how often services run between stop pairs)</li> <li>Creates spatial geometries for each connection</li> <li>Handles complex scheduling including service calendars and time-of-day filtering</li> </ul> <p>Why this matters:</p> <ul> <li>Transforms scheduling complexity into simple origin-destination relationships</li> <li>Enables network analysis (shortest paths, centrality, accessibility)</li> <li>Perfect input for graph neural networks and machine learning</li> <li>Ready-to-use format for visualization and spatial analysis</li> </ul> <p>Let's see this powerful transformation in action:</p> In\u00a0[12]: Copied! <pre># Transform GTFS schedules into a travel network graph\ntravel_summary_nodes, travel_summary_edges = c2g.travel_summary_graph(\n    gtfs_data, \n    calendar_start=\"20250601\",  # Analyze services for June 1, 2025\n    calendar_end=\"20250601\"     # Single day analysis for demonstration\n)\n\ntravel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700)\ntravel_summary_edges = travel_summary_edges.to_crs(epsg=27700)\n\nprint(f\"Created graph with:\")\nprint(f\"   \u2022 {len(travel_summary_nodes):,} nodes (stops with connections)\")\nprint(f\"   \u2022 {len(travel_summary_edges):,} edges (stop-to-stop connections)\")\nprint(f\"   \u2022 Each edge contains travel time by seconds and frequency data\")\n</pre> # Transform GTFS schedules into a travel network graph travel_summary_nodes, travel_summary_edges = c2g.travel_summary_graph(     gtfs_data,      calendar_start=\"20250601\",  # Analyze services for June 1, 2025     calendar_end=\"20250601\"     # Single day analysis for demonstration )  travel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700) travel_summary_edges = travel_summary_edges.to_crs(epsg=27700)  print(f\"Created graph with:\") print(f\"   \u2022 {len(travel_summary_nodes):,} nodes (stops with connections)\") print(f\"   \u2022 {len(travel_summary_edges):,} edges (stop-to-stop connections)\") print(f\"   \u2022 Each edge contains travel time by seconds and frequency data\") <pre>Created graph with:\n   \u2022 24,745 nodes (stops with connections)\n   \u2022 28,133 edges (stop-to-stop connections)\n   \u2022 Each edge contains travel time by seconds and frequency data\n</pre> In\u00a0[13]: Copied! <pre>travel_summary_nodes.head()\n</pre> travel_summary_nodes.head() Out[13]: stop_code stop_name stop_lat stop_lon wheelchair_boarding location_type parent_station platform_code geometry stop_id 490014597S 48536 White Hart Ln Grt Cambridge Rd 51.60490 -0.085950 0 0 NaN NaN POINT (532649.18 191297.571) 490007372S 74106 Granville Place 51.59650 -0.387280 0 0 NaN NaN POINT (511803.342 189860.013) 490013521E 52358 The Ravensbury 51.39799 -0.157870 0 0 NaN NaN POINT (528248.023 168160.434) 240G006160A NaN Bus Station 51.27127 0.193303 0 1 NaN NaN POINT (553097.001 154742.187) 490007476V 56036 Palmers Green / Green Lanes 51.61252 -0.107100 0 0 NaN NaN POINT (531162.667 192106.81) In\u00a0[14]: Copied! <pre># Examine the edges (connections) in our travel network\nprint(\"Network Edges (Transit Connections):\")\nprint(\"Each row represents a direct connection between two stops\")\nprint(\"\\nKey metrics city2graph calculated:\")\nprint(\"   \u2022 travel_time_sec: Average time to travel between stops (seconds)\")\nprint(\"   \u2022 frequency: Number of services per day on this connection\")\nprint(\"   \u2022 geometry: LineString for mapping and spatial analysis\")\n\nprint(f\"\\nPerformance insight:\")\nprint(f\"   Fastest connection: {travel_summary_edges['travel_time_sec'].min():.0f} seconds\")\nprint(f\"   Busiest connection: {travel_summary_edges['frequency'].max():.0f} services/day\")\nprint(f\"   Average travel time: {travel_summary_edges['travel_time_sec'].mean():.0f} seconds\")\n\ntravel_summary_edges.head()\n</pre> # Examine the edges (connections) in our travel network print(\"Network Edges (Transit Connections):\") print(\"Each row represents a direct connection between two stops\") print(\"\\nKey metrics city2graph calculated:\") print(\"   \u2022 travel_time_sec: Average time to travel between stops (seconds)\") print(\"   \u2022 frequency: Number of services per day on this connection\") print(\"   \u2022 geometry: LineString for mapping and spatial analysis\")  print(f\"\\nPerformance insight:\") print(f\"   Fastest connection: {travel_summary_edges['travel_time_sec'].min():.0f} seconds\") print(f\"   Busiest connection: {travel_summary_edges['frequency'].max():.0f} services/day\") print(f\"   Average travel time: {travel_summary_edges['travel_time_sec'].mean():.0f} seconds\")  travel_summary_edges.head() <pre>Network Edges (Transit Connections):\nEach row represents a direct connection between two stops\n\nKey metrics city2graph calculated:\n   \u2022 travel_time_sec: Average time to travel between stops (seconds)\n   \u2022 frequency: Number of services per day on this connection\n   \u2022 geometry: LineString for mapping and spatial analysis\n\nPerformance insight:\n   Fastest connection: 1 seconds\n   Busiest connection: 999 services/day\n   Average travel time: 436 seconds\n</pre> Out[14]: travel_time_sec frequency geometry from_stop_id to_stop_id 01000053216 0170SGP90689 830.303030 99.0 LINESTRING (358898.332 173509.501, 362270.014 ... 0190NSZ01231 2700.000000 8.0 LINESTRING (358898.332 173509.501, 336803.818 ... 035059860001 5541.176471 17.0 LINESTRING (358898.332 173509.501, 471026.138 ... 1100DEA57098 6600.000000 6.0 LINESTRING (358898.332 173509.501, 292592.045 ... 360000174 3710.000000 30.0 LINESTRING (358898.332 173509.501, 325332.697 ... <p>Now we will clean up the dataset to focus on Greater London, excluding intercity and international lines. This time we employed the boundary of the Greater London by <code>osmnx</code>.</p> In\u00a0[15]: Copied! <pre># Get London boundary using OSMnx\nlondon_boundary = ox.geocode_to_gdf(\"Greater London, UK\").to_crs(epsg=27700)\n\n# Project our network data to British National Grid for accurate spatial operations\ntravel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700)\ntravel_summary_edges = travel_summary_edges.to_crs(epsg=27700)\n\n# Spatial join to filter data within London boundary\nprint(\"Filtering nodes and edges within London boundary...\")\nnodes_in_bound = gpd.sjoin(travel_summary_nodes, london_boundary, how=\"inner\").drop(columns=['index_right'])\nedges_in_bound = gpd.sjoin(travel_summary_edges, london_boundary, how=\"inner\").drop(columns=['index_right'])\n\n# Update variables and ensure edge consistency\ntravel_summary_nodes = nodes_in_bound\ntravel_summary_edges = edges_in_bound\n\n# Keep only edges where both endpoints are in our filtered node set\ntravel_summary_edges = travel_summary_edges[\n    travel_summary_edges.index.get_level_values('from_stop_id').isin(travel_summary_nodes.index) &amp;\n    travel_summary_edges.index.get_level_values('to_stop_id').isin(travel_summary_nodes.index)\n]\n\nprint(f\"Spatial filtering complete:\")\nprint(f\"   Nodes within London: {len(travel_summary_nodes):,}\")\nprint(f\"   Edges within London: {len(travel_summary_edges):,}\")\n</pre> # Get London boundary using OSMnx london_boundary = ox.geocode_to_gdf(\"Greater London, UK\").to_crs(epsg=27700)  # Project our network data to British National Grid for accurate spatial operations travel_summary_nodes = travel_summary_nodes.to_crs(epsg=27700) travel_summary_edges = travel_summary_edges.to_crs(epsg=27700)  # Spatial join to filter data within London boundary print(\"Filtering nodes and edges within London boundary...\") nodes_in_bound = gpd.sjoin(travel_summary_nodes, london_boundary, how=\"inner\").drop(columns=['index_right']) edges_in_bound = gpd.sjoin(travel_summary_edges, london_boundary, how=\"inner\").drop(columns=['index_right'])  # Update variables and ensure edge consistency travel_summary_nodes = nodes_in_bound travel_summary_edges = edges_in_bound  # Keep only edges where both endpoints are in our filtered node set travel_summary_edges = travel_summary_edges[     travel_summary_edges.index.get_level_values('from_stop_id').isin(travel_summary_nodes.index) &amp;     travel_summary_edges.index.get_level_values('to_stop_id').isin(travel_summary_nodes.index) ]  print(f\"Spatial filtering complete:\") print(f\"   Nodes within London: {len(travel_summary_nodes):,}\") print(f\"   Edges within London: {len(travel_summary_edges):,}\") <pre>Filtering nodes and edges within London boundary...\nSpatial filtering complete:\n   Nodes within London: 20,220\n   Edges within London: 25,182\n</pre> <p>As a result, we can see the overview by <code>plot_graph()</code>.</p> In\u00a0[16]: Copied! <pre># Plot the network with dual encoding (color + width) using city2graph\nc2g.plot_graph(\n    nodes=travel_summary_nodes,\n    edges=travel_summary_edges,\n    edge_color='travel_time_sec',\n    edge_linewidth=travel_summary_edges['frequency'] / 250,\n    edge_alpha=0.8,\n    )\nplt.show()\n</pre> # Plot the network with dual encoding (color + width) using city2graph c2g.plot_graph(     nodes=travel_summary_nodes,     edges=travel_summary_edges,     edge_color='travel_time_sec',     edge_linewidth=travel_summary_edges['frequency'] / 250,     edge_alpha=0.8,     ) plt.show() <p>For the calcluation of network centralities, <code>networkx</code> is not the fastest solution. <code>city2graph</code> provides conversion functionalies to <code>rustworkx</code> for better compuation efficiency by rust.</p> In\u00a0[17]: Copied! <pre>travel_summary_graph = c2g.gdf_to_nx(\n    travel_summary_nodes,\n    travel_summary_edges,\n)\n\ntravel_rx_graph = c2g.nx_to_rx(travel_summary_graph)\n\nbetweenness_centrality = rx.betweenness_centrality(travel_rx_graph)\n\n# Set the betweenness centrality as a node attribute\nnx.set_node_attributes(\n    travel_summary_graph,\n    betweenness_centrality, \n    \"betweenness_centrality\"\n    )\n\ntravel_nodes, travel_edges = c2g.nx_to_gdf(travel_summary_graph)\n</pre> travel_summary_graph = c2g.gdf_to_nx(     travel_summary_nodes,     travel_summary_edges, )  travel_rx_graph = c2g.nx_to_rx(travel_summary_graph)  betweenness_centrality = rx.betweenness_centrality(travel_rx_graph)  # Set the betweenness centrality as a node attribute nx.set_node_attributes(     travel_summary_graph,     betweenness_centrality,      \"betweenness_centrality\"     )  travel_nodes, travel_edges = c2g.nx_to_gdf(travel_summary_graph) <pre>Removed 3 invalid geometries\n</pre> In\u00a0[18]: Copied! <pre># Calculate quantiles for node size to handle skew in centrality values\n# Drop duplicate bin edges to avoid qcut errors when many nodes share the same centrality\ncentrality_bins = pd.qcut(\n    travel_nodes['betweenness_centrality'],\n    q=10,\n    labels=False,\n    duplicates=\"drop\"\n)\n\ntravel_nodes['centrality_quantile'] = centrality_bins.fillna(0).astype(int) + 1\ntravel_nodes['node_size_visual'] = travel_nodes['centrality_quantile'] * 15\n\nfig, ax = plt.subplots(figsize=(16, 16))\n\n# Use city2graph to plot the network structure\n# Node size represents centrality (skews handled by quantiles)\n# Edge width represents frequency\nc2g.plot_graph(\n    nodes=travel_nodes,\n    edges=travel_edges,\n    markersize=8,\n    node_color='centrality_quantile',\n    node_alpha=0.9,\n    edge_color='#bbbbbb',\n    edge_linewidth=travel_edges['frequency'] / 200,\n    edge_alpha=0.7,\n    figsize=(16, 16),\n    title=\"Central London Transit Network\\nBetweenness Centrality of Stops\",\n    legend=True,\n    legend_kwargs={'label': 'Betweenness Centrality', 'orientation': 'horizontal'},\n    ax=ax\n)\n\n# Add legend for betweenness centrality ranges\ncmap = plt.cm.viridis\nnorm = plt.Normalize(\n    vmin=travel_nodes['centrality_quantile'].min(),\n    vmax=travel_nodes['centrality_quantile'].max()\n)\n\nquantile_ranges = (\n    travel_nodes\n    .groupby('centrality_quantile')['betweenness_centrality']\n    .agg(['min', 'max'])\n    .reset_index()\n)\n\nhandles = [\n    mlines.Line2D(\n        [],\n        [],\n        color=cmap(norm(row['centrality_quantile'])),\n        marker='o',\n        linestyle='',\n        markersize=8,\n        label=f\"{row['min']:.6f} \u2013 {row['max']:.6f}\"\n    )\n    for _, row in quantile_ranges.iterrows()\n]\nax.legend(handles=handles, title='Betweenness Centrality', loc='lower right')\n\n# Add basemap with a clean, modern style\nctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.DarkMatter)\n\nplt.show()\n</pre> # Calculate quantiles for node size to handle skew in centrality values # Drop duplicate bin edges to avoid qcut errors when many nodes share the same centrality centrality_bins = pd.qcut(     travel_nodes['betweenness_centrality'],     q=10,     labels=False,     duplicates=\"drop\" )  travel_nodes['centrality_quantile'] = centrality_bins.fillna(0).astype(int) + 1 travel_nodes['node_size_visual'] = travel_nodes['centrality_quantile'] * 15  fig, ax = plt.subplots(figsize=(16, 16))  # Use city2graph to plot the network structure # Node size represents centrality (skews handled by quantiles) # Edge width represents frequency c2g.plot_graph(     nodes=travel_nodes,     edges=travel_edges,     markersize=8,     node_color='centrality_quantile',     node_alpha=0.9,     edge_color='#bbbbbb',     edge_linewidth=travel_edges['frequency'] / 200,     edge_alpha=0.7,     figsize=(16, 16),     title=\"Central London Transit Network\\nBetweenness Centrality of Stops\",     legend=True,     legend_kwargs={'label': 'Betweenness Centrality', 'orientation': 'horizontal'},     ax=ax )  # Add legend for betweenness centrality ranges cmap = plt.cm.viridis norm = plt.Normalize(     vmin=travel_nodes['centrality_quantile'].min(),     vmax=travel_nodes['centrality_quantile'].max() )  quantile_ranges = (     travel_nodes     .groupby('centrality_quantile')['betweenness_centrality']     .agg(['min', 'max'])     .reset_index() )  handles = [     mlines.Line2D(         [],         [],         color=cmap(norm(row['centrality_quantile'])),         marker='o',         linestyle='',         markersize=8,         label=f\"{row['min']:.6f} \u2013 {row['max']:.6f}\"     )     for _, row in quantile_ranges.iterrows() ] ax.legend(handles=handles, title='Betweenness Centrality', loc='lower right')  # Add basemap with a clean, modern style ctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.DarkMatter)  plt.show() <p>As seen in the plot, we could detect stations with higher betweenness centrality that are alongside of main streets.</p> <p>To see the local property of transportation systems, we wil filter the graph using <code>filter_by_distance</code>. This time we filter it with 15-minute (900-seconds) travel tume from the central of London.</p> In\u00a0[19]: Copied! <pre># Filter graph to show network within 1.2km of central London\ncenter_point = london_boundary.geometry.to_crs(27700).iloc[0].centroid\n\nfiltered_travel_summary_graph = c2g.filter_graph_by_distance(\n    travel_summary_graph,\n    center_point=center_point,\n    threshold=900,  # 900 seconds (~15 minutes travel tune)\n    edge_attr=\"travel_time_sec\"  # Filter by travel time, not physical distance\n)\n</pre> # Filter graph to show network within 1.2km of central London center_point = london_boundary.geometry.to_crs(27700).iloc[0].centroid  filtered_travel_summary_graph = c2g.filter_graph_by_distance(     travel_summary_graph,     center_point=center_point,     threshold=900,  # 900 seconds (~15 minutes travel tune)     edge_attr=\"travel_time_sec\"  # Filter by travel time, not physical distance ) In\u00a0[20]: Copied! <pre>filtered_travel_rx_graph = c2g.nx_to_rx(filtered_travel_summary_graph)\n\nbetweenness_centrality_filtered = rx.betweenness_centrality(filtered_travel_rx_graph)\n\n# Set the betweenness centrality as a node attribute\nnx.set_node_attributes(\n    filtered_travel_summary_graph,\n    betweenness_centrality_filtered, \n    \"betweenness_centrality\"\n    )\n</pre> filtered_travel_rx_graph = c2g.nx_to_rx(filtered_travel_summary_graph)  betweenness_centrality_filtered = rx.betweenness_centrality(filtered_travel_rx_graph)  # Set the betweenness centrality as a node attribute nx.set_node_attributes(     filtered_travel_summary_graph,     betweenness_centrality_filtered,      \"betweenness_centrality\"     ) In\u00a0[21]: Copied! <pre>filtered_travel_nodes, filtered_travel_edges = c2g.nx_to_gdf(\n    filtered_travel_summary_graph\n    )\n</pre> filtered_travel_nodes, filtered_travel_edges = c2g.nx_to_gdf(     filtered_travel_summary_graph     ) In\u00a0[22]: Copied! <pre># Calculate quantiles for node size to handle skew in centrality values\n# We bin the data into 5 quantiles and scale the size for visibility\nfiltered_travel_nodes['centrality_quantile'] = pd.qcut(\n    filtered_travel_nodes['betweenness_centrality'], \n    q=5, \n    labels=False\n) + 1\nfiltered_travel_nodes['node_size_visual'] = filtered_travel_nodes['centrality_quantile'] * 15\n\nfig, ax = plt.subplots(figsize=(16, 16))\n\n# Use city2graph to plot the network structure\n# Node size represents centrality (skews handled by quantiles)\n# Edge width represents frequency\nc2g.plot_graph(\n    nodes=filtered_travel_nodes,\n    edges=filtered_travel_edges,\n    node_color='centrality_quantile',\n    markersize=100,\n    node_alpha=0.9,\n    edge_color='#bbbbbb',\n    edge_linewidth=filtered_travel_edges['frequency'] / 200,\n    edge_alpha=0.7,\n    ax=ax\n)\n\n# Add basemap with a clean, modern style\nctx.add_basemap(ax, crs=filtered_travel_nodes.crs, source=ctx.providers.CartoDB.DarkMatter)\n\n# Add legend for betweenness centrality ranges\ncmap = plt.cm.viridis\nnorm = plt.Normalize(\n    vmin=filtered_travel_nodes['centrality_quantile'].min(),\n    vmax=filtered_travel_nodes['centrality_quantile'].max()\n)\n\nquantile_ranges = (\n    filtered_travel_nodes\n    .groupby('centrality_quantile')['betweenness_centrality']\n    .agg(['min', 'max'])\n    .reset_index()\n)\n\nhandles = [\n    mlines.Line2D(\n        [],\n        [],\n        color=cmap(norm(row['centrality_quantile'])),\n        marker='o',\n        linestyle='',\n        markersize=8,\n        label=f\"{row['min']:.6f} \u2013 {row['max']:.6f}\"\n    )\n    for _, row in quantile_ranges.iterrows()\n]\nax.legend(handles=handles, title='Betweenness Centrality', loc='lower right')\n\nplt.show()\n</pre> # Calculate quantiles for node size to handle skew in centrality values # We bin the data into 5 quantiles and scale the size for visibility filtered_travel_nodes['centrality_quantile'] = pd.qcut(     filtered_travel_nodes['betweenness_centrality'],      q=5,      labels=False ) + 1 filtered_travel_nodes['node_size_visual'] = filtered_travel_nodes['centrality_quantile'] * 15  fig, ax = plt.subplots(figsize=(16, 16))  # Use city2graph to plot the network structure # Node size represents centrality (skews handled by quantiles) # Edge width represents frequency c2g.plot_graph(     nodes=filtered_travel_nodes,     edges=filtered_travel_edges,     node_color='centrality_quantile',     markersize=100,     node_alpha=0.9,     edge_color='#bbbbbb',     edge_linewidth=filtered_travel_edges['frequency'] / 200,     edge_alpha=0.7,     ax=ax )  # Add basemap with a clean, modern style ctx.add_basemap(ax, crs=filtered_travel_nodes.crs, source=ctx.providers.CartoDB.DarkMatter)  # Add legend for betweenness centrality ranges cmap = plt.cm.viridis norm = plt.Normalize(     vmin=filtered_travel_nodes['centrality_quantile'].min(),     vmax=filtered_travel_nodes['centrality_quantile'].max() )  quantile_ranges = (     filtered_travel_nodes     .groupby('centrality_quantile')['betweenness_centrality']     .agg(['min', 'max'])     .reset_index() )  handles = [     mlines.Line2D(         [],         [],         color=cmap(norm(row['centrality_quantile'])),         marker='o',         linestyle='',         markersize=8,         label=f\"{row['min']:.6f} \u2013 {row['max']:.6f}\"     )     for _, row in quantile_ranges.iterrows() ] ax.legend(handles=handles, title='Betweenness Centrality', loc='lower right')  plt.show()  In\u00a0[35]: Copied! <pre>print(\"Creating isochrones for accessibility analysis...\")\nprint(f\"Center point: {center_point}\")\nprint(\"\\nIsochrone parameters:\")\nprint(\"  \u2022 Threshold: 1800 seconds (30 minutes travel time)\")\nprint(\"  \u2022 Edge attribute: travel_time_sec (average seconds between stops)\")\nprint(\"  \u2022 Method: concave_hull_knn (produces smooth, realistic boundaries)\")\n\n# Create isochrone showing 30-minute travel range\nisochrone_30min = c2g.create_isochrone(\n    graph=travel_summary_graph,\n    center_point=center_point,\n    threshold=1800,  # 30 minutes in seconds\n    edge_attr=\"travel_time_sec\"\n    )\n\nprint(f\"Reachable area geometry: {isochrone_30min.geometry.geom_type.iloc[0]}\")\nprint(f\"Area coverage: {isochrone_30min.geometry.area.iloc[0] / 1e6:.2f} km\u00b2\")\n</pre> print(\"Creating isochrones for accessibility analysis...\") print(f\"Center point: {center_point}\") print(\"\\nIsochrone parameters:\") print(\"  \u2022 Threshold: 1800 seconds (30 minutes travel time)\") print(\"  \u2022 Edge attribute: travel_time_sec (average seconds between stops)\") print(\"  \u2022 Method: concave_hull_knn (produces smooth, realistic boundaries)\")  # Create isochrone showing 30-minute travel range isochrone_30min = c2g.create_isochrone(     graph=travel_summary_graph,     center_point=center_point,     threshold=1800,  # 30 minutes in seconds     edge_attr=\"travel_time_sec\"     )  print(f\"Reachable area geometry: {isochrone_30min.geometry.geom_type.iloc[0]}\") print(f\"Area coverage: {isochrone_30min.geometry.area.iloc[0] / 1e6:.2f} km\u00b2\")  <pre>Creating isochrones for accessibility analysis...\nCenter point: POINT (531330.9685805585 179645.93517953434)\n\nIsochrone parameters:\n  \u2022 Threshold: 1800 seconds (30 minutes travel time)\n  \u2022 Edge attribute: travel_time_sec (average seconds between stops)\n  \u2022 Method: concave_hull_knn (produces smooth, realistic boundaries)\nReachable area geometry: Polygon\nArea coverage: 101.04 km\u00b2\n</pre> In\u00a0[24]: Copied! <pre>time_thresholds = {\n    '5 minutes' : 300,\n    '10 minutes': 600,\n    '15 minutes': 900,\n}\n\nisochrones = {}\nfor label, seconds in time_thresholds.items():\n    iso = c2g.create_isochrone(\n        graph=travel_summary_graph,\n        center_point=center_point,\n        threshold=seconds,\n        edge_attr=\"travel_time_sec\",\n    )\n    isochrones[label] = iso\n    area_km2 = iso.geometry.area.iloc[0] / 1e6\n    print(f\"{label:15} \u2192 {area_km2:6.2f} km\u00b2 reachable area\")\n</pre> time_thresholds = {     '5 minutes' : 300,     '10 minutes': 600,     '15 minutes': 900, }  isochrones = {} for label, seconds in time_thresholds.items():     iso = c2g.create_isochrone(         graph=travel_summary_graph,         center_point=center_point,         threshold=seconds,         edge_attr=\"travel_time_sec\",     )     isochrones[label] = iso     area_km2 = iso.geometry.area.iloc[0] / 1e6     print(f\"{label:15} \u2192 {area_km2:6.2f} km\u00b2 reachable area\") <pre>5 minutes       \u2192   0.42 km\u00b2 reachable area\n10 minutes      \u2192   6.77 km\u00b2 reachable area\n15 minutes      \u2192  18.85 km\u00b2 reachable area\n</pre> In\u00a0[25]: Copied! <pre>fig, ax = plt.subplots(figsize=(16, 14))\n\n# Define colors for each isochrone (from cool to warm)\niso_colors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1']\niso_labels = list(isochrones.keys())\n\n# Plot isochrones from largest to smallest (so they don't overlap visually)\nfor label, color in zip(reversed(iso_labels), reversed(iso_colors)):\n    iso_gdf = isochrones[label]\n    iso_gdf.plot(\n        ax=ax,\n        alpha=0.4, # Increased alpha for better visibility\n        color=color,\n        label=label,\n        edgecolor='black', # Changed edge color for contrast\n        linewidth=1,\n        zorder=2 # Ensure they sit above basemap but below network\n    )\n\n# Mark the center point\nax.plot(center_point.x, center_point.y, 'r*', markersize=25, markeredgecolor='white', label='Origin', zorder=10)\n\n# Add basemap\nctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron)\n\nax.legend(loc='upper right', fontsize=12, framealpha=0.9)\nax.set_title('Transit Accessibility Isochrones\\nTravel Times from Center of London', \n             fontsize=16, color='black', pad=20)\nax.axis('off') # Cleaner look\n\nplt.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(16, 14))  # Define colors for each isochrone (from cool to warm) iso_colors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1'] iso_labels = list(isochrones.keys())  # Plot isochrones from largest to smallest (so they don't overlap visually) for label, color in zip(reversed(iso_labels), reversed(iso_colors)):     iso_gdf = isochrones[label]     iso_gdf.plot(         ax=ax,         alpha=0.4, # Increased alpha for better visibility         color=color,         label=label,         edgecolor='black', # Changed edge color for contrast         linewidth=1,         zorder=2 # Ensure they sit above basemap but below network     )  # Mark the center point ax.plot(center_point.x, center_point.y, 'r*', markersize=25, markeredgecolor='white', label='Origin', zorder=10)  # Add basemap ctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron)  ax.legend(loc='upper right', fontsize=12, framealpha=0.9) ax.set_title('Transit Accessibility Isochrones\\nTravel Times from Center of London',               fontsize=16, color='black', pad=20) ax.axis('off') # Cleaner look  plt.tight_layout() plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_85849/295802431.py:26: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  ax.legend(loc='upper right', fontsize=12, framealpha=0.9)\n</pre> In\u00a0[26]: Copied! <pre>print(\"Fetching London street network from OSM (walk network)...\")\nlondon_poly = london_boundary.to_crs(epsg=4326).geometry.union_all()\n\n# Download pedestrian network for the London polygon\nstreet_graph = ox.graph_from_polygon(london_poly, network_type=\"walk\", simplify=True)\n\n# Convert to GeoDataFrames\nstreet_nodes, street_edges = c2g.nx_to_gdf(street_graph)\n\n# Ensure correct CRS and reproject to British National Grid for distance calculations\nstreet_nodes = street_nodes.set_crs(epsg=4326).to_crs(epsg=27700)\nstreet_edges = street_edges.set_crs(epsg=4326).to_crs(epsg=27700)\n\n# Recompute accurate lengths in metres using projected geometries\nstreet_edges[\"length\"] = street_edges.geometry.length\n\n# Compute walking travel time (seconds) assuming 4.5 km/h = 4500 m/h\nstreet_edges[\"travel_time_sec\"] = street_edges[\"length\"] / 4500 * 3600\n\n# Basic summary for verification\nprint(f\"Street nodes: {len(street_nodes):,}\")\nprint(f\"Street edges: {len(street_edges):,}\")\nprint(\"Sample street edges:\")\ndisplay(street_edges.head())\n</pre> print(\"Fetching London street network from OSM (walk network)...\") london_poly = london_boundary.to_crs(epsg=4326).geometry.union_all()  # Download pedestrian network for the London polygon street_graph = ox.graph_from_polygon(london_poly, network_type=\"walk\", simplify=True)  # Convert to GeoDataFrames street_nodes, street_edges = c2g.nx_to_gdf(street_graph)  # Ensure correct CRS and reproject to British National Grid for distance calculations street_nodes = street_nodes.set_crs(epsg=4326).to_crs(epsg=27700) street_edges = street_edges.set_crs(epsg=4326).to_crs(epsg=27700)  # Recompute accurate lengths in metres using projected geometries street_edges[\"length\"] = street_edges.geometry.length  # Compute walking travel time (seconds) assuming 4.5 km/h = 4500 m/h street_edges[\"travel_time_sec\"] = street_edges[\"length\"] / 4500 * 3600  # Basic summary for verification print(f\"Street nodes: {len(street_nodes):,}\") print(f\"Street edges: {len(street_edges):,}\") print(\"Sample street edges:\") display(street_edges.head()) <pre>Fetching London street network from OSM (walk network)...\nStreet nodes: 492,210\nStreet edges: 1,264,518\nSample street edges:\n</pre> osmid access highway maxspeed name oneway reversed length geometry bridge service lanes ref tunnel width junction est_width area travel_time_sec 78112 25508583 0 129375498 permissive unclassified 20 mph Outer Circle False False 19.399136 LINESTRING (528725 182525.235, 528726.116 1825... NaN NaN NaN NaN NaN NaN NaN NaN NaN 15.519308 25508584 0 129375498 permissive unclassified 20 mph Outer Circle False True 63.701486 LINESTRING (528725 182525.235, 528722.54 18258... NaN NaN NaN NaN NaN NaN NaN NaN NaN 50.961189 1 4257258 permissive residential 20 mph Cambridge Terrace False False 102.844507 LINESTRING (528725 182525.235, 528744.582 1825... NaN NaN NaN NaN NaN NaN NaN NaN NaN 82.275606 99884 12378884761 0 4082681 NaN footway NaN NaN False False 173.282760 LINESTRING (528245.101 182222.468, 528259.75 1... NaN NaN NaN NaN NaN NaN NaN NaN NaN 138.626208 4544836450 0 5090291 NaN footway NaN NaN False False 308.182017 LINESTRING (528245.101 182222.468, 528275.674 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 246.545613 In\u00a0[27]: Copied! <pre>walking_thresholds = {\n    '5 minutes' : 300,\n    '10 minutes': 600,\n    '15 minutes': 900\n}\n\nwalking_isochrones = {}\nfor label, seconds in walking_thresholds.items():\n    iso = c2g.create_isochrone(\n        nodes=street_nodes,\n        edges=street_edges,\n        center_point=center_point,\n        threshold=seconds,\n        edge_attr=\"travel_time_sec\",\n    )\n    walking_isochrones[label] = iso\n    area_km2 = iso.geometry.area.iloc[0] / 1e6\n    print(f\"{label:12} \u2192 {area_km2:6.2f} km\u00b2 reachable area\")\n</pre> walking_thresholds = {     '5 minutes' : 300,     '10 minutes': 600,     '15 minutes': 900 }  walking_isochrones = {} for label, seconds in walking_thresholds.items():     iso = c2g.create_isochrone(         nodes=street_nodes,         edges=street_edges,         center_point=center_point,         threshold=seconds,         edge_attr=\"travel_time_sec\",     )     walking_isochrones[label] = iso     area_km2 = iso.geometry.area.iloc[0] / 1e6     print(f\"{label:12} \u2192 {area_km2:6.2f} km\u00b2 reachable area\")  <pre>5 minutes    \u2192   0.16 km\u00b2 reachable area\n10 minutes   \u2192   0.88 km\u00b2 reachable area\n15 minutes   \u2192   2.11 km\u00b2 reachable area\n</pre> In\u00a0[28]: Copied! <pre>fig, ax = plt.subplots(figsize=(16, 14))\n\nmulti_colors = ['#ff6b6b', '#48dbfb', '#1dd1a1']\nlabels_ordered = list(walking_isochrones.keys())\n\n# Plot larger thresholds first for layering\nfor label, color in zip(reversed(labels_ordered), reversed(multi_colors)):\n    iso_gdf = walking_isochrones[label]\n    iso_gdf.plot(\n        ax=ax,\n        alpha=0.35,\n        color=color,\n        edgecolor='#111111',\n        linewidth=1.25,\n        label=label,\n        zorder=2,\n    )\n\n# Origin marker\nax.plot(center_point.x, center_point.y, 'r*', markersize=28, markeredgecolor='white', label='Origin', zorder=4)\n\n# Basemap for context\nctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron, alpha=0.6)\n\nax.set_title('Walking Accessibility Isochrones\\nWalk Travel Times from London Center', fontsize=16, color='black', pad=18)\nax.legend(loc='upper right', framealpha=0.9)\nax.axis('off')\nplt.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(16, 14))  multi_colors = ['#ff6b6b', '#48dbfb', '#1dd1a1'] labels_ordered = list(walking_isochrones.keys())  # Plot larger thresholds first for layering for label, color in zip(reversed(labels_ordered), reversed(multi_colors)):     iso_gdf = walking_isochrones[label]     iso_gdf.plot(         ax=ax,         alpha=0.35,         color=color,         edgecolor='#111111',         linewidth=1.25,         label=label,         zorder=2,     )  # Origin marker ax.plot(center_point.x, center_point.y, 'r*', markersize=28, markeredgecolor='white', label='Origin', zorder=4)  # Basemap for context ctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron, alpha=0.6)  ax.set_title('Walking Accessibility Isochrones\\nWalk Travel Times from London Center', fontsize=16, color='black', pad=18) ax.legend(loc='upper right', framealpha=0.9) ax.axis('off') plt.tight_layout() plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_85849/2363295211.py:26: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  ax.legend(loc='upper right', framealpha=0.9)\n</pre> In\u00a0[29]: Copied! <pre>hetero_nodes = {\n    \"street_intersection\": street_nodes,\n    \"bus_station\": travel_nodes,\n}\n\nhetero_edges = {\n    (\"street_intersection\", \"is_connected_to\", \"street_intersection\"): street_edges,\n    (\"bus_station\", \"is_next_to\", \"bus_station\"): travel_edges,\n}\n</pre> hetero_nodes = {     \"street_intersection\": street_nodes,     \"bus_station\": travel_nodes, }  hetero_edges = {     (\"street_intersection\", \"is_connected_to\", \"street_intersection\"): street_edges,     (\"bus_station\", \"is_next_to\", \"bus_station\"): travel_edges, } In\u00a0[30]: Copied! <pre>_, bridged_edges = c2g.bridge_nodes(hetero_nodes, source_node_types=[\"bus_station\"])\n\nbridged_edges[('bus_station', 'is_nearby', 'street_intersection')][\"travel_time_sec\"] = bridged_edges[('bus_station', 'is_nearby', 'street_intersection')].geometry.length / 4500 * 3600\n\nhetero_edges.update(bridged_edges)\n</pre> _, bridged_edges = c2g.bridge_nodes(hetero_nodes, source_node_types=[\"bus_station\"])  bridged_edges[('bus_station', 'is_nearby', 'street_intersection')][\"travel_time_sec\"] = bridged_edges[('bus_station', 'is_nearby', 'street_intersection')].geometry.length / 4500 * 3600  hetero_edges.update(bridged_edges) In\u00a0[31]: Copied! <pre>multimodal_thresholds = {\n    '5 minutes' : 300,\n    '10 minutes': 600,\n    '15 minutes': 900\n}\n\nmultimodal_isochrones = {}\nfor label, seconds in multimodal_thresholds.items():\n    iso = c2g.create_isochrone(\n        nodes=hetero_nodes,\n        edges=hetero_edges,\n        center_point=center_point,\n        threshold=seconds,\n        edge_attr=\"travel_time_sec\",\n    )\n    multimodal_isochrones[label] = iso\n    area_km2 = iso.geometry.area.iloc[0] / 1e6\n    print(f\"{label:12} \u2192 {area_km2:6.2f} km\u00b2 reachable area\")\n</pre> multimodal_thresholds = {     '5 minutes' : 300,     '10 minutes': 600,     '15 minutes': 900 }  multimodal_isochrones = {} for label, seconds in multimodal_thresholds.items():     iso = c2g.create_isochrone(         nodes=hetero_nodes,         edges=hetero_edges,         center_point=center_point,         threshold=seconds,         edge_attr=\"travel_time_sec\",     )     multimodal_isochrones[label] = iso     area_km2 = iso.geometry.area.iloc[0] / 1e6     print(f\"{label:12} \u2192 {area_km2:6.2f} km\u00b2 reachable area\")  <pre>5 minutes    \u2192   0.25 km\u00b2 reachable area\n10 minutes   \u2192   3.30 km\u00b2 reachable area\n15 minutes   \u2192  15.77 km\u00b2 reachable area\n</pre> In\u00a0[32]: Copied! <pre>fig, ax = plt.subplots(figsize=(16, 14))\n\nmulti_colors = ['#ff6b6b', '#48dbfb', '#1dd1a1']\nlabels_ordered = list(multimodal_isochrones.keys())\n\n# Plot larger thresholds first for layering\nfor label, color in zip(reversed(labels_ordered), reversed(multi_colors)):\n    iso_gdf = multimodal_isochrones[label]\n    iso_gdf.plot(\n        ax=ax,\n        alpha=0.35,\n        color=color,\n        edgecolor='#111111',\n        linewidth=1.25,\n        label=label,\n        zorder=2,\n    )\n\n# Origin marker\nax.plot(center_point.x, center_point.y, 'r*', markersize=28, markeredgecolor='white', label='Origin', zorder=4)\n\n# Basemap for context\nctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron, alpha=0.6)\n\nax.set_title('Multimodal Accessibility Isochrones\\nWalk + Transit Travel Times from London Center', fontsize=16, color='black', pad=18)\nax.legend(loc='upper right', framealpha=0.9)\nax.axis('off')\nplt.tight_layout()\nplt.show()\n</pre> fig, ax = plt.subplots(figsize=(16, 14))  multi_colors = ['#ff6b6b', '#48dbfb', '#1dd1a1'] labels_ordered = list(multimodal_isochrones.keys())  # Plot larger thresholds first for layering for label, color in zip(reversed(labels_ordered), reversed(multi_colors)):     iso_gdf = multimodal_isochrones[label]     iso_gdf.plot(         ax=ax,         alpha=0.35,         color=color,         edgecolor='#111111',         linewidth=1.25,         label=label,         zorder=2,     )  # Origin marker ax.plot(center_point.x, center_point.y, 'r*', markersize=28, markeredgecolor='white', label='Origin', zorder=4)  # Basemap for context ctx.add_basemap(ax, crs=travel_nodes.crs, source=ctx.providers.CartoDB.Positron, alpha=0.6)  ax.set_title('Multimodal Accessibility Isochrones\\nWalk + Transit Travel Times from London Center', fontsize=16, color='black', pad=18) ax.legend(loc='upper right', framealpha=0.9) ax.axis('off') plt.tight_layout() plt.show() <pre>/var/folders/_n/l2f9tkgn3g17dj7hnsjprssc0000gn/T/ipykernel_85849/3780161585.py:26: UserWarning: Legend does not support handles for PatchCollection instances.\nSee: https://matplotlib.org/stable/tutorials/intermediate/legend_guide.html#implementing-a-custom-legend-handler\n  ax.legend(loc='upper right', framealpha=0.9)\n</pre>"},{"location":"examples/gtfs.html#transportation-network-analysis-with-city2graph","title":"Transportation Network Analysis with City2Graph\u00b6","text":"<p>This notebook demonstrates the power of City2Graph for processing and analyzing public transportation networks. We'll use the General Transit Feed Specification (GTFS) data format to showcase how City2Graph transforms complex transit schedules into intuitive graph representations suitable for:</p> <ul> <li>Urban accessibility analysis - Understanding travel patterns and reachability</li> <li>Network visualization - Creating compelling maps of transit flows</li> <li>Graph neural networks - Converting transportation data into ML-ready formats</li> <li>Spatial analysis - Examining the relationship between transit and urban morphology</li> </ul> <p>The City2Graph library simplifies the complex process of converting GTFS data into actionable insights, making transportation network analysis accessible to researchers, planners, and data scientists.</p>"},{"location":"examples/gtfs.html#1-environment-setup-and-dependencies","title":"1. Environment Setup and Dependencies\u00b6","text":"<p>Before we dive into transportation analysis, let's import the necessary libraries. City2Graph integrates seamlessly with the geospatial Python ecosystem, building on familiar tools like GeoPandas, Shapely, and NetworkX.</p>"},{"location":"examples/gtfs.html#2-loading-gtfs-data-with-city2graph","title":"2. Loading GTFS Data with City2Graph\u00b6","text":""},{"location":"examples/gtfs.html#what-is-gtfs","title":"What is GTFS?\u00b6","text":"<p>The General Transit Feed Specification (GTFS) is the global standard for public transportation schedules and geographic information. GTFS data contains multiple interconnected tables describing:</p> <ul> <li>Routes: Transit lines (bus routes, train lines, etc.)</li> <li>Stops: Physical locations where passengers board/alight</li> <li>Trips: Individual vehicle journeys along routes</li> <li>Stop times: Scheduled arrival/departure times at each stop</li> <li>Calendar: Service patterns (weekdays, weekends, holidays)</li> </ul>"},{"location":"examples/gtfs.html#city2graphs-gtfs-advantage","title":"City2Graph's GTFS Advantage\u00b6","text":"<p>While GTFS data is powerful, it's typically stored as separate CSV files that require complex joins and processing. City2Graph simplifies this workflow by:</p> <ol> <li>Automatic parsing of zipped GTFS files</li> <li>Spatial integration - converting coordinates to proper GeoDataFrames</li> <li>Data validation and type coercion for reliable analysis</li> <li>Seamless integration with the Python geospatial stack with compatibility to GeoDataFrame, nx.MultiGraph, PyTorch Geometric Data(), etc.</li> </ol> <p>Let's see this in action with Transport for London data:</p>"},{"location":"examples/gtfs.html#understanding-the-gtfs-data-structure","title":"Understanding the GTFS Data Structure\u00b6","text":"<p>City2Graph's <code>load_gtfs()</code> function returns a dictionary where each key corresponds to a GTFS table. The stops table is automatically converted to a GeoDataFrame with proper spatial coordinates, making it immediately ready for geospatial analysis.</p> <p>Let's explore each component to understand how transit systems are structured:</p> <ul> <li>calendar: This table provides the service schedules for the transit agency. It indicates the days of the week and dates when services are available.</li> <li>trip: This table gives details about individual trips, including the route, service times, and other trip-specific information.</li> <li>route: This table contains information about the routes that are part of the transit system, such as the route number and description.</li> <li>stop_times: This table lists the times that vehicles stop at each stop on a trip, allowing for precise tracking of transit schedules.</li> </ul> <p>Together, these components offer a comprehensive view of the transit system's operations, enabling effective analysis and visualization.</p>"},{"location":"examples/gtfs.html#3-creating-transit-graphs-with-city2graph","title":"3. Creating Transit Graphs with City2Graph\u00b6","text":""},{"location":"examples/gtfs.html#the-power-of-graph-representation","title":"The Power of Graph Representation\u00b6","text":"<p>Raw GTFS data contains thousands of individual trips and stop times, but what we really want to understand are the connections and flow patterns in the network. This is where City2Graph shines - it transforms complex scheduling data into clean graph representations.</p>"},{"location":"examples/gtfs.html#4-network-centrality-analysis","title":"4. Network Centrality Analysis\u00b6","text":"<p>We can now visualize the network structure using the calculated betweenness centrality. Nodes with higher centrality (key hubs) will be highlighted with brighter colors, while edge thickness represents service frequency. This visualization helps identify the most critical stops and connections that serve as bridges in the London transit network.</p>"},{"location":"examples/gtfs.html#6-accessibility-analysis-with-isochrones","title":"6. Accessibility Analysis with Isochrones\u00b6","text":""},{"location":"examples/gtfs.html#understanding-isochrones","title":"Understanding Isochrones\u00b6","text":"<p>An isochrone is a contour line connecting points that are equally accessible (by travel time) from a given origin. In transportation networks, isochrones reveal the \"reachability\" from a central location - showing how far passengers can travel within a specific time limit.</p> <p>Why isochrones matter:</p> <ul> <li>Accessibility assessment - Which neighborhoods are within 15 minutes of transit?</li> <li>Equity analysis - Identifying underserved areas with limited transit access</li> <li>Urban planning - Informing decisions about transit infrastructure investment</li> <li>Station placement - Understanding which locations serve the widest catchment</li> </ul> <p>City2Graph's <code>create_isochrone()</code> function simplifies this complex spatial analysis, automatically:</p> <ol> <li>Building travel time relationships from the transit network</li> <li>Finding all reachable stops within a travel time threshold</li> <li>Generating smooth boundary polygons around reachable areas</li> <li>Supporting multiple polygon generation methods (concave hull, alpha shape, convex hull, buffer)</li> <li>Supporting heterogeneous graphs with multimodal situation (bus, street, etc.)</li> </ol>"},{"location":"examples/gtfs.html#isochrones-on-street-networks-walking-distance","title":"Isochrones on Street Networks (Walking Distance)\u00b6","text":"<p>To see different accessibility by walking distance, we introduce streets network using <code>osmnx</code>.</p>"},{"location":"examples/gtfs.html#isochrones-on-the-heterogeneous-street-transit-graph","title":"Isochrones on the Heterogeneous (Street + Transit) Graph\u00b6","text":"<p>Now that we have a multimodal graph combining street intersections and bus stations, we can compute isochrones using <code>travel_time_sec</code> across all edge types. This shows walk-to-transit accessibility with realistic travel times.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html","title":"Morphology","text":"In\u00a0[1]: Copied! <pre># Core libraries\nimport numpy as np\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as cx\nfrom shapely import Point\n\n# city2graph for morphological graph analysis\nimport city2graph as c2g\n\n# Configure matplotlib for high-quality visualizations\nplt.rcParams['figure.figsize'] = (14, 10)\nplt.rcParams['figure.dpi'] = 100\nplt.rcParams['font.size'] = 11\nplt.style.use('ggplot')\n\nprint(\"\u2705 Dependencies loaded successfully\")\nprint(f\"city2graph version: {c2g.__version__}\")\nprint(f\"geopandas version: {gpd.__version__}\")\n</pre> # Core libraries import numpy as np import geopandas as gpd import matplotlib.pyplot as plt import contextily as cx from shapely import Point  # city2graph for morphological graph analysis import city2graph as c2g  # Configure matplotlib for high-quality visualizations plt.rcParams['figure.figsize'] = (14, 10) plt.rcParams['figure.dpi'] = 100 plt.rcParams['font.size'] = 11 plt.style.use('ggplot')  print(\"\u2705 Dependencies loaded successfully\") print(f\"city2graph version: {c2g.__version__}\") print(f\"geopandas version: {gpd.__version__}\") <pre>\u2705 Dependencies loaded successfully\ncity2graph version: 0.1.7\ngeopandas version: 1.1.1\n</pre> In\u00a0[\u00a0]: Copied! <pre># Download data from Overture Maps (uncomment to download fresh data)\n# This downloads building footprints, road segments, and connectors for Liverpool city centre\n\nbbox = [-3.090173, 53.355487, -2.917138, 53.465587]  # Liverpool city centre bounding box\n\nc2g.load_overture_data(\n    area=bbox,\n    types=[\"segment\", \"building\", \"connector\"],\n    output_dir=\"./data/overturemaps\",\n    prefix=\"liverpool_\",\n    save_to_file=True,\n    return_data=False,\n)\n\nprint(\"Data loading configuration complete\")\nprint(\"To download fresh data, uncomment the city2graph.load_overture_data() call above\")\n</pre> # Download data from Overture Maps (uncomment to download fresh data) # This downloads building footprints, road segments, and connectors for Liverpool city centre  bbox = [-3.090173, 53.355487, -2.917138, 53.465587]  # Liverpool city centre bounding box  c2g.load_overture_data(     area=bbox,     types=[\"segment\", \"building\", \"connector\"],     output_dir=\"./data/overturemaps\",     prefix=\"liverpool_\",     save_to_file=True,     return_data=False, )  print(\"Data loading configuration complete\") print(\"To download fresh data, uncomment the city2graph.load_overture_data() call above\")  <pre>Data loading configuration complete\nTo download fresh data, uncomment the city2graph.load_overture_data() call above\n</pre> In\u00a0[3]: Copied! <pre># Load the downloaded GeoJSON files\nbuildings_gdf = gpd.read_file(\"./data/overturemaps/liverpool_building.geojson\")\nsegments_gdf = gpd.read_file(\"./data/overturemaps/liverpool_segment.geojson\") \nconnectors_gdf = gpd.read_file(\"./data/overturemaps/liverpool_connector.geojson\")\n\n# Convert to British National Grid (EPSG:27700) for accurate distance calculations\nbuildings_gdf = buildings_gdf.to_crs(epsg=27700)\nsegments_gdf = segments_gdf.to_crs(epsg=27700)\nconnectors_gdf = connectors_gdf.to_crs(epsg=27700)\n\nprint(\"\u2705 Data loaded successfully!\")\nprint(f\"\ud83d\udcca Dataset summary:\")\nprint(f\"   \u2022 Buildings: {len(buildings_gdf):,}\")\nprint(f\"   \u2022 Road segments: {len(segments_gdf):,}\")\nprint(f\"   \u2022 Connectors: {len(connectors_gdf):,}\")\nprint(f\"   \u2022 CRS: {buildings_gdf.crs}\")\n</pre> # Load the downloaded GeoJSON files buildings_gdf = gpd.read_file(\"./data/overturemaps/liverpool_building.geojson\") segments_gdf = gpd.read_file(\"./data/overturemaps/liverpool_segment.geojson\")  connectors_gdf = gpd.read_file(\"./data/overturemaps/liverpool_connector.geojson\")  # Convert to British National Grid (EPSG:27700) for accurate distance calculations buildings_gdf = buildings_gdf.to_crs(epsg=27700) segments_gdf = segments_gdf.to_crs(epsg=27700) connectors_gdf = connectors_gdf.to_crs(epsg=27700)  print(\"\u2705 Data loaded successfully!\") print(f\"\ud83d\udcca Dataset summary:\") print(f\"   \u2022 Buildings: {len(buildings_gdf):,}\") print(f\"   \u2022 Road segments: {len(segments_gdf):,}\") print(f\"   \u2022 Connectors: {len(connectors_gdf):,}\") print(f\"   \u2022 CRS: {buildings_gdf.crs}\") <pre>\u2705 Data loaded successfully!\n\ud83d\udcca Dataset summary:\n   \u2022 Buildings: 132,549\n   \u2022 Road segments: 38,523\n   \u2022 Connectors: 48,758\n   \u2022 CRS: EPSG:27700\n</pre> In\u00a0[4]: Copied! <pre># Filter to keep only road segments (excluding pedestrian paths, railways, etc.)\nsegments_gdf = segments_gdf[segments_gdf[\"subtype\"] == \"road\"].copy()\n\n# Process segments to handle bridges/tunnels and create proper spatial barriers\nsegments_gdf = c2g.process_overture_segments(\n    segments_gdf=segments_gdf,\n    get_barriers=True,\n    connectors_gdf=connectors_gdf\n)\n\nprint(f\"\u2705 Processed {len(segments_gdf)} road segments\")\nprint(f\"\ud83d\udcc8 Barrier geometries created for tessellation\")\n\n# Check the geometry types in the barrier_geometry column\ngeometry_types = segments_gdf[\"barrier_geometry\"].geom_type.value_counts()\nprint(f\"\\n\ud83d\udd0d Barrier geometry types:\")\nfor geom_type, count in geometry_types.items():\n    print(f\"   \u2022 {geom_type}: {count:,}\")\n</pre> # Filter to keep only road segments (excluding pedestrian paths, railways, etc.) segments_gdf = segments_gdf[segments_gdf[\"subtype\"] == \"road\"].copy()  # Process segments to handle bridges/tunnels and create proper spatial barriers segments_gdf = c2g.process_overture_segments(     segments_gdf=segments_gdf,     get_barriers=True,     connectors_gdf=connectors_gdf )  print(f\"\u2705 Processed {len(segments_gdf)} road segments\") print(f\"\ud83d\udcc8 Barrier geometries created for tessellation\")  # Check the geometry types in the barrier_geometry column geometry_types = segments_gdf[\"barrier_geometry\"].geom_type.value_counts() print(f\"\\n\ud83d\udd0d Barrier geometry types:\") for geom_type, count in geometry_types.items():     print(f\"   \u2022 {geom_type}: {count:,}\") <pre>\u2705 Processed 63819 road segments\n\ud83d\udcc8 Barrier geometries created for tessellation\n\n\ud83d\udd0d Barrier geometry types:\n   \u2022 LineString: 62,869\n   \u2022 MultiLineString: 531\n</pre> <p>You can convert these segments to a (homogeneous) graph using the <code>segments_to_graph</code> function. Note that this function can be applied for any segments GeoDataFrame, not only for segments derived from OvertureMaps.</p> In\u00a0[5]: Copied! <pre>segments_G = c2g.segments_to_graph(segments_gdf, as_nx=True)\n</pre> segments_G = c2g.segments_to_graph(segments_gdf, as_nx=True) <pre>Removed 9 invalid geometries\n</pre> In\u00a0[6]: Copied! <pre>c2g.plot_graph(segments_G)\n</pre> c2g.plot_graph(segments_G) Out[6]: <pre>&lt;Axes: &gt;</pre> In\u00a0[7]: Copied! <pre># Define center point for the analysis area (Liverpool city centre)\ncenter_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)\n\n# Create the morphological graph\nmorpho_nodes, morpho_edges = c2g.morphological_graph(\n    buildings_gdf=buildings_gdf,\n    segments_gdf=segments_gdf,\n    center_point=center_point,\n    distance=500,                    # Analysis radius in meters\n    clipping_buffer=300,            # Buffer for edge effects\n    primary_barrier_col='barrier_geometry',\n    contiguity=\"queen\",             # Adjacency rule for tessellation\n    keep_buildings=True,            # Preserve building geometries\n)\n</pre> # Define center point for the analysis area (Liverpool city centre) center_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)  # Create the morphological graph morpho_nodes, morpho_edges = c2g.morphological_graph(     buildings_gdf=buildings_gdf,     segments_gdf=segments_gdf,     center_point=center_point,     distance=500,                    # Analysis radius in meters     clipping_buffer=300,            # Buffer for edge effects     primary_barrier_col='barrier_geometry',     contiguity=\"queen\",             # Adjacency rule for tessellation     keep_buildings=True,            # Preserve building geometries ) <pre>Removed 9 invalid geometries\n/Users/yutasato/Projects/Liverpool/city2graph/.venv/lib/python3.13/site-packages/libpysal/weights/contiguity.py:347: UserWarning: The weights matrix is not fully connected: \n There are 3 disconnected components.\n There are 2 islands with ids: 32_107405, 32_107413.\n  W.__init__(self, neighbors, ids=ids, **kw)\n</pre> In\u00a0[8]: Copied! <pre>print(f\"Node types: {list(morpho_nodes.keys())}\")\nprint(f\"Edge types: {list(morpho_edges.keys())}\")\nprint(f\"Private spaces: {len(morpho_nodes['private']):,}\")\nprint(f\"Public spaces: {len(morpho_nodes['public']):,}\")\n\nfor edge_type, edge_gdf in morpho_edges.items():\n    print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\")\n</pre> print(f\"Node types: {list(morpho_nodes.keys())}\") print(f\"Edge types: {list(morpho_edges.keys())}\") print(f\"Private spaces: {len(morpho_nodes['private']):,}\") print(f\"Public spaces: {len(morpho_nodes['public']):,}\")  for edge_type, edge_gdf in morpho_edges.items():     print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\") <pre>Node types: ['private', 'public']\nEdge types: [('private', 'touched_to', 'private'), ('public', 'connected_to', 'public'), ('private', 'faced_to', 'public')]\nPrivate spaces: 1,342\nPublic spaces: 801\n   \u2022 ('private', 'touched_to', 'private'): 615 connections\n   \u2022 ('public', 'connected_to', 'public'): 1,475 connections\n   \u2022 ('private', 'faced_to', 'public'): 2,503 connections\n</pre> In\u00a0[9]: Copied! <pre>morpho_nodes[\"private\"].head()\n</pre> morpho_nodes[\"private\"].head() Out[9]: geometry enclosure_index id version sources level subtype class height names ... facade_color facade_material roof_material roof_shape roof_direction roof_orientation roof_color roof_height building_geometry tessellation_geometry private_id 12_31956 POINT (334727.903 390226.444) 12 c904b7f1-c8dc-4892-bc1d-c40589a14df2 2.0 [{'property': '', 'dataset': 'OpenStreetMap', ... NaN commercial retail 22.054096 {'primary': 'Primark', 'common': None, 'rules'... ... None None None None NaN None None NaN POLYGON ((334741.448 390215.167, 334756.666 39... POLYGON ((334755.579 390206.699, 334741.754 39... 12_31956 POINT (334727.903 390226.444) 12 dc8bce71-dc2c-4f77-aef2-38d97e5587ad 1.0 [{'property': '', 'dataset': 'OpenStreetMap', ... NaN None None NaN None ... None None None None NaN None None NaN POLYGON ((334765.068 390239.944, 334756.666 39... POLYGON ((334755.579 390206.699, 334741.754 39... 12_31957 POINT (334783.221 390224.611) 12 6e125793-4950-4b77-a574-98bf89e02f7a 1.0 [{'property': '', 'dataset': 'OpenStreetMap', ... NaN None None NaN {'primary': 'Pauline Books &amp; Media', 'common':... ... None None None None NaN None None NaN POLYGON ((334808.007 390196.826, 334817.382 39... POLYGON ((334768.613 390253.5, 334803.709 3902... 12_31957 POINT (334783.221 390224.611) 12 c904b7f1-c8dc-4892-bc1d-c40589a14df2 2.0 [{'property': '', 'dataset': 'OpenStreetMap', ... NaN commercial retail 22.054096 {'primary': 'Primark', 'common': None, 'rules'... ... None None None None NaN None None NaN POLYGON ((334741.448 390215.167, 334756.666 39... POLYGON ((334768.613 390253.5, 334803.709 3902... 12_31957 POINT (334783.221 390224.611) 12 dc8bce71-dc2c-4f77-aef2-38d97e5587ad 1.0 [{'property': '', 'dataset': 'OpenStreetMap', ... NaN None None NaN None ... None None None None NaN None None NaN POLYGON ((334765.068 390239.944, 334756.666 39... POLYGON ((334768.613 390253.5, 334803.709 3902... <p>5 rows \u00d7 25 columns</p> In\u00a0[10]: Copied! <pre>morpho_nodes[\"public\"].head()\n</pre> morpho_nodes[\"public\"].head() Out[10]: id version sources subtype class names connectors routes subclass_rules access_restrictions ... road_flags speed_limits width_rules subclass geometry split_from split_to length barrier_geometry segment_geometry public_id 56159 a5e01c9b-5290-4eab-a020-ee9e7e157760_1 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road unclassified {'primary': 'Tower Gardens', 'common': None, '... [{'connector_id': '137acfba-67ce-4882-9720-be9... None None None ... None None None None POINT (334032.697 390390.027) 0.000000 0.127877 7.849774 LINESTRING (334034.687 390386.645, 334030.706 ... LINESTRING (334034.687 390386.645, 334030.706 ... 56180 d9dca30b-31ca-4d72-8c6f-b2e6195ae33d_1 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road primary {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': '137acfba-67ce-4882-9720-be9... [{'name': None, 'network': None, 'ref': 'A57',... None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334018.757 390377.991) 0.000000 0.725988 36.258554 LINESTRING (334034.687 390386.645, 334005.825 ... LINESTRING (334034.687 390386.645, 334005.825 ... 56391 4704f2a4-75b5-47d4-9270-4261f9459742 1 [{'property': 'routes', 'dataset': 'OpenStreet... road primary {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'a62ffd87-a56f-4a02-bf30-67d... [{'name': None, 'network': None, 'ref': 'A57',... None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334041.874 390390.851) NaN NaN 16.653532 LINESTRING (334049.06 390395.057, 334034.687 3... LINESTRING (334049.06 390395.057, 334034.687 3... 56178 66a3f6ca-888c-43cd-bc30-50dff8d09325_5 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road cycleway {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'ff54a37c-c0b9-4338-be77-b37... None None [{'access_type': 'denied', 'when': {'during': ... ... None None None None POINT (334015.167 390383.574) 0.332346 0.591025 36.779102 LINESTRING (333999.652 390373.703, 333999.652 ... LINESTRING (333999.652 390373.703, 333999.652 ... 56179 66a3f6ca-888c-43cd-bc30-50dff8d09325_6 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road cycleway {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'ff54a37c-c0b9-4338-be77-b37... None None [{'access_type': 'denied', 'when': {'during': ... ... None None None None POINT (334055.463 390408.654) 0.591025 1.000000 58.148253 LINESTRING (334030.706 390393.41, 334030.706 3... LINESTRING (334030.706 390393.41, 334030.706 3... <p>5 rows \u00d7 25 columns</p> In\u00a0[11]: Copied! <pre>morpho_edges[('public', 'connected_to', 'public')].head()\n</pre> morpho_edges[('public', 'connected_to', 'public')].head() Out[11]: geometry from_public_id to_public_id 23570 24229 LINESTRING (334597.772 390729.399, 334589.75 3... 24230 LINESTRING (334597.772 390729.399, 334587.034 ... 24235 LINESTRING (334597.772 390729.399, 334611.822 ... 24255 LINESTRING (334597.772 390729.399, 334582.53 3... 23577 24232 LINESTRING (334615.698 390739.427, 334602.944 ... In\u00a0[12]: Copied! <pre>morpho_edges[('private', 'faced_to', 'public')].head()\n</pre> morpho_edges[('private', 'faced_to', 'public')].head() Out[12]: geometry private_id public_id 183_107526 56159 LINESTRING (334054.645 390363.231, 334032.697 ... 182_-160 56159 LINESTRING (334017.91 390381.351, 334032.697 3... 181_-161 56159 LINESTRING (334058.29 390405.424, 334032.697 3... 180_107446 56159 LINESTRING (333990.617 390408.84, 334032.697 3... 179_107445 56159 LINESTRING (334020.81 390464.168, 334032.697 3... In\u00a0[13]: Copied! <pre>morpho_edges[('private', 'touched_to', 'private')].head()\n</pre> morpho_edges[('private', 'touched_to', 'private')].head() Out[13]: weight geometry enclosure_index from_private_id to_private_id 12_31956 12_31957 55.347745 LINESTRING (334727.903 390226.444, 334783.221 ... 12 12_31957 12_31968 28.277931 LINESTRING (334783.221 390224.611, 334810.774 ... 12 12_31967 12_31968 19.731447 LINESTRING (334829.869 390213.279, 334810.774 ... 12 20_33139 20_33140 7.723210 LINESTRING (334667.044 390104.963, 334659.849 ... 20 20_33142 72.502424 LINESTRING (334667.044 390104.963, 334600.224 ... 20 In\u00a0[14]: Copied! <pre>morpho_nodes[\"public\"]\n</pre> morpho_nodes[\"public\"] Out[14]: id version sources subtype class names connectors routes subclass_rules access_restrictions ... road_flags speed_limits width_rules subclass geometry split_from split_to length barrier_geometry segment_geometry public_id 56159 a5e01c9b-5290-4eab-a020-ee9e7e157760_1 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road unclassified {'primary': 'Tower Gardens', 'common': None, '... [{'connector_id': '137acfba-67ce-4882-9720-be9... None None None ... None None None None POINT (334032.697 390390.027) 0.000000 0.127877 7.849774 LINESTRING (334034.687 390386.645, 334030.706 ... LINESTRING (334034.687 390386.645, 334030.706 ... 56180 d9dca30b-31ca-4d72-8c6f-b2e6195ae33d_1 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road primary {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': '137acfba-67ce-4882-9720-be9... [{'name': None, 'network': None, 'ref': 'A57',... None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334018.757 390377.991) 0.000000 0.725988 36.258554 LINESTRING (334034.687 390386.645, 334005.825 ... LINESTRING (334034.687 390386.645, 334005.825 ... 56391 4704f2a4-75b5-47d4-9270-4261f9459742 1 [{'property': 'routes', 'dataset': 'OpenStreet... road primary {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'a62ffd87-a56f-4a02-bf30-67d... [{'name': None, 'network': None, 'ref': 'A57',... None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334041.874 390390.851) NaN NaN 16.653532 LINESTRING (334049.06 390395.057, 334034.687 3... LINESTRING (334049.06 390395.057, 334034.687 3... 56178 66a3f6ca-888c-43cd-bc30-50dff8d09325_5 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road cycleway {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'ff54a37c-c0b9-4338-be77-b37... None None [{'access_type': 'denied', 'when': {'during': ... ... None None None None POINT (334015.167 390383.574) 0.332346 0.591025 36.779102 LINESTRING (333999.652 390373.703, 333999.652 ... LINESTRING (333999.652 390373.703, 333999.652 ... 56179 66a3f6ca-888c-43cd-bc30-50dff8d09325_6 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road cycleway {'primary': 'Water Street', 'common': None, 'r... [{'connector_id': 'ff54a37c-c0b9-4338-be77-b37... None None [{'access_type': 'denied', 'when': {'during': ... ... None None None None POINT (334055.463 390408.654) 0.591025 1.000000 58.148253 LINESTRING (334030.706 390393.41, 334030.706 3... LINESTRING (334030.706 390393.41, 334030.706 3... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 55826 c91bfcc0-f0c3-4d8b-86f0-219e304ea73c_1 2 [{'property': '', 'dataset': 'OpenStreetMap', ... road trunk {'primary': 'Strand Street', 'common': None, '... [{'connector_id': '462f0807-4888-4a3c-bd91-e7d... None None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334126.221 390166.28) 0.000000 0.519847 42.759490 LINESTRING (334112.436 390182.618, 334116.051 ... LINESTRING (334112.436 390182.618, 334116.051 ... 55839 bf145e29-c53d-44d2-9a78-c0546b071a40_1 2 [{'property': '', 'dataset': 'OpenStreetMap', ... road trunk {'primary': 'Strand Street', 'common': None, '... [{'connector_id': '3617e7cc-e871-45f5-a8a4-ccb... None None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (334095.885 390172.017) 0.000000 0.672058 40.225191 LINESTRING (334108.506 390156.357, 334086.439 ... LINESTRING (334108.506 390156.357, 334086.439 ... 55846 3484a50c-97cc-419d-98d4-504e6cf2db09_4 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road footway None [{'connector_id': '6a832436-a808-439b-9379-e16... None None None ... None None None None POINT (334080.751 390185.634) 0.694893 0.766920 6.367964 LINESTRING (334078.252 390183.661, 334078.253 ... LINESTRING (334078.252 390183.661, 334078.253 ... 55845 3484a50c-97cc-419d-98d4-504e6cf2db09_3 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road footway None [{'connector_id': '6a832436-a808-439b-9379-e16... None None None ... None None None None POINT (334073.571 390180.984) 0.572882 0.694893 10.786927 LINESTRING (334068.889 390178.306, 334068.889 ... LINESTRING (334068.889 390178.306, 334068.889 ... 55856 d45a56ad-c452-46a6-ab9d-42ec9f35bb54_1 1 [{'property': '', 'dataset': 'OpenStreetMap', ... road unclassified {'primary': 'George's Dock Way', 'common': Non... [{'connector_id': '16a1387d-5006-4ed0-8760-668... None None [{'access_type': 'denied', 'when': {'during': ... ... None [{'min_speed': None, 'max_speed': {'value': 30... None None POINT (333974.723 390256.75) 0.000000 0.041809 8.512544 LINESTRING (333971.855 390259.894, 333977.592 ... LINESTRING (333971.855 390259.894, 333977.592 ... <p>801 rows \u00d7 25 columns</p> In\u00a0[15]: Copied! <pre>fig, ax = plt.subplots(figsize=(14, 12), facecolor='#f9f9f9')\n\nmorpho_nodes[\"private\"][\"building_geometry\"].plot(ax=ax, color='#e0e0e0', edgecolor='#c0c0c0', linewidth=0.3, alpha=0.7)\nmorpho_nodes[\"public\"][\"segment_geometry\"].plot(ax=ax, color='#404040', linewidth=0.7, alpha=0.6)\n\nc2g.plot_graph(\n    nodes=morpho_nodes,\n    edges=morpho_edges,\n    subplots=False,\n    ax=ax,\n    bgcolor=\"#f9f9f9\",\n    labelcolor=\"#000000\",\n    node_color={'private': 'red', 'public': 'blue'},\n    edge_color={\n        ('private', 'touched_to', 'private'): '#B22222',\n        ('public', 'connected_to', 'public'): '#0000FF',\n        ('private', 'faced_to', 'public'): '#7B68EE',\n    },\n    markersize=10,\n    linewidth=0.2,\n)\n</pre> fig, ax = plt.subplots(figsize=(14, 12), facecolor='#f9f9f9')  morpho_nodes[\"private\"][\"building_geometry\"].plot(ax=ax, color='#e0e0e0', edgecolor='#c0c0c0', linewidth=0.3, alpha=0.7) morpho_nodes[\"public\"][\"segment_geometry\"].plot(ax=ax, color='#404040', linewidth=0.7, alpha=0.6)  c2g.plot_graph(     nodes=morpho_nodes,     edges=morpho_edges,     subplots=False,     ax=ax,     bgcolor=\"#f9f9f9\",     labelcolor=\"#000000\",     node_color={'private': 'red', 'public': 'blue'},     edge_color={         ('private', 'touched_to', 'private'): '#B22222',         ('public', 'connected_to', 'public'): '#0000FF',         ('private', 'faced_to', 'public'): '#7B68EE',     },     markersize=10,     linewidth=0.2, ) Out[15]: <pre>&lt;Axes: &gt;</pre> In\u00a0[16]: Copied! <pre># Check for PyTorch Geometric availability\nimport torch\n\ntry:\n    import torch_geometric\n    HAS_TORCH_GEOMETRIC = True\n    print(\"\u2705 PyTorch Geometric successfully imported\")\n    print(f\"   PyTorch version: {torch.__version__}\")\n    print(f\"   PyTorch Geometric version: {torch_geometric.__version__}\")\n    print(\"\ud83d\ude80 Ready for graph representation learning!\")\nexcept ImportError:\n    HAS_TORCH_GEOMETRIC = False\n    print(\"\u26a0\ufe0f  PyTorch Geometric not installed\")\n    print(\"   Install with: pip install torch-geometric\")\n    print(\"   Graph functionality will be limited to NetworkX\")\n</pre> # Check for PyTorch Geometric availability import torch  try:     import torch_geometric     HAS_TORCH_GEOMETRIC = True     print(\"\u2705 PyTorch Geometric successfully imported\")     print(f\"   PyTorch version: {torch.__version__}\")     print(f\"   PyTorch Geometric version: {torch_geometric.__version__}\")     print(\"\ud83d\ude80 Ready for graph representation learning!\") except ImportError:     HAS_TORCH_GEOMETRIC = False     print(\"\u26a0\ufe0f  PyTorch Geometric not installed\")     print(\"   Install with: pip install torch-geometric\")     print(\"   Graph functionality will be limited to NetworkX\") <pre>\u2705 PyTorch Geometric successfully imported\n   PyTorch version: 2.9.1\n   PyTorch Geometric version: 2.7.0\n\ud83d\ude80 Ready for graph representation learning!\n</pre> In\u00a0[17]: Copied! <pre># Compute spatial features for private spaces (tessellation cells)\nmorpho_nodes[\"private\"][\"area\"] = morpho_nodes[\"private\"].geometry.area\nmorpho_nodes[\"private\"][\"perimeter\"] = morpho_nodes[\"private\"].geometry.length\nmorpho_nodes[\"private\"][\"compactness\"] = (\n    4 * np.pi * morpho_nodes[\"private\"][\"area\"] / (morpho_nodes[\"private\"][\"perimeter\"] ** 2)\n)\n\nprint(\"\ud83d\udcca Computed spatial features for private spaces:\")\nfeature_stats = morpho_nodes[\"private\"][['area', 'perimeter', 'compactness']].describe()\nprint(feature_stats.round(2))\n\n# Set proper index names for graph conversion\nmorpho_nodes[\"private\"].index.name = \"tess_id\"\nmorpho_edges[('private', 'touched_to', 'private')].index.names = ['from_private_id', 'to_private_id']\n\nprint(\"\\n\u2705 Features computed and indices configured\")\n</pre> # Compute spatial features for private spaces (tessellation cells) morpho_nodes[\"private\"][\"area\"] = morpho_nodes[\"private\"].geometry.area morpho_nodes[\"private\"][\"perimeter\"] = morpho_nodes[\"private\"].geometry.length morpho_nodes[\"private\"][\"compactness\"] = (     4 * np.pi * morpho_nodes[\"private\"][\"area\"] / (morpho_nodes[\"private\"][\"perimeter\"] ** 2) )  print(\"\ud83d\udcca Computed spatial features for private spaces:\") feature_stats = morpho_nodes[\"private\"][['area', 'perimeter', 'compactness']].describe() print(feature_stats.round(2))  # Set proper index names for graph conversion morpho_nodes[\"private\"].index.name = \"tess_id\" morpho_edges[('private', 'touched_to', 'private')].index.names = ['from_private_id', 'to_private_id']  print(\"\\n\u2705 Features computed and indices configured\") <pre>\ud83d\udcca Computed spatial features for private spaces:\n         area  perimeter  compactness\ncount  1342.0     1342.0          0.0\nmean      0.0        0.0          NaN\nstd       0.0        0.0          NaN\nmin       0.0        0.0          NaN\n25%       0.0        0.0          NaN\n50%       0.0        0.0          NaN\n75%       0.0        0.0          NaN\nmax       0.0        0.0          NaN\n\n\u2705 Features computed and indices configured\n</pre> In\u00a0[18]: Copied! <pre>if HAS_TORCH_GEOMETRIC:\n    # Create homogeneous graph of private spaces\n    private_graph = c2g.gdf_to_pyg(\n        nodes=morpho_nodes[\"private\"],\n        edges=morpho_edges[('private', 'touched_to', 'private')],\n        node_feature_cols=['area', 'perimeter', 'compactness'],\n        edge_feature_cols=None\n    )\n    \n    print(\"\ud83c\udfaf Created homogeneous graph:\")\n    print(f\"   \u2022 Nodes: {private_graph.num_nodes:,}\")\n    print(f\"   \u2022 Edges: {private_graph.num_edges:,}\")\n    print(f\"   \u2022 Node features: {private_graph.x.shape[1]} dimensions\")\n    print(f\"   \u2022 Feature tensor shape: {private_graph.x.shape}\")\n    print(\"\\n\u2705 Ready for graph neural network training!\")\n    \nelse:\n    print(\"\u26a0\ufe0f Skipping PyTorch Geometric conversion (not installed)\")\n    private_graph = None\n</pre> if HAS_TORCH_GEOMETRIC:     # Create homogeneous graph of private spaces     private_graph = c2g.gdf_to_pyg(         nodes=morpho_nodes[\"private\"],         edges=morpho_edges[('private', 'touched_to', 'private')],         node_feature_cols=['area', 'perimeter', 'compactness'],         edge_feature_cols=None     )          print(\"\ud83c\udfaf Created homogeneous graph:\")     print(f\"   \u2022 Nodes: {private_graph.num_nodes:,}\")     print(f\"   \u2022 Edges: {private_graph.num_edges:,}\")     print(f\"   \u2022 Node features: {private_graph.x.shape[1]} dimensions\")     print(f\"   \u2022 Feature tensor shape: {private_graph.x.shape}\")     print(\"\\n\u2705 Ready for graph neural network training!\")      else:     print(\"\u26a0\ufe0f Skipping PyTorch Geometric conversion (not installed)\")     private_graph = None <pre>\ud83c\udfaf Created homogeneous graph:\n   \u2022 Nodes: 1,342\n   \u2022 Edges: 615\n   \u2022 Node features: 3 dimensions\n   \u2022 Feature tensor shape: torch.Size([1342, 3])\n\n\u2705 Ready for graph neural network training!\n</pre> In\u00a0[19]: Copied! <pre># Define center point for the analysis area (Liverpool city centre)\ncenter_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)\n\n# Create the morphological graph\nprint(\"\ud83c\udfd7\ufe0f  Creating morphological graph...\")\nmorpho_nodes, morpho_edges = c2g.morphological_graph(\n    buildings_gdf=buildings_gdf,\n    segments_gdf=segments_gdf,\n    center_point=center_point,\n    distance=500,                    # Analysis radius in meters\n    clipping_buffer=300,            # Buffer for edge effects\n    primary_barrier_col='barrier_geometry',\n    contiguity=\"queen\",             # Adjacency rule for tessellation\n    keep_buildings=True,            # Preserve building geometries\n)\n\nprint(\"\u2705 Morphological graph created successfully!\")\nprint(f\"\ud83d\udcca Network summary:\")\nprint(f\"   \u2022 Node types: {list(morpho_nodes.keys())}\")\nprint(f\"   \u2022 Edge types: {list(morpho_edges.keys())}\")\nprint(f\"   \u2022 Private spaces: {len(morpho_nodes['private']):,}\")\nprint(f\"   \u2022 Public spaces: {len(morpho_nodes['public']):,}\")\n\nfor edge_type, edge_gdf in morpho_edges.items():\n    print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\")\n</pre> # Define center point for the analysis area (Liverpool city centre) center_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)  # Create the morphological graph print(\"\ud83c\udfd7\ufe0f  Creating morphological graph...\") morpho_nodes, morpho_edges = c2g.morphological_graph(     buildings_gdf=buildings_gdf,     segments_gdf=segments_gdf,     center_point=center_point,     distance=500,                    # Analysis radius in meters     clipping_buffer=300,            # Buffer for edge effects     primary_barrier_col='barrier_geometry',     contiguity=\"queen\",             # Adjacency rule for tessellation     keep_buildings=True,            # Preserve building geometries )  print(\"\u2705 Morphological graph created successfully!\") print(f\"\ud83d\udcca Network summary:\") print(f\"   \u2022 Node types: {list(morpho_nodes.keys())}\") print(f\"   \u2022 Edge types: {list(morpho_edges.keys())}\") print(f\"   \u2022 Private spaces: {len(morpho_nodes['private']):,}\") print(f\"   \u2022 Public spaces: {len(morpho_nodes['public']):,}\")  for edge_type, edge_gdf in morpho_edges.items():     print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\") <pre>Removed 9 invalid geometries\n</pre> <pre>\ud83c\udfd7\ufe0f  Creating morphological graph...\n\u2705 Morphological graph created successfully!\n\ud83d\udcca Network summary:\n   \u2022 Node types: ['private', 'public']\n   \u2022 Edge types: [('private', 'touched_to', 'private'), ('public', 'connected_to', 'public'), ('private', 'faced_to', 'public')]\n   \u2022 Private spaces: 1,342\n   \u2022 Public spaces: 801\n   \u2022 ('private', 'touched_to', 'private'): 615 connections\n   \u2022 ('public', 'connected_to', 'public'): 1,475 connections\n   \u2022 ('private', 'faced_to', 'public'): 2,503 connections\n</pre> <pre>/Users/yutasato/Projects/Liverpool/city2graph/.venv/lib/python3.13/site-packages/libpysal/weights/contiguity.py:347: UserWarning: The weights matrix is not fully connected: \n There are 3 disconnected components.\n There are 2 islands with ids: 32_107405, 32_107413.\n  W.__init__(self, neighbors, ids=ids, **kw)\n</pre> In\u00a0[20]: Copied! <pre># Compute features for public spaces (street segments)\nmorpho_nodes[\"public\"][\"length\"] = morpho_nodes[\"public\"].geometry.length\n\nprint(\"\ud83d\udcca Computed spatial features for public spaces:\")\nprint(f\"   \u2022 Street length statistics:\")\nlength_stats = morpho_nodes[\"public\"][\"length\"].describe()\nprint(f\"     - Mean: {length_stats['mean']:.1f}m\")\nprint(f\"     - Median: {length_stats['50%']:.1f}m\") \nprint(f\"     - Range: {length_stats['min']:.1f}m - {length_stats['max']:.1f}m\")\n\nprint(f\"\\n\u2705 Features ready for heterogeneous graph creation\")\n</pre> # Compute features for public spaces (street segments) morpho_nodes[\"public\"][\"length\"] = morpho_nodes[\"public\"].geometry.length  print(\"\ud83d\udcca Computed spatial features for public spaces:\") print(f\"   \u2022 Street length statistics:\") length_stats = morpho_nodes[\"public\"][\"length\"].describe() print(f\"     - Mean: {length_stats['mean']:.1f}m\") print(f\"     - Median: {length_stats['50%']:.1f}m\")  print(f\"     - Range: {length_stats['min']:.1f}m - {length_stats['max']:.1f}m\")  print(f\"\\n\u2705 Features ready for heterogeneous graph creation\") <pre>\ud83d\udcca Computed spatial features for public spaces:\n   \u2022 Street length statistics:\n     - Mean: 0.0m\n     - Median: 0.0m\n     - Range: 0.0m - 0.0m\n\n\u2705 Features ready for heterogeneous graph creation\n</pre> In\u00a0[21]: Copied! <pre>if HAS_TORCH_GEOMETRIC:\n    # Create heterogeneous graph with all morphological relationships\n    hetero_graph = c2g.gdf_to_pyg(\n        morpho_nodes,\n        morpho_edges,\n        node_feature_cols={\n            \"private\": ['area', 'perimeter', 'compactness'],\n            \"public\": ['length']\n        }\n    )\n    \n    print(\"\ud83c\udf10 Created heterogeneous morphological graph:\")\n    print(f\"   \ud83d\udcca Node types and counts:\")\n    for node_type in hetero_graph.node_types:\n        num_nodes = hetero_graph[node_type].x.shape[0]\n        num_features = hetero_graph[node_type].x.shape[1]\n        print(f\"     \u2022 {node_type}: {num_nodes:,} nodes, {num_features} features\")\n    \n    print(f\"   \ud83d\udd17 Edge types and counts:\")\n    for edge_type in hetero_graph.edge_types:\n        num_edges = hetero_graph[edge_type].edge_index.shape[1]\n        print(f\"     \u2022 {edge_type}: {num_edges:,} edges\")\n    \n    print(\"\\n\u2705 Complete morphological graph ready for heterogeneous GNN training!\")\n    \nelse:\n    print(\"\u26a0\ufe0f Skipping PyTorch Geometric conversion (not installed)\")\n    hetero_graph = None\n</pre> if HAS_TORCH_GEOMETRIC:     # Create heterogeneous graph with all morphological relationships     hetero_graph = c2g.gdf_to_pyg(         morpho_nodes,         morpho_edges,         node_feature_cols={             \"private\": ['area', 'perimeter', 'compactness'],             \"public\": ['length']         }     )          print(\"\ud83c\udf10 Created heterogeneous morphological graph:\")     print(f\"   \ud83d\udcca Node types and counts:\")     for node_type in hetero_graph.node_types:         num_nodes = hetero_graph[node_type].x.shape[0]         num_features = hetero_graph[node_type].x.shape[1]         print(f\"     \u2022 {node_type}: {num_nodes:,} nodes, {num_features} features\")          print(f\"   \ud83d\udd17 Edge types and counts:\")     for edge_type in hetero_graph.edge_types:         num_edges = hetero_graph[edge_type].edge_index.shape[1]         print(f\"     \u2022 {edge_type}: {num_edges:,} edges\")          print(\"\\n\u2705 Complete morphological graph ready for heterogeneous GNN training!\")      else:     print(\"\u26a0\ufe0f Skipping PyTorch Geometric conversion (not installed)\")     hetero_graph = None <pre>\ud83c\udf10 Created heterogeneous morphological graph:\n   \ud83d\udcca Node types and counts:\n     \u2022 private: 1,342 nodes, 0 features\n     \u2022 public: 801 nodes, 1 features\n   \ud83d\udd17 Edge types and counts:\n     \u2022 ('private', 'touched_to', 'private'): 615 edges\n     \u2022 ('public', 'connected_to', 'public'): 1,475 edges\n     \u2022 ('private', 'faced_to', 'public'): 2,503 edges\n\n\u2705 Complete morphological graph ready for heterogeneous GNN training!\n</pre> In\u00a0[22]: Copied! <pre>hetero_graph\n</pre> hetero_graph Out[22]: <pre>HeteroData(\n  crs=EPSG:27700,\n  graph_metadata=&lt;city2graph.base.GraphMetadata object at 0x15a3a3d90&gt;,\n  private={\n    x=[1342, 0],\n    pos=[1342, 2],\n  },\n  public={\n    x=[801, 1],\n    pos=[801, 2],\n  },\n  (private, touched_to, private)={\n    edge_index=[2, 615],\n    edge_attr=[615, 0],\n  },\n  (public, connected_to, public)={\n    edge_index=[2, 1475],\n    edge_attr=[1475, 0],\n  },\n  (private, faced_to, public)={\n    edge_index=[2, 2503],\n    edge_attr=[2503, 0],\n  }\n)</pre> In\u00a0[23]: Copied! <pre>morpho_graph = c2g.gdf_to_pyg(\n    morpho_nodes,\n    morpho_edges,\n    node_feature_cols={\"private\": ['area', 'perimeter', 'compactness'],\n                       \"public\": ['length']},\n                       )\n\n# Convert morphological graph to NetworkX for traditional graph analysis\nG_morpho = c2g.gdf_to_nx(morpho_nodes, morpho_edges)\n\nprint(\"\ud83d\udd17 Converted to NetworkX:\")\nprint(f\"   \u2022 Total nodes: {G_morpho.number_of_nodes():,}\")\nprint(f\"   \u2022 Total edges: {G_morpho.number_of_edges():,}\")\nprint(f\"   \u2022 Graph type: {'Directed' if G_morpho.is_directed() else 'Undirected'}\")\n\n# Check if it's a heterogeneous graph\nhas_node_types = any('node_type' in data for _, data in G_morpho.nodes(data=True))\nprint(f\"   \u2022 Heterogeneous: {'Yes' if has_node_types else 'No'}\")\n\nif has_node_types:\n    # Count nodes by type\n    from collections import Counter\n    node_types = [data.get('node_type', 'unknown') for _, data in G_morpho.nodes(data=True)]\n    type_counts = Counter(node_types)\n    print(f\"   \u2022 Node type distribution:\")\n    for node_type, count in type_counts.items():\n        print(f\"     - {node_type}: {count:,}\")\n\nprint(\"\\n\u2705 Ready for NetworkX graph analysis algorithms!\")\n</pre> morpho_graph = c2g.gdf_to_pyg(     morpho_nodes,     morpho_edges,     node_feature_cols={\"private\": ['area', 'perimeter', 'compactness'],                        \"public\": ['length']},                        )  # Convert morphological graph to NetworkX for traditional graph analysis G_morpho = c2g.gdf_to_nx(morpho_nodes, morpho_edges)  print(\"\ud83d\udd17 Converted to NetworkX:\") print(f\"   \u2022 Total nodes: {G_morpho.number_of_nodes():,}\") print(f\"   \u2022 Total edges: {G_morpho.number_of_edges():,}\") print(f\"   \u2022 Graph type: {'Directed' if G_morpho.is_directed() else 'Undirected'}\")  # Check if it's a heterogeneous graph has_node_types = any('node_type' in data for _, data in G_morpho.nodes(data=True)) print(f\"   \u2022 Heterogeneous: {'Yes' if has_node_types else 'No'}\")  if has_node_types:     # Count nodes by type     from collections import Counter     node_types = [data.get('node_type', 'unknown') for _, data in G_morpho.nodes(data=True)]     type_counts = Counter(node_types)     print(f\"   \u2022 Node type distribution:\")     for node_type, count in type_counts.items():         print(f\"     - {node_type}: {count:,}\")  print(\"\\n\u2705 Ready for NetworkX graph analysis algorithms!\") <pre>\ud83d\udd17 Converted to NetworkX:\n   \u2022 Total nodes: 2,143\n   \u2022 Total edges: 4,593\n   \u2022 Graph type: Undirected\n   \u2022 Heterogeneous: Yes\n   \u2022 Node type distribution:\n     - private: 1,342\n     - public: 801\n\n\u2705 Ready for NetworkX graph analysis algorithms!\n</pre> In\u00a0[24]: Copied! <pre>import osmnx as ox\n\n# Download and create a street network graph for Liverpool, UK\nG_osmnx = ox.graph_from_place(\"Liverpool, UK\", network_type=\"all\")\n\nprint(f\"\u2705 OSMnx graph created for Liverpool, UK\")\nprint(f\"   \u2022 Nodes: {len(G_osmnx.nodes):,}\")\nprint(f\"   \u2022 Edges: {len(G_osmnx.edges):,}\")\n</pre> import osmnx as ox  # Download and create a street network graph for Liverpool, UK G_osmnx = ox.graph_from_place(\"Liverpool, UK\", network_type=\"all\")  print(f\"\u2705 OSMnx graph created for Liverpool, UK\") print(f\"   \u2022 Nodes: {len(G_osmnx.nodes):,}\") print(f\"   \u2022 Edges: {len(G_osmnx.edges):,}\") <pre>\u2705 OSMnx graph created for Liverpool, UK\n   \u2022 Nodes: 45,081\n   \u2022 Edges: 114,978\n</pre> In\u00a0[25]: Copied! <pre># Download POIs (amenities, shops, etc.) in Liverpool, UK\ntags = {\"building\": True}\nosm_buildings = ox.features_from_place(\"Liverpool, UK\", tags)\n\nprint(f\"\u2705 Retrieved {len(osm_buildings):,} buildings from OSMnx\")\nosm_buildings.head()\n</pre> # Download POIs (amenities, shops, etc.) in Liverpool, UK tags = {\"building\": True} osm_buildings = ox.features_from_place(\"Liverpool, UK\", tags)  print(f\"\u2705 Retrieved {len(osm_buildings):,} buildings from OSMnx\") osm_buildings.head() <pre>\u2705 Retrieved 77,492 buildings from OSMnx\n</pre> Out[25]: geometry building building:material building:use name emergency addr:street shop website addr:city ... service:bicycle:parts service:bicycle:pump service:bicycle:second_hand service:bicycle:spare_parts type school:trust school:trust:name school:trust:type manager last_checked element id node 130190976 POINT (-2.92799 53.37127) yes brick religious Saint Anne's Parish Hall - 1902 NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 252558860 POINT (-2.91785 53.396) residential NaN NaN Bradbury House NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 299317179 POINT (-2.97904 53.39175) yes NaN NaN Toxteth Ambulance Station ambulance_station NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1563152870 POINT (-2.91166 53.41248) manufacture NaN NaN Tom Williams Cake Factory NaN Broad Green Road pastry http://www.cakefactory.co.uk/ NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN 1669223582 POINT (-2.96855 53.40601) yes NaN NaN ALL (Active Learning Laboratory) NaN NaN NaN NaN NaN ... NaN NaN NaN NaN NaN NaN NaN NaN NaN NaN <p>5 rows \u00d7 378 columns</p> <p>If you want to directly convert the <code>nx.MultiGraph</code> into <code>torch_geometric.data.Data</code>,</p> In\u00a0[26]: Copied! <pre>osm_data = c2g.nx_to_pyg(G_osmnx)\n</pre> osm_data = c2g.nx_to_pyg(G_osmnx) In\u00a0[27]: Copied! <pre>osm_data\n</pre> osm_data Out[27]: <pre>Data(x=[45081, 0], edge_index=[2, 114978], edge_attr=[114978, 0], pos=[45081, 2], graph_metadata=&lt;city2graph.base.GraphMetadata object at 0x14b8aab60&gt;)</pre> <p>Or you can convert it into <code>GeoDataFrame</code> that is compatible to other functions in <code>City2Graph</code>,</p> In\u00a0[28]: Copied! <pre>osm_street_nodes, osm_street_edges =c2g.nx_to_gdf(G_osmnx)\n</pre> osm_street_nodes, osm_street_edges =c2g.nx_to_gdf(G_osmnx) In\u00a0[29]: Copied! <pre>osm_street_nodes.head()\n</pre> osm_street_nodes.head() Out[29]: y x street_count geometry highway ref junction 324206 53.407123 -2.884331 3 POINT (-2.88433 53.40712) NaN NaN NaN 324209 53.405943 -2.896571 3 POINT (-2.89657 53.40594) NaN NaN NaN 324210 53.406113 -2.896688 3 POINT (-2.89669 53.40611) motorway_junction 4 NaN 324216 53.406488 -2.899987 3 POINT (-2.89999 53.40649) NaN NaN NaN 324217 53.407391 -2.902198 3 POINT (-2.9022 53.40739) NaN NaN NaN In\u00a0[30]: Copied! <pre>osm_street_edges.head()\n</pre> osm_street_edges.head() Out[30]: osmid highway lanes maxspeed oneway ref reversed length bridge geometry name junction service access width tunnel est_width 324206 324209 0 [28181793, 627409058, 546631471, 1155945617, 1... motorway 3 [70 mph, 40 mph, 50 mph] True M62 False 823.913652 yes LINESTRING (-2.88433 53.40712, -2.88494 53.407... NaN NaN NaN NaN NaN NaN NaN 324209 3467956864 0 15215646 trunk 3 40 mph True A5080 False 52.584979 NaN LINESTRING (-2.89657 53.40594, -2.89678 53.405... Bowring Park Road NaN NaN NaN NaN NaN NaN 324210 11385898804 0 15215652 primary NaN 40 mph True A5080 False 32.304470 NaN LINESTRING (-2.89669 53.40611, -2.89629 53.406... Bowring Park Road NaN NaN NaN NaN NaN NaN 324216 21026685 0 4002276 trunk 3 40 mph True A5080 False 87.887476 NaN LINESTRING (-2.89999 53.40649, -2.90028 53.406... Edge Lane Drive NaN NaN NaN NaN NaN NaN 21026680 0 4002284 trunk_link NaN 40 mph True NaN False 61.909425 NaN LINESTRING (-2.89999 53.40649, -2.90029 53.406... NaN NaN NaN NaN NaN NaN NaN <p>To constrcut a morphological graph,</p> In\u00a0[31]: Copied! <pre>osm_buildings = osm_buildings.to_crs(epsg=27700)\nosm_street_edges = osm_street_edges.to_crs(epsg=27700)\n</pre> osm_buildings = osm_buildings.to_crs(epsg=27700) osm_street_edges = osm_street_edges.to_crs(epsg=27700) In\u00a0[32]: Copied! <pre># Exclude rows with point geometries from osm_buildings\nosm_buildings = osm_buildings[osm_buildings.geometry.type != \"Point\"]\n</pre> # Exclude rows with point geometries from osm_buildings osm_buildings = osm_buildings[osm_buildings.geometry.type != \"Point\"] In\u00a0[33]: Copied! <pre># Define center point for the analysis area (Liverpool city centre)\ncenter_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)\n\n# Create the morphological graph\nprint(\"\ud83c\udfd7\ufe0f  Creating morphological graph...\")\nmorpho_nodes, morpho_edges = c2g.morphological_graph(\n    buildings_gdf=osm_buildings,\n    segments_gdf=osm_street_edges,\n    center_point=center_point,\n    distance=500,                    # Analysis radius in meters\n    clipping_buffer=300,            # Buffer for edge effects\n    primary_barrier_col='barrier_geometry',\n    contiguity=\"queen\",             # Adjacency rule for tessellation\n    keep_buildings=True,            # Preserve building geometries\n    keep_segments=True,             # Preserve street segment geometries\n)\n</pre> # Define center point for the analysis area (Liverpool city centre) center_point = gpd.GeoSeries([Point(-2.9879004, 53.4062724)], crs='EPSG:4326').to_crs(epsg=27700)  # Create the morphological graph print(\"\ud83c\udfd7\ufe0f  Creating morphological graph...\") morpho_nodes, morpho_edges = c2g.morphological_graph(     buildings_gdf=osm_buildings,     segments_gdf=osm_street_edges,     center_point=center_point,     distance=500,                    # Analysis radius in meters     clipping_buffer=300,            # Buffer for edge effects     primary_barrier_col='barrier_geometry',     contiguity=\"queen\",             # Adjacency rule for tessellation     keep_buildings=True,            # Preserve building geometries     keep_segments=True,             # Preserve street segment geometries ) <pre>\ud83c\udfd7\ufe0f  Creating morphological graph...\n</pre> <pre>/Users/yutasato/Projects/Liverpool/city2graph/.venv/lib/python3.13/site-packages/libpysal/weights/contiguity.py:347: UserWarning: The weights matrix is not fully connected: \n There are 3 disconnected components.\n There are 2 islands with ids: 50_('way', 659554384), 50_('way', 659554386).\n  W.__init__(self, neighbors, ids=ids, **kw)\n</pre> In\u00a0[34]: Copied! <pre>print(f\"   \u2022 Node types: {list(morpho_nodes.keys())}\")\nprint(f\"   \u2022 Edge types: {list(morpho_edges.keys())}\")\nprint(f\"   \u2022 Private spaces: {len(morpho_nodes['private']):,}\")\nprint(f\"   \u2022 Public spaces: {len(morpho_nodes['public']):,}\")\n\nfor edge_type, edge_gdf in morpho_edges.items():\n    print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\")\n</pre> print(f\"   \u2022 Node types: {list(morpho_nodes.keys())}\") print(f\"   \u2022 Edge types: {list(morpho_edges.keys())}\") print(f\"   \u2022 Private spaces: {len(morpho_nodes['private']):,}\") print(f\"   \u2022 Public spaces: {len(morpho_nodes['public']):,}\")  for edge_type, edge_gdf in morpho_edges.items():     print(f\"   \u2022 {edge_type}: {len(edge_gdf):,} connections\") <pre>   \u2022 Node types: ['private', 'public']\n   \u2022 Edge types: [('private', 'touched_to', 'private'), ('public', 'connected_to', 'public'), ('private', 'faced_to', 'public')]\n   \u2022 Private spaces: 1,489\n   \u2022 Public spaces: 651\n   \u2022 ('private', 'touched_to', 'private'): 564 connections\n   \u2022 ('public', 'connected_to', 'public'): 1,299 connections\n   \u2022 ('private', 'faced_to', 'public'): 3,276 connections\n</pre> In\u00a0[35]: Copied! <pre>fig, ax = plt.subplots(figsize=(14, 12), facecolor='#f9f9f9')\n\nmorpho_nodes[\"private\"][\"building_geometry\"].plot(ax=ax, color='#e0e0e0', edgecolor='#c0c0c0', linewidth=0.3, alpha=0.7)\nmorpho_nodes[\"public\"][\"segment_geometry\"].plot(ax=ax, color='#404040', linewidth=0.7, alpha=0.6)\n\nc2g.plot_graph(\n    nodes=morpho_nodes,\n    edges=morpho_edges,\n    subplots=False,\n    ax=ax,\n    bgcolor=\"#f9f9f9\",\n    labelcolor=\"#000000\",\n    node_color={'private': 'red', 'public': 'blue'},\n    edge_color={\n        ('private', 'touched_to', 'private'): '#B22222',\n        ('public', 'connected_to', 'public'): '#0000FF',\n        ('private', 'faced_to', 'public'): '#7B68EE',\n    },\n    markersize=10,\n    linewidth=0.2,\n)\n</pre> fig, ax = plt.subplots(figsize=(14, 12), facecolor='#f9f9f9')  morpho_nodes[\"private\"][\"building_geometry\"].plot(ax=ax, color='#e0e0e0', edgecolor='#c0c0c0', linewidth=0.3, alpha=0.7) morpho_nodes[\"public\"][\"segment_geometry\"].plot(ax=ax, color='#404040', linewidth=0.7, alpha=0.6)  c2g.plot_graph(     nodes=morpho_nodes,     edges=morpho_edges,     subplots=False,     ax=ax,     bgcolor=\"#f9f9f9\",     labelcolor=\"#000000\",     node_color={'private': 'red', 'public': 'blue'},     edge_color={         ('private', 'touched_to', 'private'): '#B22222',         ('public', 'connected_to', 'public'): '#0000FF',         ('private', 'faced_to', 'public'): '#7B68EE',     },     markersize=10,     linewidth=0.2, ) Out[35]: <pre>&lt;Axes: &gt;</pre> In\u00a0[36]: Copied! <pre>osm_hetero_data = c2g.gdf_to_pyg(morpho_nodes, morpho_edges)\n</pre> osm_hetero_data = c2g.gdf_to_pyg(morpho_nodes, morpho_edges) In\u00a0[37]: Copied! <pre>osm_hetero_data\n</pre> osm_hetero_data Out[37]: <pre>HeteroData(\n  crs=EPSG:27700,\n  graph_metadata=&lt;city2graph.base.GraphMetadata object at 0x14bcc2270&gt;,\n  private={\n    x=[1489, 0],\n    pos=[1489, 2],\n  },\n  public={\n    x=[651, 0],\n    pos=[651, 2],\n  },\n  (private, touched_to, private)={\n    edge_index=[2, 564],\n    edge_attr=[564, 0],\n  },\n  (public, connected_to, public)={\n    edge_index=[2, 1299],\n    edge_attr=[1299, 0],\n  },\n  (private, faced_to, public)={\n    edge_index=[2, 3276],\n    edge_attr=[3276, 0],\n  }\n)</pre>"},{"location":"examples/morphological_graph_from_overturemaps.html#morphological-graph-from-overture-maps-openstreetmap-with-city2graph","title":"Morphological Graph from Overture Maps &amp; OpenStreetMap with City2Graph\u00b6","text":"<p>This notebook demonstrates how to create morphological graph using <code>City2Graph</code> and data from Overture Maps. Morphological graph provide a comprehensive graph representation of urban form that captures the relationships between public and private spaces in cities.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#what-are-morphological-graphs","title":"What are Morphological Graphs?\u00b6","text":"<p>Morphological graphs are heterogeneous graphs where:</p> <ul> <li>Nodes represent both public spaces (street segments) and private spaces (enclosed areas/tessellations)</li> <li>Edges capture three types of spatial relationships:<ul> <li>\ud83d\udd34 Private-to-private: Adjacency between neighboring private spaces</li> <li>\ud83d\udd35 Public-to-public: Connectivity along street networks (dual graph representation)</li> <li>\ud83d\udfe3 Private-to-public: Interface between private spaces and adjacent streets</li> </ul> </li> </ul>"},{"location":"examples/morphological_graph_from_overturemaps.html#workflow-overview","title":"Workflow Overview\u00b6","text":"<ol> <li>Data Loading: Import building footprints and street segments from Overture Maps</li> <li>Data Processing: Clean and prepare spatial data for network creation</li> <li>Morphological Graph Generation: Create tessellations and extract spatial relationships</li> <li>Graph Conversion: Convert to PyTorch Geometric for machine learning applications</li> <li>Visualization: Explore the resulting morphological graph</li> </ol> <p>This approach enables advanced urban analytics including connectivity analysis, accessibility studies, and graph-based machine learning for urban form analysis.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#1-setup-and-dependencies","title":"1. Setup and Dependencies\u00b6","text":""},{"location":"examples/morphological_graph_from_overturemaps.html#2-loading-data-from-overture-maps","title":"2. Loading Data from Overture Maps\u00b6","text":"<p>We'll work with real urban data from Liverpool, UK, using Overture Maps which provides high-quality, open geospatial data including:</p> <ul> <li>Building footprints: Representing private/built spaces</li> <li>Road segments: Representing the street network</li> <li>Connectors: Intersection points in the road network</li> </ul> <p>The data covers Liverpool city centre and demonstrates how City2Graph can process real-world urban environments.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#3-street-network-processing","title":"3. Street Network Processing\u00b6","text":"<p>Before creating morphological graphs, we need to process the raw street data. This involves:</p> <ol> <li>Filtering: Keep only road segments (exclude pedestrian paths, railways, etc.)</li> <li>Barrier Processing: Handle bridges and tunnels to create accurate spatial barriers</li> <li>Network Cleanup: Ensure proper connectivity for graph operations</li> </ol> <p>The <code>barrier_geometry</code> column will contain the processed geometries that act as spatial barriers for tessellation.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#4-creating-morphological-graphs","title":"4. Creating Morphological Graphs\u00b6","text":"<p>Now we'll create the morphological graph - the core contribution of City2Graph. This process:</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#the-process","title":"The Process:\u00b6","text":"<ol> <li>Tessellation Creation: Divide space into private areas using street segments as barriers</li> <li>Network Extraction: Identify three types of spatial relationships:<ul> <li>Private-to-private (red): Adjacency between neighboring private spaces</li> <li>Public-to-public (blue): Connectivity along street networks</li> <li>Private-to-public (purple): Interface between private spaces and streets</li> </ul> </li> </ol>"},{"location":"examples/morphological_graph_from_overturemaps.html#why-morphological-graphs","title":"Why Morphological Graphs?\u00b6","text":"<p>Unlike traditional approaches that analyze street networks and buildings separately, morphological graphs provide a unified representation of urban space that:</p> <ul> <li>Captures the complete topology of public and private spaces</li> <li>Enables holistic urban analysis combining street accessibility and land use</li> <li>Provides a foundation for spatially-explicit graph machine learning</li> <li>Supports integration of diverse urban attributes (POIs, demographics, functions)</li> </ul>"},{"location":"examples/morphological_graph_from_overturemaps.html#6-converting-to-graph-representations-for-machine-learning","title":"6. Converting to Graph Representations for Machine Learning\u00b6","text":"<p>City2Graph provides seamless conversion between spatial data and graph formats optimized for machine learning. We'll demonstrate conversion to PyTorch Geometric, enabling advanced graph neural network applications for urban analysis.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#graph-format-support","title":"Graph Format Support:\u00b6","text":"<ul> <li>NetworkX: For traditional graph analysis and algorithms</li> <li>PyTorch Geometric: For deep learning on graphs</li> <li>GeoDataFrames: For spatial analysis and visualization</li> </ul> <p>This interoperability allows researchers to leverage the best tools for each analysis task.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#61-homogeneous-graph-private-space-network","title":"6.1 Homogeneous Graph: Private Space Network\u00b6","text":"<p>Let's start with a homogeneous graph focusing on private spaces (tessellation cells) and their adjacency relationships. This represents the spatial structure of plots and parcels in the urban environment.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#test-graph-conversions","title":"Test Graph Conversions\u00b6","text":"<p>Let's test the round-trip conversions between different graph formats to ensure data integrity:</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#62-heterogeneous-graph-complete-morphological-graph","title":"6.2 Heterogeneous Graph: Complete Morphological Graph\u00b6","text":"<p>Now let's create a heterogeneous graph that captures the full morphological graph with all node and edge types. This provides the complete representation for advanced urban analysis.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#63-using-networkx","title":"6.3 Using NetworkX\u00b6","text":"<p>City2Graph provides seamless conversion to NetworkX for traditional graph analysis and algorithms. This enables access to the rich ecosystem of graph analysis tools.</p>"},{"location":"examples/morphological_graph_from_overturemaps.html#7-openstreetmap","title":"7. OpenStreetMap\u00b6","text":"<p>As a reference, you can execute the same process using OpenStreetMap dataset, extracted by <code>osmnx</code>.</p>"}]}